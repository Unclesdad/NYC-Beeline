"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/routes";
exports.ids = ["pages/api/routes"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%5Cpages%5Capi%5Croutes.ts&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%5Cpages%5Capi%5Croutes.ts&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src\\pages\\api\\routes.ts */ \"(api)/./src/pages/api/routes.ts\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/routes\",\n        pathname: \"/api/routes\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRnJvdXRlcyZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnNyYyU1Q3BhZ2VzJTVDYXBpJTVDcm91dGVzLnRzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNMO0FBQzFEO0FBQ3lEO0FBQ3pEO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyxxREFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMscURBQVE7QUFDcEM7QUFDTyx3QkFBd0IsZ0hBQW1CO0FBQ2xEO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWJlZWxpbmUvPzZkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3NyY1xcXFxwYWdlc1xcXFxhcGlcXFxccm91dGVzLnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvcm91dGVzXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvcm91dGVzXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogXCJcIixcbiAgICAgICAgZmlsZW5hbWU6IFwiXCJcbiAgICB9LFxuICAgIHVzZXJsYW5kXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMtYXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%5Cpages%5Capi%5Croutes.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transitAPI: () => (/* binding */ transitAPI)\n/* harmony export */ });\n// API configuration\nconst API_CONFIG = {\n    MTA_BASE_URL: \"https://api.mta.info/api\",\n    CITIBIKE_BASE_URL: \"https://gbfs.citibikenyc.com/gbfs/en\",\n    UBER_BASE_URL: \"https://api.uber.com/v1\",\n    GOOGLE_MAPS_BASE_URL: \"https://maps.googleapis.com/maps/api\"\n};\n// Mock data (in a real app, these would be API calls)\nconst mockSubwayData = [\n    {\n        line: \"A\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"C\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"E\",\n        status: \"delayed\",\n        delay: 10,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"B\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"D\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"F\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"M\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"G\",\n        status: \"delayed\",\n        delay: 5,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"L\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"N\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"Q\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"R\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"W\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"1\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"2\",\n        status: \"delayed\",\n        delay: 8,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"3\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"4\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"5\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"6\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"7\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"J\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"Z\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"S\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    }\n];\nconst mockBusRoutes = [\n    \"Q58\",\n    \"Q59\",\n    \"Q60\",\n    \"B41\",\n    \"B42\",\n    \"B44\",\n    \"B45\",\n    \"B46\",\n    \"M1\",\n    \"M2\",\n    \"M3\",\n    \"M4\",\n    \"M5\",\n    \"BX1\",\n    \"BX2\",\n    \"BX9\",\n    \"BX10\",\n    \"S40\",\n    \"S44\",\n    \"S46\",\n    \"S48\"\n];\nconst generateMockBusData = ()=>{\n    return mockBusRoutes.map((route)=>({\n            route,\n            location: {\n                lat: 40.7128 + (Math.random() - 0.5) * 0.2,\n                lng: -74.0060 + (Math.random() - 0.5) * 0.2\n            },\n            next_stop: `${route} Stop ${Math.floor(Math.random() * 20) + 1}`,\n            estimated_arrival: new Date(Date.now() + Math.floor(Math.random() * 20) * 60000).toISOString(),\n            crowd_level: [\n                \"low\",\n                \"medium\",\n                \"high\"\n            ][Math.floor(Math.random() * 3)]\n        }));\n};\n// API service functions\nclass TransitAPI {\n    // Subway data\n    async getSubwayStatus() {\n        // In a real app, this would be an API call to MTA\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/subway/status`).then(res => res.data);\n        // Using mock data for now\n        return Promise.resolve(mockSubwayData);\n    }\n    async getSubwayLine(line) {\n        // In a real app, this would be an API call to MTA\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/subway/line/${line}`).then(res => res.data);\n        // Using mock data for now\n        const lineData = mockSubwayData.find((subway)=>subway.line === line);\n        return Promise.resolve(lineData || null);\n    }\n    // Bus data\n    async getBusRoutes(borough) {\n        // In a real app, this would be an API call\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/bus/routes?borough=${borough}`).then(res => res.data);\n        // Using mock data filtered by borough prefix\n        const boroughPrefix = borough.charAt(0).toUpperCase();\n        const routes = mockBusRoutes.filter((route)=>route.startsWith(boroughPrefix));\n        return Promise.resolve(routes);\n    }\n    async getBusLocations(route) {\n        // In a real app, this would be an API call\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/bus/route/${route}/locations`).then(res => res.data);\n        // Using mock data\n        const busData = generateMockBusData().filter((bus)=>bus.route === route);\n        return Promise.resolve(busData);\n    }\n    // Bike data\n    async getBikeStations(lat, lng, radius = 1) {\n        // In a real app, this would be an API call to Citi Bike\n        // return axios.get(`${API_CONFIG.CITIBIKE_BASE_URL}/station_information.json`).then(res => res.data.data.stations);\n        // Generate mock bike stations around the provided coordinates\n        const stations = [];\n        const stationCount = Math.floor(Math.random() * 5) + 3; // 3-7 stations\n        for(let i = 0; i < stationCount; i++){\n            const stationLat = lat + (Math.random() - 0.5) * 0.02 * radius;\n            const stationLng = lng + (Math.random() - 0.5) * 0.02 * radius;\n            stations.push({\n                station_id: `station-${i}`,\n                name: `Bike Station ${i + 1}`,\n                location: {\n                    lat: stationLat,\n                    lng: stationLng\n                },\n                available_bikes: Math.floor(Math.random() * 15),\n                available_docks: Math.floor(Math.random() * 10)\n            });\n        }\n        return Promise.resolve(stations);\n    }\n    // Uber/Taxi data\n    async getUberEstimate(startLat, startLng, endLat, endLng) {\n        // In a real app, this would be an API call to Uber\n        // return axios.get(`${API_CONFIG.UBER_BASE_URL}/estimates/price?start_latitude=${startLat}&start_longitude=${startLng}&end_latitude=${endLat}&end_longitude=${endLng}`).then(res => res.data.prices);\n        // Generate mock Uber options\n        const options = [\n            {\n                product_id: \"uberx\",\n                display_name: \"UberX\"\n            },\n            {\n                product_id: \"uberxl\",\n                display_name: \"UberXL\"\n            },\n            {\n                product_id: \"uberblack\",\n                display_name: \"Uber Black\"\n            },\n            {\n                product_id: \"uberpool\",\n                display_name: \"Uber Pool\"\n            }\n        ];\n        // Calculate mock duration and fare based on distance\n        const distance = this.calculateDistance(startLat, startLng, endLat, endLng);\n        return Promise.resolve(options.map((option)=>({\n                ...option,\n                estimate: {\n                    duration: Math.floor(distance * 120),\n                    fare: Math.floor((option.product_id === \"uberpool\" ? 2.0 : 2.5) * distance * 100) / 100\n                }\n            })));\n    }\n    async getTaxiEstimate(startLat, startLng, endLat, endLng) {\n        // In a real app, this would be an API call or calculation\n        // return axios.get(`${API_CONFIG.TAXI_BASE_URL}/estimate?start_latitude=${startLat}&start_longitude=${startLng}&end_latitude=${endLat}&end_longitude=${endLng}`).then(res => res.data.fare);\n        // Calculate mock taxi fare based on distance\n        const distance = this.calculateDistance(startLat, startLng, endLat, endLng);\n        const baseFare = 2.50;\n        const perMileFare = 2.50;\n        return Promise.resolve(Math.floor((baseFare + distance * perMileFare) * 100) / 100);\n    }\n    // Helper functions\n    calculateDistance(lat1, lng1, lat2, lng2) {\n        const R = 3958.8; // Earth radius in miles\n        const dLat = this.toRadians(lat2 - lat1);\n        const dLng = this.toRadians(lng2 - lng1);\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        const distance = R * c;\n        return distance;\n    }\n    toRadians(degrees) {\n        return degrees * Math.PI / 180;\n    }\n}\n// Export a singleton instance\nconst transitAPI = new TransitAPI();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sS0FBSzlELEtBQUtrRSxHQUFHLENBQUNKLE9BQU8sS0FDckM5RCxLQUFLbUUsR0FBRyxDQUFDLElBQUksQ0FBQ0osU0FBUyxDQUFDTixTQUFTekQsS0FBS21FLEdBQUcsQ0FBQyxJQUFJLENBQUNKLFNBQVMsQ0FBQ0osU0FDekQzRCxLQUFLa0UsR0FBRyxDQUFDRixPQUFPLEtBQUtoRSxLQUFLa0UsR0FBRyxDQUFDRixPQUFPO1FBQ3ZDLE1BQU1JLElBQUksSUFBSXBFLEtBQUtxRSxLQUFLLENBQUNyRSxLQUFLc0UsSUFBSSxDQUFDTCxJQUFJakUsS0FBS3NFLElBQUksQ0FBQyxJQUFJTDtRQUNyRCxNQUFNakIsV0FBV2EsSUFBSU87UUFFckIsT0FBT3BCO0lBQ1Q7SUFFUWUsVUFBVVEsT0FBZSxFQUFVO1FBQ3pDLE9BQU9BLFVBQVV2RSxLQUFLd0UsRUFBRSxHQUFHO0lBQzdCO0FBQ0Y7QUFFQSw4QkFBOEI7QUFDdkIsTUFBTUMsYUFBYSxJQUFJaEUsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1iZWVsaW5lLy4vc3JjL2xpYi9hcGkudHM/MmZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5cclxuLy8gQVBJIGNvbmZpZ3VyYXRpb25cclxuY29uc3QgQVBJX0NPTkZJRyA9IHtcclxuICBNVEFfQkFTRV9VUkw6ICdodHRwczovL2FwaS5tdGEuaW5mby9hcGknLFxyXG4gIENJVElCSUtFX0JBU0VfVVJMOiAnaHR0cHM6Ly9nYmZzLmNpdGliaWtlbnljLmNvbS9nYmZzL2VuJyxcclxuICBVQkVSX0JBU0VfVVJMOiAnaHR0cHM6Ly9hcGkudWJlci5jb20vdjEnLFxyXG4gIEdPT0dMRV9NQVBTX0JBU0VfVVJMOiAnaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpJyxcclxufTtcclxuXHJcbi8vIFRyYW5zaXQgZGF0YSBpbnRlcmZhY2VzXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3Vid2F5RGF0YSB7XHJcbiAgbGluZTogc3RyaW5nO1xyXG4gIHN0YXR1czogc3RyaW5nO1xyXG4gIGRlbGF5OiBudW1iZXI7IC8vIGluIG1pbnV0ZXNcclxuICBjcm93ZF9sZXZlbDogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCdXNEYXRhIHtcclxuICByb3V0ZTogc3RyaW5nO1xyXG4gIGxvY2F0aW9uOiB7XHJcbiAgICBsYXQ6IG51bWJlcjtcclxuICAgIGxuZzogbnVtYmVyO1xyXG4gIH07XHJcbiAgbmV4dF9zdG9wOiBzdHJpbmc7XHJcbiAgZXN0aW1hdGVkX2Fycml2YWw6IHN0cmluZztcclxuICBjcm93ZF9sZXZlbDogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBCaWtlRGF0YSB7XHJcbiAgc3RhdGlvbl9pZDogc3RyaW5nO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBsb2NhdGlvbjoge1xyXG4gICAgbGF0OiBudW1iZXI7XHJcbiAgICBsbmc6IG51bWJlcjtcclxuICB9O1xyXG4gIGF2YWlsYWJsZV9iaWtlczogbnVtYmVyO1xyXG4gIGF2YWlsYWJsZV9kb2NrczogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFViZXJEYXRhIHtcclxuICBwcm9kdWN0X2lkOiBzdHJpbmc7XHJcbiAgZGlzcGxheV9uYW1lOiBzdHJpbmc7XHJcbiAgZXN0aW1hdGU6IHtcclxuICAgIGR1cmF0aW9uOiBudW1iZXI7IC8vIGluIHNlY29uZHNcclxuICAgIGZhcmU6IG51bWJlcjsgLy8gaW4gZG9sbGFyc1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIE1vY2sgZGF0YSAoaW4gYSByZWFsIGFwcCwgdGhlc2Ugd291bGQgYmUgQVBJIGNhbGxzKVxyXG5jb25zdCBtb2NrU3Vid2F5RGF0YTogU3Vid2F5RGF0YVtdID0gW1xyXG4gIHsgbGluZTogJ0EnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXHJcbiAgeyBsaW5lOiAnQycsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ2xvdycgfSxcclxuICB7IGxpbmU6ICdFJywgc3RhdHVzOiAnZGVsYXllZCcsIGRlbGF5OiAxMCwgY3Jvd2RfbGV2ZWw6ICdoaWdoJyB9LFxyXG4gIHsgbGluZTogJ0InLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXHJcbiAgeyBsaW5lOiAnRCcsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ21lZGl1bScgfSxcclxuICB7IGxpbmU6ICdGJywgc3RhdHVzOiAnbm9ybWFsJywgZGVsYXk6IDAsIGNyb3dkX2xldmVsOiAnbWVkaXVtJyB9LFxyXG4gIHsgbGluZTogJ00nLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXHJcbiAgeyBsaW5lOiAnRycsIHN0YXR1czogJ2RlbGF5ZWQnLCBkZWxheTogNSwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXHJcbiAgeyBsaW5lOiAnTCcsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ2hpZ2gnIH0sXHJcbiAgeyBsaW5lOiAnTicsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ21lZGl1bScgfSxcclxuICB7IGxpbmU6ICdRJywgc3RhdHVzOiAnbm9ybWFsJywgZGVsYXk6IDAsIGNyb3dkX2xldmVsOiAnbWVkaXVtJyB9LFxyXG4gIHsgbGluZTogJ1InLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXHJcbiAgeyBsaW5lOiAnVycsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ2xvdycgfSxcclxuICB7IGxpbmU6ICcxJywgc3RhdHVzOiAnbm9ybWFsJywgZGVsYXk6IDAsIGNyb3dkX2xldmVsOiAnbWVkaXVtJyB9LFxyXG4gIHsgbGluZTogJzInLCBzdGF0dXM6ICdkZWxheWVkJywgZGVsYXk6IDgsIGNyb3dkX2xldmVsOiAnaGlnaCcgfSxcclxuICB7IGxpbmU6ICczJywgc3RhdHVzOiAnbm9ybWFsJywgZGVsYXk6IDAsIGNyb3dkX2xldmVsOiAnbWVkaXVtJyB9LFxyXG4gIHsgbGluZTogJzQnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdoaWdoJyB9LFxyXG4gIHsgbGluZTogJzUnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXHJcbiAgeyBsaW5lOiAnNicsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ2hpZ2gnIH0sXHJcbiAgeyBsaW5lOiAnNycsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ21lZGl1bScgfSxcclxuICB7IGxpbmU6ICdKJywgc3RhdHVzOiAnbm9ybWFsJywgZGVsYXk6IDAsIGNyb3dkX2xldmVsOiAnbG93JyB9LFxyXG4gIHsgbGluZTogJ1onLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXHJcbiAgeyBsaW5lOiAnUycsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ2xvdycgfSxcclxuXTtcclxuXHJcbmNvbnN0IG1vY2tCdXNSb3V0ZXM6IHN0cmluZ1tdID0gWydRNTgnLCAnUTU5JywgJ1E2MCcsICdCNDEnLCAnQjQyJywgJ0I0NCcsICdCNDUnLCAnQjQ2JywgJ00xJywgJ00yJywgJ00zJywgJ000JywgJ001JywgJ0JYMScsICdCWDInLCAnQlg5JywgJ0JYMTAnLCAnUzQwJywgJ1M0NCcsICdTNDYnLCAnUzQ4J107XHJcblxyXG5jb25zdCBnZW5lcmF0ZU1vY2tCdXNEYXRhID0gKCk6IEJ1c0RhdGFbXSA9PiB7XHJcbiAgcmV0dXJuIG1vY2tCdXNSb3V0ZXMubWFwKHJvdXRlID0+ICh7XHJcbiAgICByb3V0ZSxcclxuICAgIGxvY2F0aW9uOiB7XHJcbiAgICAgIGxhdDogNDAuNzEyOCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMixcclxuICAgICAgbG5nOiAtNzQuMDA2MCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMixcclxuICAgIH0sXHJcbiAgICBuZXh0X3N0b3A6IGAke3JvdXRlfSBTdG9wICR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApICsgMX1gLFxyXG4gICAgZXN0aW1hdGVkX2Fycml2YWw6IG5ldyBEYXRlKERhdGUubm93KCkgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCkgKiA2MDAwMCkudG9JU09TdHJpbmcoKSxcclxuICAgIGNyb3dkX2xldmVsOiBbJ2xvdycsICdtZWRpdW0nLCAnaGlnaCddW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMpXSBhcyAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnLFxyXG4gIH0pKTtcclxufTtcclxuXHJcbi8vIEFQSSBzZXJ2aWNlIGZ1bmN0aW9uc1xyXG5jbGFzcyBUcmFuc2l0QVBJIHtcclxuICAvLyBTdWJ3YXkgZGF0YVxyXG4gIGFzeW5jIGdldFN1YndheVN0YXR1cygpOiBQcm9taXNlPFN1YndheURhdGFbXT4ge1xyXG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZSBhbiBBUEkgY2FsbCB0byBNVEFcclxuICAgIC8vIHJldHVybiBheGlvcy5nZXQoYCR7QVBJX0NPTkZJRy5NVEFfQkFTRV9VUkx9L3N1YndheS9zdGF0dXNgKS50aGVuKHJlcyA9PiByZXMuZGF0YSk7XHJcbiAgICBcclxuICAgIC8vIFVzaW5nIG1vY2sgZGF0YSBmb3Igbm93XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1vY2tTdWJ3YXlEYXRhKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFN1YndheUxpbmUobGluZTogc3RyaW5nKTogUHJvbWlzZTxTdWJ3YXlEYXRhIHwgbnVsbD4ge1xyXG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZSBhbiBBUEkgY2FsbCB0byBNVEFcclxuICAgIC8vIHJldHVybiBheGlvcy5nZXQoYCR7QVBJX0NPTkZJRy5NVEFfQkFTRV9VUkx9L3N1YndheS9saW5lLyR7bGluZX1gKS50aGVuKHJlcyA9PiByZXMuZGF0YSk7XHJcbiAgICBcclxuICAgIC8vIFVzaW5nIG1vY2sgZGF0YSBmb3Igbm93XHJcbiAgICBjb25zdCBsaW5lRGF0YSA9IG1vY2tTdWJ3YXlEYXRhLmZpbmQoc3Vid2F5ID0+IHN1YndheS5saW5lID09PSBsaW5lKTtcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobGluZURhdGEgfHwgbnVsbCk7XHJcbiAgfVxyXG5cclxuICAvLyBCdXMgZGF0YVxyXG4gIGFzeW5jIGdldEJ1c1JvdXRlcyhib3JvdWdoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XHJcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIGFuIEFQSSBjYWxsXHJcbiAgICAvLyByZXR1cm4gYXhpb3MuZ2V0KGAke0FQSV9DT05GSUcuTVRBX0JBU0VfVVJMfS9idXMvcm91dGVzP2Jvcm91Z2g9JHtib3JvdWdofWApLnRoZW4ocmVzID0+IHJlcy5kYXRhKTtcclxuICAgIFxyXG4gICAgLy8gVXNpbmcgbW9jayBkYXRhIGZpbHRlcmVkIGJ5IGJvcm91Z2ggcHJlZml4XHJcbiAgICBjb25zdCBib3JvdWdoUHJlZml4ID0gYm9yb3VnaC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcclxuICAgIGNvbnN0IHJvdXRlcyA9IG1vY2tCdXNSb3V0ZXMuZmlsdGVyKHJvdXRlID0+IHJvdXRlLnN0YXJ0c1dpdGgoYm9yb3VnaFByZWZpeCkpO1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyb3V0ZXMpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0QnVzTG9jYXRpb25zKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPEJ1c0RhdGFbXT4ge1xyXG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZSBhbiBBUEkgY2FsbFxyXG4gICAgLy8gcmV0dXJuIGF4aW9zLmdldChgJHtBUElfQ09ORklHLk1UQV9CQVNFX1VSTH0vYnVzL3JvdXRlLyR7cm91dGV9L2xvY2F0aW9uc2ApLnRoZW4ocmVzID0+IHJlcy5kYXRhKTtcclxuICAgIFxyXG4gICAgLy8gVXNpbmcgbW9jayBkYXRhXHJcbiAgICBjb25zdCBidXNEYXRhID0gZ2VuZXJhdGVNb2NrQnVzRGF0YSgpLmZpbHRlcihidXMgPT4gYnVzLnJvdXRlID09PSByb3V0ZSk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJ1c0RhdGEpO1xyXG4gIH1cclxuXHJcbiAgLy8gQmlrZSBkYXRhXHJcbiAgYXN5bmMgZ2V0QmlrZVN0YXRpb25zKGxhdDogbnVtYmVyLCBsbmc6IG51bWJlciwgcmFkaXVzOiBudW1iZXIgPSAxKTogUHJvbWlzZTxCaWtlRGF0YVtdPiB7XHJcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIGFuIEFQSSBjYWxsIHRvIENpdGkgQmlrZVxyXG4gICAgLy8gcmV0dXJuIGF4aW9zLmdldChgJHtBUElfQ09ORklHLkNJVElCSUtFX0JBU0VfVVJMfS9zdGF0aW9uX2luZm9ybWF0aW9uLmpzb25gKS50aGVuKHJlcyA9PiByZXMuZGF0YS5kYXRhLnN0YXRpb25zKTtcclxuICAgIFxyXG4gICAgLy8gR2VuZXJhdGUgbW9jayBiaWtlIHN0YXRpb25zIGFyb3VuZCB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZXNcclxuICAgIGNvbnN0IHN0YXRpb25zOiBCaWtlRGF0YVtdID0gW107XHJcbiAgICBjb25zdCBzdGF0aW9uQ291bnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1KSArIDM7IC8vIDMtNyBzdGF0aW9uc1xyXG4gICAgXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRpb25Db3VudDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRpb25MYXQgPSBsYXQgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAyICogcmFkaXVzO1xyXG4gICAgICBjb25zdCBzdGF0aW9uTG5nID0gbG5nICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4wMiAqIHJhZGl1cztcclxuICAgICAgXHJcbiAgICAgIHN0YXRpb25zLnB1c2goe1xyXG4gICAgICAgIHN0YXRpb25faWQ6IGBzdGF0aW9uLSR7aX1gLFxyXG4gICAgICAgIG5hbWU6IGBCaWtlIFN0YXRpb24gJHtpICsgMX1gLFxyXG4gICAgICAgIGxvY2F0aW9uOiB7XHJcbiAgICAgICAgICBsYXQ6IHN0YXRpb25MYXQsXHJcbiAgICAgICAgICBsbmc6IHN0YXRpb25MbmcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhdmFpbGFibGVfYmlrZXM6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE1KSxcclxuICAgICAgICBhdmFpbGFibGVfZG9ja3M6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3RhdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gVWJlci9UYXhpIGRhdGFcclxuICBhc3luYyBnZXRVYmVyRXN0aW1hdGUoc3RhcnRMYXQ6IG51bWJlciwgc3RhcnRMbmc6IG51bWJlciwgZW5kTGF0OiBudW1iZXIsIGVuZExuZzogbnVtYmVyKTogUHJvbWlzZTxVYmVyRGF0YVtdPiB7XHJcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIGFuIEFQSSBjYWxsIHRvIFViZXJcclxuICAgIC8vIHJldHVybiBheGlvcy5nZXQoYCR7QVBJX0NPTkZJRy5VQkVSX0JBU0VfVVJMfS9lc3RpbWF0ZXMvcHJpY2U/c3RhcnRfbGF0aXR1ZGU9JHtzdGFydExhdH0mc3RhcnRfbG9uZ2l0dWRlPSR7c3RhcnRMbmd9JmVuZF9sYXRpdHVkZT0ke2VuZExhdH0mZW5kX2xvbmdpdHVkZT0ke2VuZExuZ31gKS50aGVuKHJlcyA9PiByZXMuZGF0YS5wcmljZXMpO1xyXG4gICAgXHJcbiAgICAvLyBHZW5lcmF0ZSBtb2NrIFViZXIgb3B0aW9uc1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IFtcclxuICAgICAgeyBwcm9kdWN0X2lkOiAndWJlcngnLCBkaXNwbGF5X25hbWU6ICdVYmVyWCcgfSxcclxuICAgICAgeyBwcm9kdWN0X2lkOiAndWJlcnhsJywgZGlzcGxheV9uYW1lOiAnVWJlclhMJyB9LFxyXG4gICAgICB7IHByb2R1Y3RfaWQ6ICd1YmVyYmxhY2snLCBkaXNwbGF5X25hbWU6ICdVYmVyIEJsYWNrJyB9LFxyXG4gICAgICB7IHByb2R1Y3RfaWQ6ICd1YmVycG9vbCcsIGRpc3BsYXlfbmFtZTogJ1ViZXIgUG9vbCcgfSxcclxuICAgIF07XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBtb2NrIGR1cmF0aW9uIGFuZCBmYXJlIGJhc2VkIG9uIGRpc3RhbmNlXHJcbiAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2Uoc3RhcnRMYXQsIHN0YXJ0TG5nLCBlbmRMYXQsIGVuZExuZyk7XHJcbiAgICBcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5tYXAob3B0aW9uID0+ICh7XHJcbiAgICAgIC4uLm9wdGlvbixcclxuICAgICAgZXN0aW1hdGU6IHtcclxuICAgICAgICBkdXJhdGlvbjogTWF0aC5mbG9vcihkaXN0YW5jZSAqIDEyMCksIC8vIDEyMCBzZWNvbmRzIHBlciBtaWxlXHJcbiAgICAgICAgZmFyZTogTWF0aC5mbG9vcigob3B0aW9uLnByb2R1Y3RfaWQgPT09ICd1YmVycG9vbCcgPyAyLjAgOiAyLjUpICogZGlzdGFuY2UgKiAxMDApIC8gMTAwLFxyXG4gICAgICB9LFxyXG4gICAgfSkpKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFRheGlFc3RpbWF0ZShzdGFydExhdDogbnVtYmVyLCBzdGFydExuZzogbnVtYmVyLCBlbmRMYXQ6IG51bWJlciwgZW5kTG5nOiBudW1iZXIpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZSBhbiBBUEkgY2FsbCBvciBjYWxjdWxhdGlvblxyXG4gICAgLy8gcmV0dXJuIGF4aW9zLmdldChgJHtBUElfQ09ORklHLlRBWElfQkFTRV9VUkx9L2VzdGltYXRlP3N0YXJ0X2xhdGl0dWRlPSR7c3RhcnRMYXR9JnN0YXJ0X2xvbmdpdHVkZT0ke3N0YXJ0TG5nfSZlbmRfbGF0aXR1ZGU9JHtlbmRMYXR9JmVuZF9sb25naXR1ZGU9JHtlbmRMbmd9YCkudGhlbihyZXMgPT4gcmVzLmRhdGEuZmFyZSk7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBtb2NrIHRheGkgZmFyZSBiYXNlZCBvbiBkaXN0YW5jZVxyXG4gICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKHN0YXJ0TGF0LCBzdGFydExuZywgZW5kTGF0LCBlbmRMbmcpO1xyXG4gICAgY29uc3QgYmFzZUZhcmUgPSAyLjUwO1xyXG4gICAgY29uc3QgcGVyTWlsZUZhcmUgPSAyLjUwO1xyXG4gICAgXHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKE1hdGguZmxvb3IoKGJhc2VGYXJlICsgZGlzdGFuY2UgKiBwZXJNaWxlRmFyZSkgKiAxMDApIC8gMTAwKTtcclxuICB9XHJcblxyXG4gIC8vIEhlbHBlciBmdW5jdGlvbnNcclxuICBwcml2YXRlIGNhbGN1bGF0ZURpc3RhbmNlKGxhdDE6IG51bWJlciwgbG5nMTogbnVtYmVyLCBsYXQyOiBudW1iZXIsIGxuZzI6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICBjb25zdCBSID0gMzk1OC44OyAvLyBFYXJ0aCByYWRpdXMgaW4gbWlsZXNcclxuICAgIGNvbnN0IGRMYXQgPSB0aGlzLnRvUmFkaWFucyhsYXQyIC0gbGF0MSk7XHJcbiAgICBjb25zdCBkTG5nID0gdGhpcy50b1JhZGlhbnMobG5nMiAtIGxuZzEpO1xyXG4gICAgY29uc3QgYSA9XHJcbiAgICAgIE1hdGguc2luKGRMYXQgLyAyKSAqIE1hdGguc2luKGRMYXQgLyAyKSArXHJcbiAgICAgIE1hdGguY29zKHRoaXMudG9SYWRpYW5zKGxhdDEpKSAqIE1hdGguY29zKHRoaXMudG9SYWRpYW5zKGxhdDIpKSAqXHJcbiAgICAgIE1hdGguc2luKGRMbmcgLyAyKSAqIE1hdGguc2luKGRMbmcgLyAyKTtcclxuICAgIGNvbnN0IGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xyXG4gICAgY29uc3QgZGlzdGFuY2UgPSBSICogYztcclxuICAgIFxyXG4gICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB0b1JhZGlhbnMoZGVncmVlczogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBkZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydCBhIHNpbmdsZXRvbiBpbnN0YW5jZVxyXG5leHBvcnQgY29uc3QgdHJhbnNpdEFQSSA9IG5ldyBUcmFuc2l0QVBJKCk7ICJdLCJuYW1lcyI6WyJBUElfQ09ORklHIiwiTVRBX0JBU0VfVVJMIiwiQ0lUSUJJS0VfQkFTRV9VUkwiLCJVQkVSX0JBU0VfVVJMIiwiR09PR0xFX01BUFNfQkFTRV9VUkwiLCJtb2NrU3Vid2F5RGF0YSIsImxpbmUiLCJzdGF0dXMiLCJkZWxheSIsImNyb3dkX2xldmVsIiwibW9ja0J1c1JvdXRlcyIsImdlbmVyYXRlTW9ja0J1c0RhdGEiLCJtYXAiLCJyb3V0ZSIsImxvY2F0aW9uIiwibGF0IiwiTWF0aCIsInJhbmRvbSIsImxuZyIsIm5leHRfc3RvcCIsImZsb29yIiwiZXN0aW1hdGVkX2Fycml2YWwiLCJEYXRlIiwibm93IiwidG9JU09TdHJpbmciLCJUcmFuc2l0QVBJIiwiZ2V0U3Vid2F5U3RhdHVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJnZXRTdWJ3YXlMaW5lIiwibGluZURhdGEiLCJmaW5kIiwic3Vid2F5IiwiZ2V0QnVzUm91dGVzIiwiYm9yb3VnaCIsImJvcm91Z2hQcmVmaXgiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInJvdXRlcyIsImZpbHRlciIsInN0YXJ0c1dpdGgiLCJnZXRCdXNMb2NhdGlvbnMiLCJidXNEYXRhIiwiYnVzIiwiZ2V0QmlrZVN0YXRpb25zIiwicmFkaXVzIiwic3RhdGlvbnMiLCJzdGF0aW9uQ291bnQiLCJpIiwic3RhdGlvbkxhdCIsInN0YXRpb25MbmciLCJwdXNoIiwic3RhdGlvbl9pZCIsIm5hbWUiLCJhdmFpbGFibGVfYmlrZXMiLCJhdmFpbGFibGVfZG9ja3MiLCJnZXRVYmVyRXN0aW1hdGUiLCJzdGFydExhdCIsInN0YXJ0TG5nIiwiZW5kTGF0IiwiZW5kTG5nIiwib3B0aW9ucyIsInByb2R1Y3RfaWQiLCJkaXNwbGF5X25hbWUiLCJkaXN0YW5jZSIsImNhbGN1bGF0ZURpc3RhbmNlIiwib3B0aW9uIiwiZXN0aW1hdGUiLCJkdXJhdGlvbiIsImZhcmUiLCJnZXRUYXhpRXN0aW1hdGUiLCJiYXNlRmFyZSIsInBlck1pbGVGYXJlIiwibGF0MSIsImxuZzEiLCJsYXQyIiwibG5nMiIsIlIiLCJkTGF0IiwidG9SYWRpYW5zIiwiZExuZyIsImEiLCJzaW4iLCJjb3MiLCJjIiwiYXRhbjIiLCJzcXJ0IiwiZGVncmVlcyIsIlBJIiwidHJhbnNpdEFQSSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./src/lib/api.ts\n");

/***/ }),

/***/ "(api)/./src/pages/api/routes.ts":
/*!*********************************!*\
  !*** ./src/pages/api/routes.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/api */ \"(api)/./src/lib/api.ts\");\n\n// Mock coordinates for some NYC locations\nconst locationCoordinates = {\n    \"Manhattan\": [\n        40.7831,\n        -73.9712\n    ],\n    \"Brooklyn\": [\n        40.6782,\n        -73.9442\n    ],\n    \"Queens\": [\n        40.7282,\n        -73.7949\n    ],\n    \"Bronx\": [\n        40.8448,\n        -73.8648\n    ],\n    \"Staten Island\": [\n        40.5795,\n        -74.1502\n    ],\n    \"Times Square\": [\n        40.7580,\n        -73.9855\n    ],\n    \"Central Park\": [\n        40.7829,\n        -73.9654\n    ],\n    \"Prospect Park\": [\n        40.6602,\n        -73.9690\n    ],\n    \"Flushing Meadows\": [\n        40.7466,\n        -73.8422\n    ],\n    \"Flushing\": [\n        40.7654,\n        -73.8318\n    ],\n    \"Bayside\": [\n        40.7612,\n        -73.7716\n    ],\n    \"Main St\": [\n        40.7590,\n        -73.8300\n    ],\n    \"Yankee Stadium\": [\n        40.8296,\n        -73.9262\n    ]\n};\n// Traffic data mock (in a real app this would be real-time data)\nconst trafficConditions = {\n    \"Manhattan\": {\n        level: \"high\",\n        factor: 1.5\n    },\n    \"Brooklyn\": {\n        level: \"medium\",\n        factor: 1.3\n    },\n    \"Queens\": {\n        level: \"medium\",\n        factor: 1.2\n    },\n    \"Bronx\": {\n        level: \"medium\",\n        factor: 1.25\n    },\n    \"Staten Island\": {\n        level: \"low\",\n        factor: 1.1\n    },\n    \"Flushing\": {\n        level: \"medium\",\n        factor: 1.2\n    },\n    \"Bayside\": {\n        level: \"low\",\n        factor: 1.1\n    },\n    \"Times Square\": {\n        level: \"high\",\n        factor: 1.6\n    },\n    \"Central Park\": {\n        level: \"medium\",\n        factor: 1.3\n    }\n};\n// Topology data - elevation changes that affect walking/biking comfort\nconst topologyDifficulty = {\n    \"Manhattan\": 0.2,\n    \"Brooklyn\": 0.1,\n    \"Queens\": 0.1,\n    \"Bronx\": 0.4,\n    \"Staten Island\": 0.5,\n    \"Flushing\": 0.1,\n    \"Bayside\": 0.2,\n    \"Times Square\": 0.1,\n    \"Central Park\": 0.3\n};\n// Helper function to get coordinates from a location string\nconst getCoordinates = (location)=>{\n    // Normalize the location string for better matching\n    const normalizedLocation = location.toLowerCase();\n    // First try exact matches for specific neighborhoods/locations\n    for (const [name, coords] of Object.entries(locationCoordinates)){\n        if (normalizedLocation.includes(name.toLowerCase())) {\n            return coords;\n        }\n    }\n    // If no specific match, try to determine which borough it's in\n    if (normalizedLocation.includes(\"queens\") || normalizedLocation.includes(\"flushing\") || normalizedLocation.includes(\"bayside\") || normalizedLocation.includes(\"jamaica\") || normalizedLocation.includes(\"astoria\")) {\n        return locationCoordinates[\"Queens\"];\n    }\n    if (normalizedLocation.includes(\"brooklyn\") || normalizedLocation.includes(\"williamsburg\") || normalizedLocation.includes(\"park slope\")) {\n        return locationCoordinates[\"Brooklyn\"];\n    }\n    if (normalizedLocation.includes(\"bronx\")) {\n        return locationCoordinates[\"Bronx\"];\n    }\n    if (normalizedLocation.includes(\"staten\")) {\n        return locationCoordinates[\"Staten Island\"];\n    }\n    // Default to Manhattan if not found\n    return locationCoordinates[\"Manhattan\"];\n};\n// Helper function to calculate distance between two coordinates\nconst calculateDistance = (lat1, lng1, lat2, lng2)=>{\n    const R = 3958.8; // Earth radius in miles\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c;\n    return distance;\n};\n// Define the route colors for different modes\nconst getRouteColor = (mode)=>{\n    switch(mode){\n        case \"subway\":\n            return \"#3b82f6\"; // blue-500\n        case \"bus\":\n            return \"#22c55e\"; // green-500\n        case \"ebike\":\n            return \"#8b5cf6\"; // purple-500\n        case \"taxi\":\n        case \"uber\":\n            return \"#f59e0b\"; // amber-500\n        case \"walk\":\n            return \"#6b7280\"; // gray-500\n        default:\n            return \"#ef4444\"; // red-500\n    }\n};\nasync function handler(req, res) {\n    if (req.method !== \"GET\") {\n        return res.status(405).json({\n            message: \"Method Not Allowed\"\n        });\n    }\n    const { from, to, priority, noise, safety, bags, wheelchair } = req.query;\n    if (!from || !to) {\n        return res.status(400).json({\n            message: \"Origin and destination are required\"\n        });\n    }\n    try {\n        // In a real app, we would use geocoding to get coordinates\n        const fromCoords = getCoordinates(from);\n        const toCoords = getCoordinates(to);\n        // Log the coordinates for debugging\n        console.log(`From location: \"${from}\" → coordinates: [${fromCoords[0]}, ${fromCoords[1]}]`);\n        console.log(`To location: \"${to}\" → coordinates: [${toCoords[0]}, ${toCoords[1]}]`);\n        // Get user preferences\n        const userPriority = priority || \"balanced\";\n        const userNoise = noise || \"moderate\";\n        const userSafety = safety || \"moderate\";\n        const userBags = parseInt(bags || \"0\", 10);\n        const requireWheelchair = wheelchair === \"true\";\n        // Calculate distance\n        const distance = calculateDistance(fromCoords[0], fromCoords[1], toCoords[0], toCoords[1]);\n        // Get real-time transit data\n        const subwayStatus = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.transitAPI.getSubwayStatus();\n        // Determine available subway lines based on location\n        const subwayLinesByLocation = {\n            \"Manhattan\": [\n                \"1\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"A\",\n                \"C\",\n                \"E\",\n                \"B\",\n                \"D\",\n                \"F\",\n                \"M\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"W\",\n                \"L\"\n            ],\n            \"Brooklyn\": [\n                \"A\",\n                \"C\",\n                \"G\",\n                \"J\",\n                \"Z\",\n                \"L\",\n                \"M\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\"\n            ],\n            \"Queens\": [\n                \"E\",\n                \"F\",\n                \"M\",\n                \"R\",\n                \"N\",\n                \"W\",\n                \"G\",\n                \"7\"\n            ],\n            \"Bronx\": [\n                \"1\",\n                \"2\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"B\",\n                \"D\"\n            ],\n            \"Staten Island\": [\n                \"SIR\"\n            ],\n            \"Flushing\": [\n                \"7\"\n            ],\n            \"Main St\": [\n                \"7\"\n            ],\n            \"Times Square\": [\n                \"1\",\n                \"2\",\n                \"3\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"W\",\n                \"7\",\n                \"S\"\n            ],\n            \"Central Park\": [\n                \"A\",\n                \"B\",\n                \"C\",\n                \"D\",\n                \"1\"\n            ],\n            \"Yankee Stadium\": [\n                \"4\",\n                \"B\",\n                \"D\"\n            ],\n            \"JFK Airport\": [\n                \"A\",\n                \"E\"\n            ],\n            \"LaGuardia Airport\": [],\n            \"Prospect Park\": [\n                \"B\",\n                \"Q\",\n                \"S\"\n            ]\n        };\n        // Determine from and to areas to check subway availability\n        const fromArea = Object.keys(locationCoordinates).find((area)=>from.toLowerCase().includes(area.toLowerCase())) || \"Manhattan\";\n        const toArea = Object.keys(locationCoordinates).find((area)=>to.toLowerCase().includes(area.toLowerCase())) || \"Manhattan\";\n        // Check available subway lines for the route\n        const fromSubwayLines = subwayLinesByLocation[fromArea] || [];\n        const toSubwayLines = subwayLinesByLocation[toArea] || [];\n        // Find common subway lines or lines that can get you there with a transfer\n        let availableSubwayLines = fromSubwayLines.filter((line)=>toSubwayLines.includes(line));\n        // If no direct lines, consider options with transfers\n        const hasTransferOptions = fromSubwayLines.length > 0 && toSubwayLines.length > 0;\n        // Check subway status to see if the lines are operating normally\n        const operatingSubwayLines = availableSubwayLines.filter((line)=>{\n            const lineStatus = subwayStatus.find((s)=>s.line === line);\n            return lineStatus && lineStatus.status === \"normal\";\n        });\n        // Filter to just get one operating line if available\n        const bestSubwayLine = operatingSubwayLines.length > 0 ? operatingSubwayLines[0] : null;\n        // Get all the bus routes for both areas\n        const fromBoroughPrefix = fromArea.charAt(0).toUpperCase();\n        const toBoroughPrefix = toArea.charAt(0).toUpperCase();\n        const busRoutesFrom = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.transitAPI.getBusRoutes(fromArea);\n        // Map specific neighborhoods to appropriate bus routes\n        const busRoutesByArea = {\n            \"Manhattan\": [\n                \"M1\",\n                \"M2\",\n                \"M3\",\n                \"M4\",\n                \"M5\",\n                \"M15\",\n                \"M31\",\n                \"M42\",\n                \"M60\"\n            ],\n            \"Brooklyn\": [\n                \"B41\",\n                \"B42\",\n                \"B44\",\n                \"B46\",\n                \"B67\",\n                \"B68\",\n                \"B69\"\n            ],\n            \"Queens\": [\n                \"Q58\",\n                \"Q59\",\n                \"Q60\",\n                \"Q65\",\n                \"Q66\",\n                \"Q44\",\n                \"Q46\"\n            ],\n            \"Bronx\": [\n                \"BX1\",\n                \"BX2\",\n                \"BX9\",\n                \"BX10\",\n                \"BX12\",\n                \"BX22\"\n            ],\n            \"Staten Island\": [\n                \"S40\",\n                \"S44\",\n                \"S46\",\n                \"S48\",\n                \"S51\",\n                \"S53\"\n            ],\n            \"Flushing\": [\n                \"Q65\",\n                \"Q66\",\n                \"Q17\",\n                \"Q27\",\n                \"Q44\"\n            ],\n            \"Bayside\": [\n                \"Q27\",\n                \"Q31\",\n                \"Q76\",\n                \"Q13\"\n            ],\n            \"Times Square\": [\n                \"M42\",\n                \"M104\",\n                \"Q104\"\n            ],\n            \"JFK Airport\": [\n                \"Q3\",\n                \"Q10\",\n                \"B15\"\n            ],\n            \"LaGuardia Airport\": [\n                \"Q70\",\n                \"M60\"\n            ]\n        };\n        // Get specific bus routes for origin and destination\n        const specificFromBuses = busRoutesByArea[fromArea] || [];\n        const specificToBuses = busRoutesByArea[toArea] || [];\n        // Find bus routes that might connect the two areas\n        let connectingBuses = specificFromBuses.filter((bus)=>specificToBuses.includes(bus));\n        // Check if origin and destination are in different boroughs\n        const originBorough = fromArea === \"Manhattan\" || fromArea === \"Times Square\" || fromArea === \"Central Park\" ? \"Manhattan\" : fromArea === \"Brooklyn\" || fromArea === \"Prospect Park\" ? \"Brooklyn\" : fromArea === \"Queens\" || fromArea === \"Flushing\" || fromArea === \"Bayside\" || fromArea === \"JFK Airport\" ? \"Queens\" : fromArea === \"Bronx\" || fromArea === \"Yankee Stadium\" ? \"Bronx\" : fromArea === \"Staten Island\" ? \"Staten Island\" : \"Manhattan\";\n        const destinationBorough = toArea === \"Manhattan\" || toArea === \"Times Square\" || toArea === \"Central Park\" ? \"Manhattan\" : toArea === \"Brooklyn\" || toArea === \"Prospect Park\" ? \"Brooklyn\" : toArea === \"Queens\" || toArea === \"Flushing\" || toArea === \"Bayside\" || toArea === \"JFK Airport\" ? \"Queens\" : toArea === \"Bronx\" || toArea === \"Yankee Stadium\" ? \"Bronx\" : toArea === \"Staten Island\" ? \"Staten Island\" : \"Manhattan\";\n        // Check if this is a cross-borough trip requiring transfers\n        const isCrossBoroughTrip = originBorough !== destinationBorough;\n        // Express Bus routes for cross-borough travel\n        const expressBusRoutes = {\n            \"Queens-Manhattan\": [\n                \"QM1\",\n                \"QM5\",\n                \"QM7\",\n                \"QM8\"\n            ],\n            \"Brooklyn-Manhattan\": [\n                \"BM1\",\n                \"BM2\",\n                \"BM3\",\n                \"BM4\"\n            ],\n            \"Bronx-Manhattan\": [\n                \"BxM1\",\n                \"BxM2\",\n                \"BxM3\",\n                \"BxM4\"\n            ],\n            \"Staten Island-Manhattan\": [\n                \"SIM1\",\n                \"SIM3\",\n                \"SIM4\",\n                \"SIM5\"\n            ]\n        };\n        // Get appropriate express bus if this is cross-borough\n        let expressBusRoute = \"\";\n        if (isCrossBoroughTrip) {\n            const routeKey = `${originBorough}-${destinationBorough}`;\n            const reverseRouteKey = `${destinationBorough}-${originBorough}`;\n            if (expressBusRoutes[routeKey]) {\n                expressBusRoute = expressBusRoutes[routeKey][0];\n            } else if (expressBusRoutes[reverseRouteKey]) {\n                expressBusRoute = expressBusRoutes[reverseRouteKey][0];\n            }\n        }\n        // If no direct connection, pick a bus from origin for local trips only\n        // For cross-borough trips without express buses, we'll rely on subway instead\n        if (connectingBuses.length === 0 && specificFromBuses.length > 0 && !isCrossBoroughTrip) {\n            connectingBuses = [\n                specificFromBuses[0]\n            ];\n        }\n        // Default to a borough-specific bus if nothing else is available\n        const busRoute = connectingBuses.length > 0 ? connectingBuses[0] : expressBusRoute || `${fromBoroughPrefix}${Math.floor(Math.random() * 50) + 1}`;\n        // Get traffic conditions for origin and destination areas\n        const originTraffic = trafficConditions[originBorough] || {\n            level: \"medium\",\n            factor: 1.25\n        };\n        const destinationTraffic = trafficConditions[destinationBorough] || {\n            level: \"medium\",\n            factor: 1.25\n        };\n        // Get topology difficulty for each area\n        const originTopology = topologyDifficulty[originBorough] || 0.2;\n        const destinationTopology = topologyDifficulty[destinationBorough] || 0.2;\n        // Calculate average traffic and topology difficulty\n        const avgTrafficFactor = (originTraffic.factor + destinationTraffic.factor) / 2;\n        const avgTopologyDifficulty = (originTopology + destinationTopology) / 2;\n        // Routes generation logic\n        const generateRoutes = ()=>{\n            const routes = [];\n            // Calculate a balanced score to determine which route should be \"Best Overall\"\n            const calculateBalancedScore = (duration, cost, comfort, numTransfers, hasBags, isHilly, trafficImpact, isWheelchairAccessible)=>{\n                // Base comfort score from comfort level\n                let comfortScore = comfort === \"high\" ? 0.9 : comfort === \"medium\" ? 0.6 : 0.3;\n                // Adjust comfort for number of bags\n                if (userBags > 0) {\n                    // Each bag reduces comfort, especially for walking/biking\n                    comfortScore = Math.max(0.1, comfortScore - userBags * 0.1);\n                }\n                // Adjust comfort for topology if route involves walking or biking\n                if (isHilly) {\n                    comfortScore = Math.max(0.1, comfortScore - avgTopologyDifficulty);\n                }\n                // Normalize time and cost on a scale where lower is better\n                // Traffic factor increases duration for road-based transport\n                const adjustedDuration = duration * trafficImpact;\n                const timeScore = Math.max(0, 1 - adjustedDuration / 120); // Assume 120 mins is worst case\n                const costScore = Math.max(0, 1 - cost / 30); // Assume $30 is worst case\n                // Transfer penalty\n                const transferScore = Math.max(0, 1 - numTransfers * 0.15);\n                // Adjust weights based on user priority\n                let timeWeight = 0.40;\n                let costWeight = 0.35;\n                let comfortWeight = 0.15;\n                let transferWeight = 0.10;\n                switch(userPriority){\n                    case \"speed\":\n                        timeWeight = 0.60;\n                        costWeight = 0.20;\n                        comfortWeight = 0.10;\n                        transferWeight = 0.10;\n                        break;\n                    case \"cost\":\n                        timeWeight = 0.20;\n                        costWeight = 0.60;\n                        comfortWeight = 0.10;\n                        transferWeight = 0.10;\n                        break;\n                    case \"comfort\":\n                        timeWeight = 0.20;\n                        costWeight = 0.20;\n                        comfortWeight = 0.45;\n                        transferWeight = 0.15;\n                        break;\n                    default:\n                        break;\n                }\n                // Further adjust comfort weight based on noise sensitivity\n                if (userNoise === \"high\") {\n                    // If user is highly sensitive to noise, increase comfort weight slightly\n                    comfortWeight += 0.1;\n                    // And reduce other weights proportionally\n                    timeWeight -= 0.04;\n                    costWeight -= 0.03;\n                    transferWeight -= 0.03;\n                }\n                // Adjust for safety preference\n                if (userSafety === \"high\") {\n                    // For high safety preference, fewer transfers and higher comfort are preferred\n                    transferWeight += 0.05;\n                    comfortWeight += 0.05;\n                    timeWeight -= 0.05;\n                    costWeight -= 0.05;\n                }\n                // Add wheelchair accessibility factor if needed\n                let accessibilityPenalty = 0;\n                if (requireWheelchair && !isWheelchairAccessible) {\n                    // Significantly penalize non-accessible routes when wheelchair is required\n                    accessibilityPenalty = 0.5;\n                }\n                const rawScore = (timeScore * timeWeight + costScore * costWeight + comfortScore * comfortWeight + transferScore * transferWeight) * (1 - accessibilityPenalty);\n                // Convert to 1-10 scale\n                return {\n                    raw: rawScore,\n                    score: Math.round(rawScore * 10),\n                    timeScore: Math.round(timeScore * 10),\n                    costScore: Math.round(costScore * 10),\n                    comfortScore: Math.round(comfortScore * 10),\n                    transferScore: Math.round(transferScore * 10)\n                };\n            };\n            // Function to generate route color based on score\n            const getRouteColorFromScore = (score)=>{\n                // Color gradient from red (1) to yellow (5) to green (10)\n                if (score <= 3) return \"#ef4444\"; // red-500\n                if (score <= 5) return \"#f59e0b\"; // amber-500\n                if (score <= 7) return \"#facc15\"; // yellow-400\n                if (score <= 9) return \"#65a30d\"; // lime-600\n                return \"#16a34a\"; // green-600\n            };\n            // Reference the outer getRouteColor function or redefine it here\n            const getRouteColorForMode = (mode)=>{\n                return getRouteColor(mode);\n            };\n            // 0. Best Overall route\n            const bestOverallRoute = {\n                id: \"0\",\n                name: \"Best Overall Route\",\n                duration: 0,\n                cost: 0,\n                comfort: \"medium\",\n                vectorScore: 0.95,\n                segments: [],\n                // Additional detailed information\n                hasTopologyImpact: false,\n                numTransfers: 0,\n                traffic: {\n                    level: \"medium\",\n                    impact: 1.0\n                },\n                eta: \"\",\n                costBreakdown: {\n                    fare: 0,\n                    additionalFees: 0,\n                    totalCost: 0\n                },\n                scores: {\n                    overall: 0,\n                    time: 0,\n                    cost: 0,\n                    comfort: 0,\n                    transfers: 0\n                },\n                routeColor: \"\",\n                pathData: []\n            };\n            // Helper to calculate ETA\n            const calculateETA = (durationMinutes)=>{\n                const now = new Date();\n                const eta = new Date(now.getTime() + durationMinutes * 60000);\n                return eta.toLocaleTimeString([], {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\"\n                });\n            };\n            // Generate path data for map visualization\n            const generatePathData = (route)=>{\n                const pathData = [];\n                let lastCoords = fromCoords;\n                route.segments.forEach((segment, index)=>{\n                    const isLastSegment = index === route.segments.length - 1;\n                    const endCoords = isLastSegment ? toCoords : getCoordinates(segment.endLocation);\n                    // For different transport modes, generate different path types\n                    switch(segment.mode){\n                        case \"subway\":\n                            // Subway routes should follow mostly straight lines with slight curves\n                            pathData.push({\n                                type: \"subway\",\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    // Add a midpoint with slight offset for a natural curve\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.5 + (Math.random() - 0.5) * 0.01,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.5 + (Math.random() - 0.5) * 0.01\n                                    ],\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        case \"bus\":\n                            // Bus routes should follow a more zigzag street-like pattern\n                            const numPoints = Math.ceil(calculateDistance(lastCoords[0], lastCoords[1], endCoords[0], endCoords[1]) * 2);\n                            const points = [\n                                lastCoords\n                            ];\n                            // Generate points that zigzag like city streets\n                            let currentPoint = [\n                                ...lastCoords\n                            ];\n                            for(let i = 0; i < numPoints; i++){\n                                // Alternate between horizontal and vertical movement\n                                if (i % 2 === 0) {\n                                    currentPoint = [\n                                        currentPoint[0],\n                                        currentPoint[1] + (endCoords[1] - currentPoint[1]) * 0.3\n                                    ];\n                                } else {\n                                    currentPoint = [\n                                        currentPoint[0] + (endCoords[0] - currentPoint[0]) * 0.3,\n                                        currentPoint[1]\n                                    ];\n                                }\n                                points.push(currentPoint);\n                            }\n                            points.push(endCoords);\n                            pathData.push({\n                                type: \"bus\",\n                                color: getRouteColorForMode(segment.mode),\n                                points\n                            });\n                            break;\n                        case \"walk\":\n                            // Walking should be a relatively direct path\n                            pathData.push({\n                                type: \"walk\",\n                                color: getRouteColorForMode(segment.mode),\n                                dashArray: \"4,4\",\n                                points: [\n                                    lastCoords,\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        case \"uber\":\n                        case \"taxi\":\n                            // Car routes follow streets but more direct than buses\n                            pathData.push({\n                                type: segment.mode,\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.33,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.66\n                                    ],\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.66,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.33\n                                    ],\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        case \"ebike\":\n                            // Bike routes should follow streets but might take shortcuts\n                            pathData.push({\n                                type: \"ebike\",\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.5 + (Math.random() - 0.5) * 0.005,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.5 + (Math.random() - 0.5) * 0.005\n                                    ],\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        default:\n                            // Default direct line\n                            pathData.push({\n                                type: segment.mode,\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    endCoords\n                                ]\n                            });\n                    }\n                    lastCoords = endCoords;\n                });\n                return pathData;\n            };\n            // Process a completed route with all detailed information\n            const finalizeRoute = (route)=>{\n                // Count transfers (segments that change mode of transportation)\n                const numTransfers = route.segments.length > 0 ? route.segments.length - 1 : 0;\n                // Check if route has walking/biking components to consider topology\n                const hasTopologyImpact = route.segments.some((segment)=>segment.mode === \"walk\" || segment.mode === \"ebike\");\n                // Calculate traffic impact for road-based segments\n                const roadBasedSegments = route.segments.filter((segment)=>segment.mode === \"bus\" || segment.mode === \"uber\" || segment.mode === \"taxi\");\n                const trafficImpact = roadBasedSegments.length > 0 ? avgTrafficFactor : 1.0;\n                // Determine wheelchair accessibility\n                const isWheelchairAccessible = route.segments.every((segment)=>{\n                    if (segment.mode === \"walk\") return true; // Walking is always accessible\n                    if (segment.mode === \"subway\") {\n                        // Check if the specific station is accessible - in a real app this would check actual station data\n                        // For now we'll estimate that 40% of subway segments are wheelchair accessible\n                        return segment.hasOwnProperty(\"wheelchairAccessible\") ? segment.wheelchairAccessible : Math.random() > 0.6;\n                    }\n                    if (segment.mode === \"bus\") {\n                        // Most buses are accessible\n                        return segment.hasOwnProperty(\"wheelchairAccessible\") ? segment.wheelchairAccessible : Math.random() > 0.2;\n                    }\n                    if (segment.mode === \"uber\" || segment.mode === \"taxi\") {\n                        // Some taxis/ubers are wheelchair accessible\n                        return segment.hasOwnProperty(\"wheelchairAccessible\") ? segment.wheelchairAccessible : Math.random() > 0.7;\n                    }\n                    return false;\n                });\n                // Calculate cost breakdown\n                const costBreakdown = {\n                    fare: route.segments.reduce((total, segment)=>{\n                        // Only count positive costs (e.g., exclude free transfers)\n                        return total + (segment.cost > 0 ? segment.cost : 0);\n                    }, 0),\n                    additionalFees: 0,\n                    totalCost: route.cost\n                };\n                // Add fees for Uber/Taxi during high traffic\n                if (roadBasedSegments.length > 0 && trafficImpact > 1.2) {\n                    costBreakdown.additionalFees = parseFloat((costBreakdown.fare * 0.15).toFixed(2));\n                    costBreakdown.totalCost = parseFloat((costBreakdown.fare + costBreakdown.additionalFees).toFixed(2));\n                }\n                // Calculate route scores\n                const scores = calculateBalancedScore(route.duration, costBreakdown.totalCost, route.comfort, numTransfers, userBags > 0, hasTopologyImpact, trafficImpact, isWheelchairAccessible);\n                // Calculate ETA\n                const eta = calculateETA(Math.round(route.duration * trafficImpact));\n                // Generate route color based on overall score\n                const routeColor = getRouteColorFromScore(scores.score);\n                // Generate path data for map\n                const pathData = generatePathData(route);\n                // Add detailed information to route\n                route.numTransfers = numTransfers;\n                route.hasTopologyImpact = hasTopologyImpact;\n                route.traffic = {\n                    level: trafficImpact > 1.3 ? \"high\" : trafficImpact > 1.1 ? \"medium\" : \"low\",\n                    impact: trafficImpact\n                };\n                route.eta = eta;\n                route.costBreakdown = costBreakdown;\n                route.scores = scores;\n                route.routeColor = routeColor;\n                route.pathData = pathData;\n                route.isWheelchairAccessible = isWheelchairAccessible;\n                // Enhance segments with scores\n                route.segments.forEach((segment)=>{\n                    // Score each segment based on mode and conditions\n                    const segmentScore = segment.mode === \"walk\" && hasTopologyImpact ? Math.max(3, 7 - Math.floor(avgTopologyDifficulty * 10)) : segment.mode === \"ebike\" && hasTopologyImpact ? Math.max(2, 6 - Math.floor(avgTopologyDifficulty * 10)) : segment.mode === \"bus\" || segment.mode === \"uber\" || segment.mode === \"taxi\" ? Math.max(2, 9 - Math.floor((trafficImpact - 1) * 10)) : 7; // Default reasonable score\n                    segment.score = segmentScore;\n                    segment.adjustedDuration = segment.mode === \"walk\" && hasTopologyImpact ? Math.round(segment.duration * (1 + avgTopologyDifficulty)) : segment.mode === \"bus\" || segment.mode === \"uber\" || segment.mode === \"taxi\" ? Math.round(segment.duration * trafficImpact) : segment.duration; // No adjustment for subway\n                });\n                return route;\n            };\n            // Decide on the best overall route based on distance\n            if (distance < 1) {\n                // Very short distance - walking might be best\n                bestOverallRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: from,\n                    endLocation: to,\n                    duration: Math.round(distance * 20),\n                    cost: 0,\n                    lineInfo: \"Walk to destination\"\n                });\n                bestOverallRoute.duration = Math.round(distance * 20);\n                bestOverallRoute.comfort = \"high\";\n            } else if (distance < 5 && (bestSubwayLine || connectingBuses.length > 0)) {\n                // Medium distance with transit options\n                // First segment - walk to station\n                bestOverallRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: from,\n                    endLocation: bestSubwayLine ? `Subway Station near ${from}` : `Bus Stop near ${from}`,\n                    duration: 5,\n                    cost: 0,\n                    lineInfo: `Walk to ${bestSubwayLine ? \"station\" : \"bus stop\"}`\n                });\n                // Second segment - transit\n                if (bestSubwayLine) {\n                    bestOverallRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Subway Station near ${from}`,\n                        endLocation: `Subway Station near ${to}`,\n                        duration: Math.round(distance * 8),\n                        cost: 2.75,\n                        lineInfo: `${bestSubwayLine} Train${bestSubwayLine === \"7\" ? \" (Flushing Line)\" : \"\"}`\n                    });\n                } else {\n                    bestOverallRoute.segments.push({\n                        mode: \"bus\",\n                        startLocation: `Bus Stop near ${from}`,\n                        endLocation: `Bus Stop near ${to}`,\n                        duration: Math.round(distance * 10),\n                        cost: 2.75,\n                        lineInfo: `${busRoute} Bus`\n                    });\n                }\n                // Last segment - walk to destination\n                bestOverallRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: bestSubwayLine ? `Subway Station near ${to}` : `Bus Stop near ${to}`,\n                    endLocation: to,\n                    duration: 5,\n                    cost: 0,\n                    lineInfo: \"Walk to destination\"\n                });\n                bestOverallRoute.duration = bestSubwayLine ? Math.round(distance * 8) + 10 // Subway time + walking\n                 : Math.round(distance * 10) + 10; // Bus time + walking\n                bestOverallRoute.cost = 2.75;\n                bestOverallRoute.comfort = bestSubwayLine ? \"medium\" : \"low\";\n            } else {\n                // Longer distance or no good transit - mixed mode might be best\n                // Start with transit if available for most of the route\n                if (bestSubwayLine || hasTransferOptions) {\n                    bestOverallRoute.segments.push({\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Subway Station near ${from}`,\n                        duration: 5,\n                        cost: 0,\n                        lineInfo: \"Walk to station\"\n                    });\n                    if (bestSubwayLine) {\n                        bestOverallRoute.segments.push({\n                            mode: \"subway\",\n                            startLocation: `Subway Station near ${from}`,\n                            endLocation: `Subway Station near ${to}`,\n                            duration: Math.round(distance * 7),\n                            cost: 2.75,\n                            lineInfo: `${bestSubwayLine} Train${bestSubwayLine === \"7\" ? \" (Flushing Line)\" : \"\"}`\n                        });\n                    } else {\n                        // Use transfer if needed\n                        const fromLine = fromSubwayLines[0];\n                        const toLine = toSubwayLines[0];\n                        bestOverallRoute.segments.push({\n                            mode: \"subway\",\n                            startLocation: `Subway Station near ${from}`,\n                            endLocation: \"Transfer Station\",\n                            duration: Math.round(distance * 4),\n                            cost: 2.75,\n                            lineInfo: `${fromLine} Train`\n                        });\n                        bestOverallRoute.segments.push({\n                            mode: \"subway\",\n                            startLocation: \"Transfer Station\",\n                            endLocation: `Subway Station near ${to}`,\n                            duration: Math.round(distance * 4),\n                            cost: 0,\n                            lineInfo: `${toLine} Train`\n                        });\n                    }\n                    // For longer distances, use Uber for the last mile\n                    if (distance > 8) {\n                        bestOverallRoute.segments.push({\n                            mode: \"uber\",\n                            startLocation: `Subway Station near ${to}`,\n                            endLocation: to,\n                            duration: 8,\n                            cost: 7.50,\n                            lineInfo: \"UberX (last mile)\"\n                        });\n                        bestOverallRoute.duration = Math.round(distance * 6) + 13; // Transit + uber + initial walk\n                        bestOverallRoute.cost = 10.25; // Subway + uber\n                        bestOverallRoute.comfort = \"high\";\n                    } else {\n                        bestOverallRoute.segments.push({\n                            mode: \"walk\",\n                            startLocation: `Subway Station near ${to}`,\n                            endLocation: to,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to destination\"\n                        });\n                        bestOverallRoute.duration = bestSubwayLine ? Math.round(distance * 7) + 10 // Subway time + walking\n                         : Math.round(distance * 8) + 10; // Transfer subway time + walking\n                        bestOverallRoute.cost = 2.75;\n                        bestOverallRoute.comfort = \"medium\";\n                    }\n                } else {\n                    // No good transit option - use Uber for efficiency\n                    bestOverallRoute.segments.push({\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Pickup Point near ${from}`,\n                        duration: 3,\n                        cost: 0,\n                        lineInfo: \"Walk to pickup point\"\n                    });\n                    bestOverallRoute.segments.push({\n                        mode: \"uber\",\n                        startLocation: `Pickup Point near ${from}`,\n                        endLocation: to,\n                        duration: Math.round(distance * 8),\n                        cost: parseFloat((distance * 2.25).toFixed(2)),\n                        lineInfo: \"UberX\"\n                    });\n                    bestOverallRoute.duration = Math.round(distance * 8) + 3;\n                    bestOverallRoute.cost = parseFloat((distance * 2.25).toFixed(2));\n                    bestOverallRoute.comfort = \"high\";\n                }\n            }\n            routes.push(bestOverallRoute);\n            // 1. If subway is available, create a subway route\n            if (bestSubwayLine || hasTransferOptions) {\n                const subwayRoute = {\n                    id: routes.length + \"\",\n                    name: \"Fastest Route\",\n                    duration: Math.round(distance * 10),\n                    cost: parseFloat((2.75 + (distance > 5 ? 3 : 0)).toFixed(2)),\n                    comfort: distance < 8 ? \"medium\" : \"low\",\n                    vectorScore: 0.89,\n                    segments: [\n                        {\n                            mode: \"walk\",\n                            startLocation: from,\n                            endLocation: `Subway Station near ${from}`,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: `Walk to station`\n                        }\n                    ]\n                };\n                // Add the subway segment(s)\n                if (bestSubwayLine) {\n                    // Direct subway line\n                    subwayRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Subway Station near ${from}`,\n                        endLocation: `Subway Station near ${to}`,\n                        duration: Math.round(distance * 8),\n                        cost: 2.75,\n                        lineInfo: `${bestSubwayLine} Train${bestSubwayLine === \"7\" ? \" (Flushing Line)\" : \"\"}`\n                    });\n                } else if (hasTransferOptions) {\n                    // Need a transfer\n                    const fromLine = fromSubwayLines[0];\n                    const toLine = toSubwayLines[0];\n                    subwayRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Subway Station near ${from}`,\n                        endLocation: `Transfer Station`,\n                        duration: Math.round(distance * 4),\n                        cost: 2.75,\n                        lineInfo: `${fromLine} Train`\n                    });\n                    subwayRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Transfer Station`,\n                        endLocation: `Subway Station near ${to}`,\n                        duration: Math.round(distance * 4),\n                        cost: 0,\n                        lineInfo: `${toLine} Train`\n                    });\n                }\n                // Add the final walking segment\n                subwayRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: `Subway Station near ${to}`,\n                    endLocation: to,\n                    duration: 7,\n                    cost: 0,\n                    lineInfo: `Walk to destination`\n                });\n                routes.push(subwayRoute);\n            }\n            // 2. Always create a ride-sharing route as an option\n            const uberRoute = {\n                id: routes.length + \"\",\n                name: \"Most Comfortable Route\",\n                duration: Math.round(distance * 12),\n                cost: parseFloat((distance * 2.5).toFixed(2)),\n                comfort: \"high\",\n                vectorScore: 0.78,\n                segments: [\n                    {\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Pickup Point near ${from}`,\n                        duration: 3,\n                        cost: 0,\n                        lineInfo: \"Walk to pickup point\"\n                    },\n                    {\n                        mode: \"uber\",\n                        startLocation: `Pickup Point near ${from}`,\n                        endLocation: `Drop-off near ${to}`,\n                        duration: Math.round(distance * 10),\n                        cost: parseFloat((distance * 2.5).toFixed(2)),\n                        lineInfo: \"UberX\"\n                    },\n                    {\n                        mode: \"walk\",\n                        startLocation: `Drop-off near ${to}`,\n                        endLocation: to,\n                        duration: 4,\n                        cost: 0,\n                        lineInfo: \"Walk to destination\"\n                    }\n                ]\n            };\n            routes.push(uberRoute);\n            // Add a taxi route option\n            const taxiRoute = {\n                id: routes.length + \"\",\n                name: \"Taxi Route\",\n                duration: Math.round(distance * 11),\n                cost: parseFloat((distance * 2.8).toFixed(2)),\n                comfort: \"high\",\n                vectorScore: 0.77,\n                segments: [\n                    {\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Taxi Stand near ${from}`,\n                        duration: 4,\n                        cost: 0,\n                        lineInfo: \"Walk to taxi stand\"\n                    },\n                    {\n                        mode: \"taxi\",\n                        startLocation: `Taxi Stand near ${from}`,\n                        endLocation: to,\n                        duration: Math.round(distance * 9),\n                        cost: parseFloat((distance * 2.8).toFixed(2)),\n                        lineInfo: \"NYC Taxi\"\n                    }\n                ]\n            };\n            routes.push(taxiRoute);\n            // Add an E-bike route option if the distance is under 10 miles\n            if (distance < 10) {\n                const ebikeRoute = {\n                    id: routes.length + \"\",\n                    name: \"E-Bike Route\",\n                    duration: Math.round(distance * 15),\n                    cost: 5.00,\n                    comfort: \"medium\",\n                    vectorScore: 0.72,\n                    segments: [\n                        {\n                            mode: \"walk\",\n                            startLocation: from,\n                            endLocation: `E-Bike Station near ${from}`,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to e-bike station\"\n                        },\n                        {\n                            mode: \"ebike\",\n                            startLocation: `E-Bike Station near ${from}`,\n                            endLocation: `E-Bike Station near ${to}`,\n                            duration: Math.round(distance * 12),\n                            cost: 5.00,\n                            lineInfo: \"Citi Bike E-Bike\"\n                        },\n                        {\n                            mode: \"walk\",\n                            startLocation: `E-Bike Station near ${to}`,\n                            endLocation: to,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to destination\"\n                        }\n                    ]\n                };\n                routes.push(ebikeRoute);\n            }\n            // 3. Try to create a bus route if available\n            if (busRoutesFrom.length > 0) {\n                // Use the connecting bus or an area-specific bus route\n                const busOption = {\n                    id: routes.length + \"\",\n                    name: \"Cheapest Route\",\n                    duration: Math.round(distance * 15),\n                    cost: 2.75,\n                    comfort: \"low\",\n                    vectorScore: 0.71,\n                    segments: []\n                };\n                // First walk segment\n                busOption.segments.push({\n                    mode: \"walk\",\n                    startLocation: from,\n                    endLocation: `Bus Stop near ${from}`,\n                    duration: 7,\n                    cost: 0,\n                    lineInfo: \"Walk to bus stop\"\n                });\n                // Cross-borough trips generally need subway or express bus\n                if (isCrossBoroughTrip) {\n                    if (expressBusRoute) {\n                        // Express bus option for cross-borough\n                        busOption.segments.push({\n                            mode: \"bus\",\n                            startLocation: `Bus Stop near ${from}`,\n                            endLocation: `Bus Stop near ${to}`,\n                            duration: Math.round(distance * 10),\n                            cost: 6.75,\n                            lineInfo: `${expressBusRoute} Express Bus`\n                        });\n                        busOption.cost = 6.75;\n                        busOption.name = \"Express Bus Route\";\n                        busOption.comfort = \"medium\";\n                    } else if (fromSubwayLines.length > 0 && toSubwayLines.length > 0) {\n                        // Use a combination of local bus and subway for cross-borough\n                        busOption.segments.push({\n                            mode: \"bus\",\n                            startLocation: `Bus Stop near ${from}`,\n                            endLocation: `${originBorough} Subway Station`,\n                            duration: 10,\n                            cost: 2.75,\n                            lineInfo: `${specificFromBuses[0]} Bus to subway`\n                        });\n                        // Add subway transfer\n                        busOption.segments.push({\n                            mode: \"subway\",\n                            startLocation: `${originBorough} Subway Station`,\n                            endLocation: `${destinationBorough} Subway Station`,\n                            duration: Math.round(distance * 7),\n                            cost: 0,\n                            lineInfo: `${fromSubwayLines[0]} Train`\n                        });\n                        busOption.name = \"Bus + Subway Route\";\n                    } else {\n                        // Fallback to just showing subway if it exists\n                        return routes;\n                    }\n                } else {\n                    // Local bus for same-borough trips\n                    busOption.segments.push({\n                        mode: \"bus\",\n                        startLocation: `Bus Stop near ${from}`,\n                        endLocation: `Bus Stop near ${to}`,\n                        duration: Math.round(distance * 12),\n                        cost: 2.75,\n                        lineInfo: `${busRoute} Bus`\n                    });\n                }\n                // Final walk segment\n                busOption.segments.push({\n                    mode: \"walk\",\n                    startLocation: `Bus Stop near ${to}`,\n                    endLocation: to,\n                    duration: 8,\n                    cost: 0,\n                    lineInfo: \"Walk to destination\"\n                });\n                // Update duration based on segments\n                busOption.duration = busOption.segments.reduce((total, segment)=>total + segment.duration, 0);\n                routes.push(busOption);\n            } else if (!bestSubwayLine && !hasTransferOptions) {\n                // 4. If no subway or bus is available, add a bike option\n                const bikeOption = {\n                    id: routes.length + \"\",\n                    name: \"Eco-Friendly Route\",\n                    duration: Math.round(distance * 18),\n                    cost: 3.50,\n                    comfort: \"medium\",\n                    vectorScore: 0.65,\n                    segments: [\n                        {\n                            mode: \"walk\",\n                            startLocation: from,\n                            endLocation: `Citi Bike Station near ${from}`,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to bike station\"\n                        },\n                        {\n                            mode: \"ebike\",\n                            startLocation: `Citi Bike Station near ${from}`,\n                            endLocation: `Citi Bike Station near ${to}`,\n                            duration: Math.round(distance * 15),\n                            cost: 3.50,\n                            lineInfo: \"Citi Bike\"\n                        },\n                        {\n                            mode: \"walk\",\n                            startLocation: `Citi Bike Station near ${to}`,\n                            endLocation: to,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to destination\"\n                        }\n                    ]\n                };\n                routes.push(bikeOption);\n            }\n            // Sort routes by balanced score\n            routes.forEach((route)=>{\n                route.balancedScore = calculateBalancedScore(route.duration, route.cost, route.comfort, 0, false, false, 1, true);\n            });\n            const mockRoutes = routes.map(finalizeRoute);\n            // Always ensure we have at least 3 routes\n            if (mockRoutes.length < 3) {\n                // Generate more diverse route options if needed\n                if (mockRoutes.length === 1) {\n                    // Add a slower but cheaper option\n                    const cheapestRoute = {\n                        id: \"98\",\n                        name: \"Economy Option\",\n                        duration: Math.round(distance * 18),\n                        cost: 2.75,\n                        comfort: \"low\",\n                        vectorScore: 0.65,\n                        segments: [\n                            {\n                                mode: \"walk\",\n                                startLocation: from,\n                                endLocation: `Bus Stop near ${from}`,\n                                duration: 10,\n                                cost: 0,\n                                lineInfo: \"Walk to bus stop\"\n                            },\n                            {\n                                mode: \"bus\",\n                                startLocation: `Bus Stop near ${from}`,\n                                endLocation: `Bus Stop near ${to}`,\n                                duration: Math.round(distance * 14),\n                                cost: 2.75,\n                                lineInfo: `Local Bus Route`\n                            },\n                            {\n                                mode: \"walk\",\n                                startLocation: `Bus Stop near ${to}`,\n                                endLocation: to,\n                                duration: 10,\n                                cost: 0,\n                                lineInfo: \"Walk to destination\"\n                            }\n                        ]\n                    };\n                    mockRoutes.push(finalizeRoute(cheapestRoute));\n                    // Add a faster but expensive option\n                    const fastestRoute = {\n                        id: \"99\",\n                        name: \"Premium Express\",\n                        duration: Math.round(distance * 8),\n                        cost: parseFloat((distance * 2.5).toFixed(2)),\n                        comfort: \"high\",\n                        vectorScore: 0.75,\n                        segments: [\n                            {\n                                mode: \"walk\",\n                                startLocation: from,\n                                endLocation: `Pickup near ${from}`,\n                                duration: 3,\n                                cost: 0,\n                                lineInfo: \"Walk to pickup point\"\n                            },\n                            {\n                                mode: \"uber\",\n                                startLocation: `Pickup near ${from}`,\n                                endLocation: to,\n                                duration: Math.round(distance * 7),\n                                cost: parseFloat((distance * 2.5).toFixed(2)),\n                                lineInfo: \"UberX Direct\"\n                            }\n                        ]\n                    };\n                    mockRoutes.push(finalizeRoute(fastestRoute));\n                }\n            }\n            // Filter routes based on wheelchair accessibility if required\n            let filteredRoutes = mockRoutes;\n            if (requireWheelchair) {\n                filteredRoutes = mockRoutes.filter((route)=>route.isWheelchairAccessible);\n                // If no accessible routes are found, generate at least one\n                if (filteredRoutes.length === 0) {\n                    const accessibleRoute = {\n                        id: \"99\",\n                        name: \"Wheelchair Accessible Route\",\n                        duration: Math.round(distance * 10),\n                        cost: parseFloat((distance * 2.8).toFixed(2)),\n                        comfort: \"high\",\n                        vectorScore: 0.7,\n                        segments: [\n                            {\n                                mode: \"walk\",\n                                startLocation: from,\n                                endLocation: `Accessible Pickup near ${from}`,\n                                duration: 5,\n                                cost: 0,\n                                lineInfo: \"Short accessible walk to pickup\",\n                                wheelchairAccessible: true\n                            },\n                            {\n                                mode: \"taxi\",\n                                startLocation: `Pickup near ${from}`,\n                                endLocation: to,\n                                duration: Math.round(distance * 9),\n                                cost: parseFloat((distance * 2.8).toFixed(2)),\n                                lineInfo: \"Wheelchair accessible taxi\",\n                                wheelchairAccessible: true\n                            }\n                        ],\n                        isWheelchairAccessible: true\n                    };\n                    filteredRoutes.push(finalizeRoute(accessibleRoute));\n                }\n            }\n            return filteredRoutes;\n        };\n        const routes = generateRoutes();\n        return res.status(200).json({\n            routes: routes,\n            distance,\n            fromCoords,\n            toCoords,\n            subwayAvailable: bestSubwayLine !== null || hasTransferOptions,\n            transferRequired: !bestSubwayLine && hasTransferOptions,\n            traffic: {\n                origin: originTraffic,\n                destination: destinationTraffic,\n                average: avgTrafficFactor\n            },\n            topology: {\n                origin: originTopology,\n                destination: destinationTopology,\n                average: avgTopologyDifficulty\n            }\n        });\n    } catch (error) {\n        console.error(\"Error calculating routes:\", error);\n        return res.status(500).json({\n            message: \"Error calculating routes\"\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQzFCbUUsUUFBUUE7WUFDUjNFO1lBQ0FrQjtZQUNBQztZQUNBMkosaUJBQWlCaEksbUJBQW1CLFFBQVFMO1lBQzVDc0ksa0JBQWtCLENBQUNqSSxrQkFBa0JMO1lBQ3JDa0UsU0FBUztnQkFDUHFFLFFBQVE1RztnQkFDUjZHLGFBQWE1RztnQkFDYjZHLFNBQVMxRztZQUNYO1lBQ0EyRyxVQUFVO2dCQUNSSCxRQUFRMUc7Z0JBQ1IyRyxhQUFhMUc7Z0JBQ2IyRyxTQUFTekc7WUFDWDtRQUNGO0lBQ0YsRUFBRSxPQUFPMkcsT0FBTztRQUNkaEssUUFBUWdLLEtBQUssQ0FBQyw2QkFBNkJBO1FBQzNDLE9BQU8vSyxJQUFJRSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQUVDLFNBQVM7UUFBMkI7SUFDcEU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1iZWVsaW5lLy4vc3JjL3BhZ2VzL2FwaS9yb3V0ZXMudHM/ZjE0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5leHRBcGlSZXF1ZXN0LCBOZXh0QXBpUmVzcG9uc2UgfSBmcm9tICduZXh0JztcclxuaW1wb3J0IHsgdHJhbnNpdEFQSSB9IGZyb20gJ0AvbGliL2FwaSc7XHJcbmltcG9ydCB7IHRyYW5zcG9ydE1vZGVzLCBmaW5kT3B0aW1hbFJvdXRlcyB9IGZyb20gJ0AvdXRpbHMvdmVjdG9yQ2FsY3VsYXRpb24nO1xyXG5cclxuLy8gTW9jayBjb29yZGluYXRlcyBmb3Igc29tZSBOWUMgbG9jYXRpb25zXHJcbmNvbnN0IGxvY2F0aW9uQ29vcmRpbmF0ZXM6IFJlY29yZDxzdHJpbmcsIFtudW1iZXIsIG51bWJlcl0+ID0ge1xyXG4gICdNYW5oYXR0YW4nOiBbNDAuNzgzMSwgLTczLjk3MTJdLFxyXG4gICdCcm9va2x5bic6IFs0MC42NzgyLCAtNzMuOTQ0Ml0sXHJcbiAgJ1F1ZWVucyc6IFs0MC43MjgyLCAtNzMuNzk0OV0sXHJcbiAgJ0Jyb254JzogWzQwLjg0NDgsIC03My44NjQ4XSxcclxuICAnU3RhdGVuIElzbGFuZCc6IFs0MC41Nzk1LCAtNzQuMTUwMl0sXHJcbiAgJ1RpbWVzIFNxdWFyZSc6IFs0MC43NTgwLCAtNzMuOTg1NV0sXHJcbiAgJ0NlbnRyYWwgUGFyayc6IFs0MC43ODI5LCAtNzMuOTY1NF0sXHJcbiAgJ1Byb3NwZWN0IFBhcmsnOiBbNDAuNjYwMiwgLTczLjk2OTBdLFxyXG4gICdGbHVzaGluZyBNZWFkb3dzJzogWzQwLjc0NjYsIC03My44NDIyXSxcclxuICAnRmx1c2hpbmcnOiBbNDAuNzY1NCwgLTczLjgzMThdLFxyXG4gICdCYXlzaWRlJzogWzQwLjc2MTIsIC03My43NzE2XSxcclxuICAnTWFpbiBTdCc6IFs0MC43NTkwLCAtNzMuODMwMF0sXHJcbiAgJ1lhbmtlZSBTdGFkaXVtJzogWzQwLjgyOTYsIC03My45MjYyXSxcclxufTtcclxuXHJcbi8vIFRyYWZmaWMgZGF0YSBtb2NrIChpbiBhIHJlYWwgYXBwIHRoaXMgd291bGQgYmUgcmVhbC10aW1lIGRhdGEpXHJcbmNvbnN0IHRyYWZmaWNDb25kaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCB7IGxldmVsOiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnLCBmYWN0b3I6IG51bWJlciB9PiA9IHtcclxuICAnTWFuaGF0dGFuJzogeyBsZXZlbDogJ2hpZ2gnLCBmYWN0b3I6IDEuNSB9LFxyXG4gICdCcm9va2x5bic6IHsgbGV2ZWw6ICdtZWRpdW0nLCBmYWN0b3I6IDEuMyB9LFxyXG4gICdRdWVlbnMnOiB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjIgfSxcclxuICAnQnJvbngnOiB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjI1IH0sXHJcbiAgJ1N0YXRlbiBJc2xhbmQnOiB7IGxldmVsOiAnbG93JywgZmFjdG9yOiAxLjEgfSxcclxuICAnRmx1c2hpbmcnOiB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjIgfSxcclxuICAnQmF5c2lkZSc6IHsgbGV2ZWw6ICdsb3cnLCBmYWN0b3I6IDEuMSB9LFxyXG4gICdUaW1lcyBTcXVhcmUnOiB7IGxldmVsOiAnaGlnaCcsIGZhY3RvcjogMS42IH0sXHJcbiAgJ0NlbnRyYWwgUGFyayc6IHsgbGV2ZWw6ICdtZWRpdW0nLCBmYWN0b3I6IDEuMyB9LFxyXG59O1xyXG5cclxuLy8gVG9wb2xvZ3kgZGF0YSAtIGVsZXZhdGlvbiBjaGFuZ2VzIHRoYXQgYWZmZWN0IHdhbGtpbmcvYmlraW5nIGNvbWZvcnRcclxuY29uc3QgdG9wb2xvZ3lEaWZmaWN1bHR5OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xyXG4gICdNYW5oYXR0YW4nOiAwLjIsIC8vIFNvbWUgaGlsbHNcclxuICAnQnJvb2tseW4nOiAwLjEsIC8vIE1vc3RseSBmbGF0XHJcbiAgJ1F1ZWVucyc6IDAuMSwgLy8gTW9zdGx5IGZsYXRcclxuICAnQnJvbngnOiAwLjQsIC8vIEhpbGx5XHJcbiAgJ1N0YXRlbiBJc2xhbmQnOiAwLjUsIC8vIFZlcnkgaGlsbHlcclxuICAnRmx1c2hpbmcnOiAwLjEsIC8vIE1vc3RseSBmbGF0XHJcbiAgJ0JheXNpZGUnOiAwLjIsIC8vIFNvbWUgaGlsbHNcclxuICAnVGltZXMgU3F1YXJlJzogMC4xLCAvLyBGbGF0XHJcbiAgJ0NlbnRyYWwgUGFyayc6IDAuMywgLy8gUm9sbGluZyBoaWxsc1xyXG59O1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBjb29yZGluYXRlcyBmcm9tIGEgbG9jYXRpb24gc3RyaW5nXHJcbmNvbnN0IGdldENvb3JkaW5hdGVzID0gKGxvY2F0aW9uOiBzdHJpbmcpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcclxuICAvLyBOb3JtYWxpemUgdGhlIGxvY2F0aW9uIHN0cmluZyBmb3IgYmV0dGVyIG1hdGNoaW5nXHJcbiAgY29uc3Qgbm9ybWFsaXplZExvY2F0aW9uID0gbG9jYXRpb24udG9Mb3dlckNhc2UoKTtcclxuICBcclxuICAvLyBGaXJzdCB0cnkgZXhhY3QgbWF0Y2hlcyBmb3Igc3BlY2lmaWMgbmVpZ2hib3Job29kcy9sb2NhdGlvbnNcclxuICBmb3IgKGNvbnN0IFtuYW1lLCBjb29yZHNdIG9mIE9iamVjdC5lbnRyaWVzKGxvY2F0aW9uQ29vcmRpbmF0ZXMpKSB7XHJcbiAgICBpZiAobm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKG5hbWUudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgcmV0dXJuIGNvb3JkcztcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gSWYgbm8gc3BlY2lmaWMgbWF0Y2gsIHRyeSB0byBkZXRlcm1pbmUgd2hpY2ggYm9yb3VnaCBpdCdzIGluXHJcbiAgaWYgKG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygncXVlZW5zJykgfHwgXHJcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnZmx1c2hpbmcnKSB8fCBcclxuICAgICAgbm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKCdiYXlzaWRlJykgfHxcclxuICAgICAgbm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKCdqYW1haWNhJykgfHxcclxuICAgICAgbm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKCdhc3RvcmlhJykpIHtcclxuICAgIHJldHVybiBsb2NhdGlvbkNvb3JkaW5hdGVzWydRdWVlbnMnXTtcclxuICB9XHJcbiAgXHJcbiAgaWYgKG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnYnJvb2tseW4nKSB8fFxyXG4gICAgICBub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMoJ3dpbGxpYW1zYnVyZycpIHx8XHJcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygncGFyayBzbG9wZScpKSB7XHJcbiAgICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snQnJvb2tseW4nXTtcclxuICB9XHJcbiAgXHJcbiAgaWYgKG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnYnJvbngnKSkge1xyXG4gICAgcmV0dXJuIGxvY2F0aW9uQ29vcmRpbmF0ZXNbJ0Jyb254J107XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMoJ3N0YXRlbicpKSB7XHJcbiAgICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snU3RhdGVuIElzbGFuZCddO1xyXG4gIH1cclxuICBcclxuICAvLyBEZWZhdWx0IHRvIE1hbmhhdHRhbiBpZiBub3QgZm91bmRcclxuICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snTWFuaGF0dGFuJ107XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXHJcbmNvbnN0IGNhbGN1bGF0ZURpc3RhbmNlID0gKFxyXG4gIGxhdDE6IG51bWJlciwgXHJcbiAgbG5nMTogbnVtYmVyLCBcclxuICBsYXQyOiBudW1iZXIsIFxyXG4gIGxuZzI6IG51bWJlclxyXG4pOiBudW1iZXIgPT4ge1xyXG4gIGNvbnN0IFIgPSAzOTU4Ljg7IC8vIEVhcnRoIHJhZGl1cyBpbiBtaWxlc1xyXG4gIGNvbnN0IGRMYXQgPSAobGF0MiAtIGxhdDEpICogTWF0aC5QSSAvIDE4MDtcclxuICBjb25zdCBkTG5nID0gKGxuZzIgLSBsbmcxKSAqIE1hdGguUEkgLyAxODA7XHJcbiAgY29uc3QgYSA9XHJcbiAgICBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xyXG4gICAgTWF0aC5jb3MobGF0MSAqIE1hdGguUEkgLyAxODApICogTWF0aC5jb3MobGF0MiAqIE1hdGguUEkgLyAxODApICpcclxuICAgIE1hdGguc2luKGRMbmcgLyAyKSAqIE1hdGguc2luKGRMbmcgLyAyKTtcclxuICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcclxuICBjb25zdCBkaXN0YW5jZSA9IFIgKiBjO1xyXG4gIFxyXG4gIHJldHVybiBkaXN0YW5jZTtcclxufTtcclxuXHJcbi8vIERlZmluZSB0aGUgcm91dGUgY29sb3JzIGZvciBkaWZmZXJlbnQgbW9kZXNcclxuY29uc3QgZ2V0Um91dGVDb2xvciA9IChtb2RlOiBzdHJpbmcpID0+IHtcclxuICBzd2l0Y2ggKG1vZGUpIHtcclxuICAgIGNhc2UgJ3N1YndheSc6XHJcbiAgICAgIHJldHVybiAnIzNiODJmNic7ICAvLyBibHVlLTUwMFxyXG4gICAgY2FzZSAnYnVzJzpcclxuICAgICAgcmV0dXJuICcjMjJjNTVlJzsgIC8vIGdyZWVuLTUwMFxyXG4gICAgY2FzZSAnZWJpa2UnOlxyXG4gICAgICByZXR1cm4gJyM4YjVjZjYnOyAgLy8gcHVycGxlLTUwMFxyXG4gICAgY2FzZSAndGF4aSc6XHJcbiAgICBjYXNlICd1YmVyJzpcclxuICAgICAgcmV0dXJuICcjZjU5ZTBiJzsgIC8vIGFtYmVyLTUwMFxyXG4gICAgY2FzZSAnd2Fsayc6XHJcbiAgICAgIHJldHVybiAnIzZiNzI4MCc7ICAvLyBncmF5LTUwMFxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuICcjZWY0NDQ0JzsgIC8vIHJlZC01MDBcclxuICB9XHJcbn07XHJcblxyXG4vLyBEZWZpbmUgdGhlIHJvdXRlIHR5cGVcclxuaW50ZXJmYWNlIFJvdXRlSXRlbSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgZHVyYXRpb246IG51bWJlcjtcclxuICBjb3N0OiBudW1iZXI7XHJcbiAgY29tZm9ydDogc3RyaW5nO1xyXG4gIHZlY3RvclNjb3JlOiBudW1iZXI7XHJcbiAgc2VnbWVudHM6IGFueVtdO1xyXG4gIGJhbGFuY2VkU2NvcmU/OiB7XHJcbiAgICByYXc6IG51bWJlcjtcclxuICAgIHNjb3JlOiBudW1iZXI7XHJcbiAgICB0aW1lU2NvcmU6IG51bWJlcjtcclxuICAgIGNvc3RTY29yZTogbnVtYmVyO1xyXG4gICAgY29tZm9ydFNjb3JlOiBudW1iZXI7XHJcbiAgICB0cmFuc2ZlclNjb3JlOiBudW1iZXI7XHJcbiAgfTtcclxuICAvLyBBZGRpdGlvbmFsIHByb3BlcnRpZXNcclxuICBoYXNUb3BvbG9neUltcGFjdD86IGJvb2xlYW47XHJcbiAgbnVtVHJhbnNmZXJzPzogbnVtYmVyO1xyXG4gIHRyYWZmaWM/OiB7IGxldmVsOiBzdHJpbmc7IGltcGFjdDogbnVtYmVyIH07XHJcbiAgZXRhPzogc3RyaW5nO1xyXG4gIGNvMj86IG51bWJlcjtcclxuICBpc1doZWVsY2hhaXJBY2Nlc3NpYmxlPzogYm9vbGVhbjtcclxuICBzY29yZXM/OiBhbnk7XHJcbiAgcm91dGVDb2xvcj86IHN0cmluZztcclxuICBwYXRoRGF0YT86IGFueVtdO1xyXG4gIGNvc3RCcmVha2Rvd24/OiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIoXHJcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcclxuICByZXM6IE5leHRBcGlSZXNwb25zZVxyXG4pIHtcclxuICBpZiAocmVxLm1ldGhvZCAhPT0gJ0dFVCcpIHtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwNSkuanNvbih7IG1lc3NhZ2U6ICdNZXRob2QgTm90IEFsbG93ZWQnIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBmcm9tLCB0bywgcHJpb3JpdHksIG5vaXNlLCBzYWZldHksIGJhZ3MsIHdoZWVsY2hhaXIgfSA9IHJlcS5xdWVyeTtcclxuXHJcbiAgaWYgKCFmcm9tIHx8ICF0bykge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgbWVzc2FnZTogJ09yaWdpbiBhbmQgZGVzdGluYXRpb24gYXJlIHJlcXVpcmVkJyB9KTtcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB3ZSB3b3VsZCB1c2UgZ2VvY29kaW5nIHRvIGdldCBjb29yZGluYXRlc1xyXG4gICAgY29uc3QgZnJvbUNvb3JkcyA9IGdldENvb3JkaW5hdGVzKGZyb20gYXMgc3RyaW5nKTtcclxuICAgIGNvbnN0IHRvQ29vcmRzID0gZ2V0Q29vcmRpbmF0ZXModG8gYXMgc3RyaW5nKTtcclxuICAgIFxyXG4gICAgLy8gTG9nIHRoZSBjb29yZGluYXRlcyBmb3IgZGVidWdnaW5nXHJcbiAgICBjb25zb2xlLmxvZyhgRnJvbSBsb2NhdGlvbjogXCIke2Zyb219XCIg4oaSIGNvb3JkaW5hdGVzOiBbJHtmcm9tQ29vcmRzWzBdfSwgJHtmcm9tQ29vcmRzWzFdfV1gKTtcclxuICAgIGNvbnNvbGUubG9nKGBUbyBsb2NhdGlvbjogXCIke3RvfVwiIOKGkiBjb29yZGluYXRlczogWyR7dG9Db29yZHNbMF19LCAke3RvQ29vcmRzWzFdfV1gKTtcclxuICAgIFxyXG4gICAgLy8gR2V0IHVzZXIgcHJlZmVyZW5jZXNcclxuICAgIGNvbnN0IHVzZXJQcmlvcml0eSA9IHByaW9yaXR5IGFzIHN0cmluZyB8fCAnYmFsYW5jZWQnO1xyXG4gICAgY29uc3QgdXNlck5vaXNlID0gbm9pc2UgYXMgc3RyaW5nIHx8ICdtb2RlcmF0ZSc7XHJcbiAgICBjb25zdCB1c2VyU2FmZXR5ID0gc2FmZXR5IGFzIHN0cmluZyB8fCAnbW9kZXJhdGUnO1xyXG4gICAgY29uc3QgdXNlckJhZ3MgPSBwYXJzZUludChiYWdzIGFzIHN0cmluZyB8fCAnMCcsIDEwKTtcclxuICAgIGNvbnN0IHJlcXVpcmVXaGVlbGNoYWlyID0gd2hlZWxjaGFpciA9PT0gJ3RydWUnO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2VcclxuICAgIGNvbnN0IGRpc3RhbmNlID0gY2FsY3VsYXRlRGlzdGFuY2UoXHJcbiAgICAgIGZyb21Db29yZHNbMF0sIGZyb21Db29yZHNbMV0sIFxyXG4gICAgICB0b0Nvb3Jkc1swXSwgdG9Db29yZHNbMV1cclxuICAgICk7XHJcblxyXG4gICAgLy8gR2V0IHJlYWwtdGltZSB0cmFuc2l0IGRhdGFcclxuICAgIGNvbnN0IHN1YndheVN0YXR1cyA9IGF3YWl0IHRyYW5zaXRBUEkuZ2V0U3Vid2F5U3RhdHVzKCk7XHJcbiAgICBcclxuICAgIC8vIERldGVybWluZSBhdmFpbGFibGUgc3Vid2F5IGxpbmVzIGJhc2VkIG9uIGxvY2F0aW9uXHJcbiAgICBjb25zdCBzdWJ3YXlMaW5lc0J5TG9jYXRpb246IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHtcclxuICAgICAgJ01hbmhhdHRhbic6IFsnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnQScsICdDJywgJ0UnLCAnQicsICdEJywgJ0YnLCAnTScsICdOJywgJ1EnLCAnUicsICdXJywgJ0wnXSxcclxuICAgICAgJ0Jyb29rbHluJzogWydBJywgJ0MnLCAnRycsICdKJywgJ1onLCAnTCcsICdNJywgJ04nLCAnUScsICdSJywgJzInLCAnMycsICc0JywgJzUnXSxcclxuICAgICAgJ1F1ZWVucyc6IFsnRScsICdGJywgJ00nLCAnUicsICdOJywgJ1cnLCAnRycsICc3J10sXHJcbiAgICAgICdCcm9ueCc6IFsnMScsICcyJywgJzQnLCAnNScsICc2JywgJ0InLCAnRCddLFxyXG4gICAgICAnU3RhdGVuIElzbGFuZCc6IFsnU0lSJ10sXHJcbiAgICAgICdGbHVzaGluZyc6IFsnNyddLFxyXG4gICAgICAnTWFpbiBTdCc6IFsnNyddLFxyXG4gICAgICAnVGltZXMgU3F1YXJlJzogWycxJywgJzInLCAnMycsICdOJywgJ1EnLCAnUicsICdXJywgJzcnLCAnUyddLFxyXG4gICAgICAnQ2VudHJhbCBQYXJrJzogWydBJywgJ0InLCAnQycsICdEJywgJzEnXSxcclxuICAgICAgJ1lhbmtlZSBTdGFkaXVtJzogWyc0JywgJ0InLCAnRCddLFxyXG4gICAgICAnSkZLIEFpcnBvcnQnOiBbJ0EnLCAnRSddLFxyXG4gICAgICAnTGFHdWFyZGlhIEFpcnBvcnQnOiBbXSxcclxuICAgICAgJ1Byb3NwZWN0IFBhcmsnOiBbJ0InLCAnUScsICdTJ10sXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBEZXRlcm1pbmUgZnJvbSBhbmQgdG8gYXJlYXMgdG8gY2hlY2sgc3Vid2F5IGF2YWlsYWJpbGl0eVxyXG4gICAgY29uc3QgZnJvbUFyZWEgPSBPYmplY3Qua2V5cyhsb2NhdGlvbkNvb3JkaW5hdGVzKS5maW5kKGFyZWEgPT4gXHJcbiAgICAgIChmcm9tIGFzIHN0cmluZykudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhhcmVhLnRvTG93ZXJDYXNlKCkpXHJcbiAgICApIHx8ICdNYW5oYXR0YW4nO1xyXG4gICAgXHJcbiAgICBjb25zdCB0b0FyZWEgPSBPYmplY3Qua2V5cyhsb2NhdGlvbkNvb3JkaW5hdGVzKS5maW5kKGFyZWEgPT4gXHJcbiAgICAgICh0byBhcyBzdHJpbmcpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoYXJlYS50b0xvd2VyQ2FzZSgpKVxyXG4gICAgKSB8fCAnTWFuaGF0dGFuJztcclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgYXZhaWxhYmxlIHN1YndheSBsaW5lcyBmb3IgdGhlIHJvdXRlXHJcbiAgICBjb25zdCBmcm9tU3Vid2F5TGluZXMgPSBzdWJ3YXlMaW5lc0J5TG9jYXRpb25bZnJvbUFyZWFdIHx8IFtdO1xyXG4gICAgY29uc3QgdG9TdWJ3YXlMaW5lcyA9IHN1YndheUxpbmVzQnlMb2NhdGlvblt0b0FyZWFdIHx8IFtdO1xyXG4gICAgXHJcbiAgICAvLyBGaW5kIGNvbW1vbiBzdWJ3YXkgbGluZXMgb3IgbGluZXMgdGhhdCBjYW4gZ2V0IHlvdSB0aGVyZSB3aXRoIGEgdHJhbnNmZXJcclxuICAgIGxldCBhdmFpbGFibGVTdWJ3YXlMaW5lcyA9IGZyb21TdWJ3YXlMaW5lcy5maWx0ZXIobGluZSA9PiB0b1N1YndheUxpbmVzLmluY2x1ZGVzKGxpbmUpKTtcclxuICAgIFxyXG4gICAgLy8gSWYgbm8gZGlyZWN0IGxpbmVzLCBjb25zaWRlciBvcHRpb25zIHdpdGggdHJhbnNmZXJzXHJcbiAgICBjb25zdCBoYXNUcmFuc2Zlck9wdGlvbnMgPSBmcm9tU3Vid2F5TGluZXMubGVuZ3RoID4gMCAmJiB0b1N1YndheUxpbmVzLmxlbmd0aCA+IDA7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIHN1YndheSBzdGF0dXMgdG8gc2VlIGlmIHRoZSBsaW5lcyBhcmUgb3BlcmF0aW5nIG5vcm1hbGx5XHJcbiAgICBjb25zdCBvcGVyYXRpbmdTdWJ3YXlMaW5lcyA9IGF2YWlsYWJsZVN1YndheUxpbmVzLmZpbHRlcihsaW5lID0+IHtcclxuICAgICAgY29uc3QgbGluZVN0YXR1cyA9IHN1YndheVN0YXR1cy5maW5kKHMgPT4gcy5saW5lID09PSBsaW5lKTtcclxuICAgICAgcmV0dXJuIGxpbmVTdGF0dXMgJiYgbGluZVN0YXR1cy5zdGF0dXMgPT09ICdub3JtYWwnO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIC8vIEZpbHRlciB0byBqdXN0IGdldCBvbmUgb3BlcmF0aW5nIGxpbmUgaWYgYXZhaWxhYmxlXHJcbiAgICBjb25zdCBiZXN0U3Vid2F5TGluZSA9IG9wZXJhdGluZ1N1YndheUxpbmVzLmxlbmd0aCA+IDAgPyBvcGVyYXRpbmdTdWJ3YXlMaW5lc1swXSA6IG51bGw7XHJcbiAgICBcclxuICAgIC8vIEdldCBhbGwgdGhlIGJ1cyByb3V0ZXMgZm9yIGJvdGggYXJlYXNcclxuICAgIGNvbnN0IGZyb21Cb3JvdWdoUHJlZml4ID0gZnJvbUFyZWEuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XHJcbiAgICBjb25zdCB0b0Jvcm91Z2hQcmVmaXggPSB0b0FyZWEuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XHJcbiAgICBjb25zdCBidXNSb3V0ZXNGcm9tID0gYXdhaXQgdHJhbnNpdEFQSS5nZXRCdXNSb3V0ZXMoZnJvbUFyZWEpO1xyXG4gICAgXHJcbiAgICAvLyBNYXAgc3BlY2lmaWMgbmVpZ2hib3Job29kcyB0byBhcHByb3ByaWF0ZSBidXMgcm91dGVzXHJcbiAgICBjb25zdCBidXNSb3V0ZXNCeUFyZWE6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHtcclxuICAgICAgJ01hbmhhdHRhbic6IFsnTTEnLCAnTTInLCAnTTMnLCAnTTQnLCAnTTUnLCAnTTE1JywgJ00zMScsICdNNDInLCAnTTYwJ10sXHJcbiAgICAgICdCcm9va2x5bic6IFsnQjQxJywgJ0I0MicsICdCNDQnLCAnQjQ2JywgJ0I2NycsICdCNjgnLCAnQjY5J10sXHJcbiAgICAgICdRdWVlbnMnOiBbJ1E1OCcsICdRNTknLCAnUTYwJywgJ1E2NScsICdRNjYnLCAnUTQ0JywgJ1E0NiddLFxyXG4gICAgICAnQnJvbngnOiBbJ0JYMScsICdCWDInLCAnQlg5JywgJ0JYMTAnLCAnQlgxMicsICdCWDIyJ10sXHJcbiAgICAgICdTdGF0ZW4gSXNsYW5kJzogWydTNDAnLCAnUzQ0JywgJ1M0NicsICdTNDgnLCAnUzUxJywgJ1M1MyddLFxyXG4gICAgICAnRmx1c2hpbmcnOiBbJ1E2NScsICdRNjYnLCAnUTE3JywgJ1EyNycsICdRNDQnXSxcclxuICAgICAgJ0JheXNpZGUnOiBbJ1EyNycsICdRMzEnLCAnUTc2JywgJ1ExMyddLFxyXG4gICAgICAnVGltZXMgU3F1YXJlJzogWydNNDInLCAnTTEwNCcsICdRMTA0J10sXHJcbiAgICAgICdKRksgQWlycG9ydCc6IFsnUTMnLCAnUTEwJywgJ0IxNSddLFxyXG4gICAgICAnTGFHdWFyZGlhIEFpcnBvcnQnOiBbJ1E3MCcsICdNNjAnXSxcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIEdldCBzcGVjaWZpYyBidXMgcm91dGVzIGZvciBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uXHJcbiAgICBjb25zdCBzcGVjaWZpY0Zyb21CdXNlcyA9IGJ1c1JvdXRlc0J5QXJlYVtmcm9tQXJlYV0gfHwgW107XHJcbiAgICBjb25zdCBzcGVjaWZpY1RvQnVzZXMgPSBidXNSb3V0ZXNCeUFyZWFbdG9BcmVhXSB8fCBbXTtcclxuICAgIFxyXG4gICAgLy8gRmluZCBidXMgcm91dGVzIHRoYXQgbWlnaHQgY29ubmVjdCB0aGUgdHdvIGFyZWFzXHJcbiAgICBsZXQgY29ubmVjdGluZ0J1c2VzID0gc3BlY2lmaWNGcm9tQnVzZXMuZmlsdGVyKGJ1cyA9PiBzcGVjaWZpY1RvQnVzZXMuaW5jbHVkZXMoYnVzKSk7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gYXJlIGluIGRpZmZlcmVudCBib3JvdWdoc1xyXG4gICAgY29uc3Qgb3JpZ2luQm9yb3VnaCA9IFxyXG4gICAgICBmcm9tQXJlYSA9PT0gJ01hbmhhdHRhbicgfHwgZnJvbUFyZWEgPT09ICdUaW1lcyBTcXVhcmUnIHx8IGZyb21BcmVhID09PSAnQ2VudHJhbCBQYXJrJyA/ICdNYW5oYXR0YW4nIDpcclxuICAgICAgZnJvbUFyZWEgPT09ICdCcm9va2x5bicgfHwgZnJvbUFyZWEgPT09ICdQcm9zcGVjdCBQYXJrJyA/ICdCcm9va2x5bicgOlxyXG4gICAgICBmcm9tQXJlYSA9PT0gJ1F1ZWVucycgfHwgZnJvbUFyZWEgPT09ICdGbHVzaGluZycgfHwgZnJvbUFyZWEgPT09ICdCYXlzaWRlJyB8fCBmcm9tQXJlYSA9PT0gJ0pGSyBBaXJwb3J0JyA/ICdRdWVlbnMnIDpcclxuICAgICAgZnJvbUFyZWEgPT09ICdCcm9ueCcgfHwgZnJvbUFyZWEgPT09ICdZYW5rZWUgU3RhZGl1bScgPyAnQnJvbngnIDpcclxuICAgICAgZnJvbUFyZWEgPT09ICdTdGF0ZW4gSXNsYW5kJyA/ICdTdGF0ZW4gSXNsYW5kJyA6ICdNYW5oYXR0YW4nO1xyXG4gICAgXHJcbiAgICBjb25zdCBkZXN0aW5hdGlvbkJvcm91Z2ggPSBcclxuICAgICAgdG9BcmVhID09PSAnTWFuaGF0dGFuJyB8fCB0b0FyZWEgPT09ICdUaW1lcyBTcXVhcmUnIHx8IHRvQXJlYSA9PT0gJ0NlbnRyYWwgUGFyaycgPyAnTWFuaGF0dGFuJyA6XHJcbiAgICAgIHRvQXJlYSA9PT0gJ0Jyb29rbHluJyB8fCB0b0FyZWEgPT09ICdQcm9zcGVjdCBQYXJrJyA/ICdCcm9va2x5bicgOlxyXG4gICAgICB0b0FyZWEgPT09ICdRdWVlbnMnIHx8IHRvQXJlYSA9PT0gJ0ZsdXNoaW5nJyB8fCB0b0FyZWEgPT09ICdCYXlzaWRlJyB8fCB0b0FyZWEgPT09ICdKRksgQWlycG9ydCcgPyAnUXVlZW5zJyA6XHJcbiAgICAgIHRvQXJlYSA9PT0gJ0Jyb254JyB8fCB0b0FyZWEgPT09ICdZYW5rZWUgU3RhZGl1bScgPyAnQnJvbngnIDpcclxuICAgICAgdG9BcmVhID09PSAnU3RhdGVuIElzbGFuZCcgPyAnU3RhdGVuIElzbGFuZCcgOiAnTWFuaGF0dGFuJztcclxuICAgIFxyXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGNyb3NzLWJvcm91Z2ggdHJpcCByZXF1aXJpbmcgdHJhbnNmZXJzXHJcbiAgICBjb25zdCBpc0Nyb3NzQm9yb3VnaFRyaXAgPSBvcmlnaW5Cb3JvdWdoICE9PSBkZXN0aW5hdGlvbkJvcm91Z2g7XHJcbiAgICBcclxuICAgIC8vIEV4cHJlc3MgQnVzIHJvdXRlcyBmb3IgY3Jvc3MtYm9yb3VnaCB0cmF2ZWxcclxuICAgIGNvbnN0IGV4cHJlc3NCdXNSb3V0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHtcclxuICAgICAgJ1F1ZWVucy1NYW5oYXR0YW4nOiBbJ1FNMScsICdRTTUnLCAnUU03JywgJ1FNOCddLFxyXG4gICAgICAnQnJvb2tseW4tTWFuaGF0dGFuJzogWydCTTEnLCAnQk0yJywgJ0JNMycsICdCTTQnXSxcclxuICAgICAgJ0Jyb254LU1hbmhhdHRhbic6IFsnQnhNMScsICdCeE0yJywgJ0J4TTMnLCAnQnhNNCddLFxyXG4gICAgICAnU3RhdGVuIElzbGFuZC1NYW5oYXR0YW4nOiBbJ1NJTTEnLCAnU0lNMycsICdTSU00JywgJ1NJTTUnXSxcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIEdldCBhcHByb3ByaWF0ZSBleHByZXNzIGJ1cyBpZiB0aGlzIGlzIGNyb3NzLWJvcm91Z2hcclxuICAgIGxldCBleHByZXNzQnVzUm91dGUgPSAnJztcclxuICAgIGlmIChpc0Nyb3NzQm9yb3VnaFRyaXApIHtcclxuICAgICAgY29uc3Qgcm91dGVLZXkgPSBgJHtvcmlnaW5Cb3JvdWdofS0ke2Rlc3RpbmF0aW9uQm9yb3VnaH1gO1xyXG4gICAgICBjb25zdCByZXZlcnNlUm91dGVLZXkgPSBgJHtkZXN0aW5hdGlvbkJvcm91Z2h9LSR7b3JpZ2luQm9yb3VnaH1gO1xyXG4gICAgICBcclxuICAgICAgaWYgKGV4cHJlc3NCdXNSb3V0ZXNbcm91dGVLZXldKSB7XHJcbiAgICAgICAgZXhwcmVzc0J1c1JvdXRlID0gZXhwcmVzc0J1c1JvdXRlc1tyb3V0ZUtleV1bMF07XHJcbiAgICAgIH0gZWxzZSBpZiAoZXhwcmVzc0J1c1JvdXRlc1tyZXZlcnNlUm91dGVLZXldKSB7XHJcbiAgICAgICAgZXhwcmVzc0J1c1JvdXRlID0gZXhwcmVzc0J1c1JvdXRlc1tyZXZlcnNlUm91dGVLZXldWzBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIElmIG5vIGRpcmVjdCBjb25uZWN0aW9uLCBwaWNrIGEgYnVzIGZyb20gb3JpZ2luIGZvciBsb2NhbCB0cmlwcyBvbmx5XHJcbiAgICAvLyBGb3IgY3Jvc3MtYm9yb3VnaCB0cmlwcyB3aXRob3V0IGV4cHJlc3MgYnVzZXMsIHdlJ2xsIHJlbHkgb24gc3Vid2F5IGluc3RlYWRcclxuICAgIGlmIChjb25uZWN0aW5nQnVzZXMubGVuZ3RoID09PSAwICYmIHNwZWNpZmljRnJvbUJ1c2VzLmxlbmd0aCA+IDAgJiYgIWlzQ3Jvc3NCb3JvdWdoVHJpcCkge1xyXG4gICAgICBjb25uZWN0aW5nQnVzZXMgPSBbc3BlY2lmaWNGcm9tQnVzZXNbMF1dO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBEZWZhdWx0IHRvIGEgYm9yb3VnaC1zcGVjaWZpYyBidXMgaWYgbm90aGluZyBlbHNlIGlzIGF2YWlsYWJsZVxyXG4gICAgY29uc3QgYnVzUm91dGUgPSBjb25uZWN0aW5nQnVzZXMubGVuZ3RoID4gMCBcclxuICAgICAgPyBjb25uZWN0aW5nQnVzZXNbMF0gXHJcbiAgICAgIDogKGV4cHJlc3NCdXNSb3V0ZSB8fCBgJHtmcm9tQm9yb3VnaFByZWZpeH0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwKSArIDF9YCk7XHJcbiAgICBcclxuICAgIC8vIEdldCB0cmFmZmljIGNvbmRpdGlvbnMgZm9yIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gYXJlYXNcclxuICAgIGNvbnN0IG9yaWdpblRyYWZmaWMgPSB0cmFmZmljQ29uZGl0aW9uc1tvcmlnaW5Cb3JvdWdoXSB8fCB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjI1IH07XHJcbiAgICBjb25zdCBkZXN0aW5hdGlvblRyYWZmaWMgPSB0cmFmZmljQ29uZGl0aW9uc1tkZXN0aW5hdGlvbkJvcm91Z2hdIHx8IHsgbGV2ZWw6ICdtZWRpdW0nLCBmYWN0b3I6IDEuMjUgfTtcclxuICAgIFxyXG4gICAgLy8gR2V0IHRvcG9sb2d5IGRpZmZpY3VsdHkgZm9yIGVhY2ggYXJlYVxyXG4gICAgY29uc3Qgb3JpZ2luVG9wb2xvZ3kgPSB0b3BvbG9neURpZmZpY3VsdHlbb3JpZ2luQm9yb3VnaF0gfHwgMC4yO1xyXG4gICAgY29uc3QgZGVzdGluYXRpb25Ub3BvbG9neSA9IHRvcG9sb2d5RGlmZmljdWx0eVtkZXN0aW5hdGlvbkJvcm91Z2hdIHx8IDAuMjtcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2UgdHJhZmZpYyBhbmQgdG9wb2xvZ3kgZGlmZmljdWx0eVxyXG4gICAgY29uc3QgYXZnVHJhZmZpY0ZhY3RvciA9IChvcmlnaW5UcmFmZmljLmZhY3RvciArIGRlc3RpbmF0aW9uVHJhZmZpYy5mYWN0b3IpIC8gMjtcclxuICAgIGNvbnN0IGF2Z1RvcG9sb2d5RGlmZmljdWx0eSA9IChvcmlnaW5Ub3BvbG9neSArIGRlc3RpbmF0aW9uVG9wb2xvZ3kpIC8gMjtcclxuICAgIFxyXG4gICAgLy8gUm91dGVzIGdlbmVyYXRpb24gbG9naWNcclxuICAgIGNvbnN0IGdlbmVyYXRlUm91dGVzID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCByb3V0ZXM6IFJvdXRlSXRlbVtdID0gW107XHJcbiAgICAgIFxyXG4gICAgICAvLyBDYWxjdWxhdGUgYSBiYWxhbmNlZCBzY29yZSB0byBkZXRlcm1pbmUgd2hpY2ggcm91dGUgc2hvdWxkIGJlIFwiQmVzdCBPdmVyYWxsXCJcclxuICAgICAgY29uc3QgY2FsY3VsYXRlQmFsYW5jZWRTY29yZSA9IChkdXJhdGlvbjogbnVtYmVyLCBjb3N0OiBudW1iZXIsIGNvbWZvcnQ6IHN0cmluZywgbnVtVHJhbnNmZXJzOiBudW1iZXIsIGhhc0JhZ3M6IGJvb2xlYW4sIGlzSGlsbHk6IGJvb2xlYW4sIHRyYWZmaWNJbXBhY3Q6IG51bWJlciwgaXNXaGVlbGNoYWlyQWNjZXNzaWJsZTogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIC8vIEJhc2UgY29tZm9ydCBzY29yZSBmcm9tIGNvbWZvcnQgbGV2ZWxcclxuICAgICAgICBsZXQgY29tZm9ydFNjb3JlID0gY29tZm9ydCA9PT0gJ2hpZ2gnID8gMC45IDogY29tZm9ydCA9PT0gJ21lZGl1bScgPyAwLjYgOiAwLjM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRqdXN0IGNvbWZvcnQgZm9yIG51bWJlciBvZiBiYWdzXHJcbiAgICAgICAgaWYgKHVzZXJCYWdzID4gMCkge1xyXG4gICAgICAgICAgLy8gRWFjaCBiYWcgcmVkdWNlcyBjb21mb3J0LCBlc3BlY2lhbGx5IGZvciB3YWxraW5nL2Jpa2luZ1xyXG4gICAgICAgICAgY29tZm9ydFNjb3JlID0gTWF0aC5tYXgoMC4xLCBjb21mb3J0U2NvcmUgLSAodXNlckJhZ3MgKiAwLjEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRqdXN0IGNvbWZvcnQgZm9yIHRvcG9sb2d5IGlmIHJvdXRlIGludm9sdmVzIHdhbGtpbmcgb3IgYmlraW5nXHJcbiAgICAgICAgaWYgKGlzSGlsbHkpIHtcclxuICAgICAgICAgIGNvbWZvcnRTY29yZSA9IE1hdGgubWF4KDAuMSwgY29tZm9ydFNjb3JlIC0gYXZnVG9wb2xvZ3lEaWZmaWN1bHR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRpbWUgYW5kIGNvc3Qgb24gYSBzY2FsZSB3aGVyZSBsb3dlciBpcyBiZXR0ZXJcclxuICAgICAgICAvLyBUcmFmZmljIGZhY3RvciBpbmNyZWFzZXMgZHVyYXRpb24gZm9yIHJvYWQtYmFzZWQgdHJhbnNwb3J0XHJcbiAgICAgICAgY29uc3QgYWRqdXN0ZWREdXJhdGlvbiA9IGR1cmF0aW9uICogdHJhZmZpY0ltcGFjdDtcclxuICAgICAgICBjb25zdCB0aW1lU2NvcmUgPSBNYXRoLm1heCgwLCAxIC0gKGFkanVzdGVkRHVyYXRpb24gLyAxMjApKTsgLy8gQXNzdW1lIDEyMCBtaW5zIGlzIHdvcnN0IGNhc2VcclxuICAgICAgICBjb25zdCBjb3N0U2NvcmUgPSBNYXRoLm1heCgwLCAxIC0gKGNvc3QgLyAzMCkpOyAgICAgIC8vIEFzc3VtZSAkMzAgaXMgd29yc3QgY2FzZVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRyYW5zZmVyIHBlbmFsdHlcclxuICAgICAgICBjb25zdCB0cmFuc2ZlclNjb3JlID0gTWF0aC5tYXgoMCwgMSAtIChudW1UcmFuc2ZlcnMgKiAwLjE1KSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRqdXN0IHdlaWdodHMgYmFzZWQgb24gdXNlciBwcmlvcml0eVxyXG4gICAgICAgIGxldCB0aW1lV2VpZ2h0ID0gMC40MDtcclxuICAgICAgICBsZXQgY29zdFdlaWdodCA9IDAuMzU7XHJcbiAgICAgICAgbGV0IGNvbWZvcnRXZWlnaHQgPSAwLjE1O1xyXG4gICAgICAgIGxldCB0cmFuc2ZlcldlaWdodCA9IDAuMTA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3dpdGNoICh1c2VyUHJpb3JpdHkpIHtcclxuICAgICAgICAgIGNhc2UgJ3NwZWVkJzpcclxuICAgICAgICAgICAgdGltZVdlaWdodCA9IDAuNjA7XHJcbiAgICAgICAgICAgIGNvc3RXZWlnaHQgPSAwLjIwO1xyXG4gICAgICAgICAgICBjb21mb3J0V2VpZ2h0ID0gMC4xMDtcclxuICAgICAgICAgICAgdHJhbnNmZXJXZWlnaHQgPSAwLjEwO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2Nvc3QnOlxyXG4gICAgICAgICAgICB0aW1lV2VpZ2h0ID0gMC4yMDtcclxuICAgICAgICAgICAgY29zdFdlaWdodCA9IDAuNjA7XHJcbiAgICAgICAgICAgIGNvbWZvcnRXZWlnaHQgPSAwLjEwO1xyXG4gICAgICAgICAgICB0cmFuc2ZlcldlaWdodCA9IDAuMTA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnY29tZm9ydCc6XHJcbiAgICAgICAgICAgIHRpbWVXZWlnaHQgPSAwLjIwO1xyXG4gICAgICAgICAgICBjb3N0V2VpZ2h0ID0gMC4yMDtcclxuICAgICAgICAgICAgY29tZm9ydFdlaWdodCA9IDAuNDU7XHJcbiAgICAgICAgICAgIHRyYW5zZmVyV2VpZ2h0ID0gMC4xNTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OiAvLyAnYmFsYW5jZWQnXHJcbiAgICAgICAgICAgIC8vIEtlZXAgdGhlIGRlZmF1bHQgd2VpZ2h0c1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRnVydGhlciBhZGp1c3QgY29tZm9ydCB3ZWlnaHQgYmFzZWQgb24gbm9pc2Ugc2Vuc2l0aXZpdHlcclxuICAgICAgICBpZiAodXNlck5vaXNlID09PSAnaGlnaCcpIHtcclxuICAgICAgICAgIC8vIElmIHVzZXIgaXMgaGlnaGx5IHNlbnNpdGl2ZSB0byBub2lzZSwgaW5jcmVhc2UgY29tZm9ydCB3ZWlnaHQgc2xpZ2h0bHlcclxuICAgICAgICAgIGNvbWZvcnRXZWlnaHQgKz0gMC4xO1xyXG4gICAgICAgICAgLy8gQW5kIHJlZHVjZSBvdGhlciB3ZWlnaHRzIHByb3BvcnRpb25hbGx5XHJcbiAgICAgICAgICB0aW1lV2VpZ2h0IC09IDAuMDQ7XHJcbiAgICAgICAgICBjb3N0V2VpZ2h0IC09IDAuMDM7XHJcbiAgICAgICAgICB0cmFuc2ZlcldlaWdodCAtPSAwLjAzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBBZGp1c3QgZm9yIHNhZmV0eSBwcmVmZXJlbmNlXHJcbiAgICAgICAgaWYgKHVzZXJTYWZldHkgPT09ICdoaWdoJykge1xyXG4gICAgICAgICAgLy8gRm9yIGhpZ2ggc2FmZXR5IHByZWZlcmVuY2UsIGZld2VyIHRyYW5zZmVycyBhbmQgaGlnaGVyIGNvbWZvcnQgYXJlIHByZWZlcnJlZFxyXG4gICAgICAgICAgdHJhbnNmZXJXZWlnaHQgKz0gMC4wNTtcclxuICAgICAgICAgIGNvbWZvcnRXZWlnaHQgKz0gMC4wNTtcclxuICAgICAgICAgIHRpbWVXZWlnaHQgLT0gMC4wNTtcclxuICAgICAgICAgIGNvc3RXZWlnaHQgLT0gMC4wNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkIHdoZWVsY2hhaXIgYWNjZXNzaWJpbGl0eSBmYWN0b3IgaWYgbmVlZGVkXHJcbiAgICAgICAgbGV0IGFjY2Vzc2liaWxpdHlQZW5hbHR5ID0gMDtcclxuICAgICAgICBpZiAocmVxdWlyZVdoZWVsY2hhaXIgJiYgIWlzV2hlZWxjaGFpckFjY2Vzc2libGUpIHtcclxuICAgICAgICAgIC8vIFNpZ25pZmljYW50bHkgcGVuYWxpemUgbm9uLWFjY2Vzc2libGUgcm91dGVzIHdoZW4gd2hlZWxjaGFpciBpcyByZXF1aXJlZFxyXG4gICAgICAgICAgYWNjZXNzaWJpbGl0eVBlbmFsdHkgPSAwLjU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHJhd1Njb3JlID0gKCh0aW1lU2NvcmUgKiB0aW1lV2VpZ2h0KSArIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChjb3N0U2NvcmUgKiBjb3N0V2VpZ2h0KSArIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChjb21mb3J0U2NvcmUgKiBjb21mb3J0V2VpZ2h0KSArIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICh0cmFuc2ZlclNjb3JlICogdHJhbnNmZXJXZWlnaHQpKSAqIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgxIC0gYWNjZXNzaWJpbGl0eVBlbmFsdHkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENvbnZlcnQgdG8gMS0xMCBzY2FsZVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICByYXc6IHJhd1Njb3JlLFxyXG4gICAgICAgICAgc2NvcmU6IE1hdGgucm91bmQocmF3U2NvcmUgKiAxMCksXHJcbiAgICAgICAgICB0aW1lU2NvcmU6IE1hdGgucm91bmQodGltZVNjb3JlICogMTApLFxyXG4gICAgICAgICAgY29zdFNjb3JlOiBNYXRoLnJvdW5kKGNvc3RTY29yZSAqIDEwKSxcclxuICAgICAgICAgIGNvbWZvcnRTY29yZTogTWF0aC5yb3VuZChjb21mb3J0U2NvcmUgKiAxMCksXHJcbiAgICAgICAgICB0cmFuc2ZlclNjb3JlOiBNYXRoLnJvdW5kKHRyYW5zZmVyU2NvcmUgKiAxMClcclxuICAgICAgICB9O1xyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgLy8gRnVuY3Rpb24gdG8gZ2VuZXJhdGUgcm91dGUgY29sb3IgYmFzZWQgb24gc2NvcmVcclxuICAgICAgY29uc3QgZ2V0Um91dGVDb2xvckZyb21TY29yZSA9IChzY29yZTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgLy8gQ29sb3IgZ3JhZGllbnQgZnJvbSByZWQgKDEpIHRvIHllbGxvdyAoNSkgdG8gZ3JlZW4gKDEwKVxyXG4gICAgICAgIGlmIChzY29yZSA8PSAzKSByZXR1cm4gJyNlZjQ0NDQnOyAvLyByZWQtNTAwXHJcbiAgICAgICAgaWYgKHNjb3JlIDw9IDUpIHJldHVybiAnI2Y1OWUwYic7IC8vIGFtYmVyLTUwMFxyXG4gICAgICAgIGlmIChzY29yZSA8PSA3KSByZXR1cm4gJyNmYWNjMTUnOyAvLyB5ZWxsb3ctNDAwXHJcbiAgICAgICAgaWYgKHNjb3JlIDw9IDkpIHJldHVybiAnIzY1YTMwZCc7IC8vIGxpbWUtNjAwXHJcbiAgICAgICAgcmV0dXJuICcjMTZhMzRhJzsgLy8gZ3JlZW4tNjAwXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZWZlcmVuY2UgdGhlIG91dGVyIGdldFJvdXRlQ29sb3IgZnVuY3Rpb24gb3IgcmVkZWZpbmUgaXQgaGVyZVxyXG4gICAgICBjb25zdCBnZXRSb3V0ZUNvbG9yRm9yTW9kZSA9IChtb2RlOiBzdHJpbmcpID0+IHtcclxuICAgICAgICByZXR1cm4gZ2V0Um91dGVDb2xvcihtb2RlKTtcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIDAuIEJlc3QgT3ZlcmFsbCByb3V0ZVxyXG4gICAgICBjb25zdCBiZXN0T3ZlcmFsbFJvdXRlOiBSb3V0ZUl0ZW0gPSB7XHJcbiAgICAgICAgaWQ6ICcwJyxcclxuICAgICAgICBuYW1lOiAnQmVzdCBPdmVyYWxsIFJvdXRlJyxcclxuICAgICAgICBkdXJhdGlvbjogMCxcclxuICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgIGNvbWZvcnQ6ICdtZWRpdW0nIGFzICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdycsXHJcbiAgICAgICAgdmVjdG9yU2NvcmU6IDAuOTUsXHJcbiAgICAgICAgc2VnbWVudHM6IFtdLFxyXG4gICAgICAgIC8vIEFkZGl0aW9uYWwgZGV0YWlsZWQgaW5mb3JtYXRpb25cclxuICAgICAgICBoYXNUb3BvbG9neUltcGFjdDogZmFsc2UsXHJcbiAgICAgICAgbnVtVHJhbnNmZXJzOiAwLFxyXG4gICAgICAgIHRyYWZmaWM6IHsgbGV2ZWw6ICdtZWRpdW0nLCBpbXBhY3Q6IDEuMCB9LFxyXG4gICAgICAgIGV0YTogJycsXHJcbiAgICAgICAgY29zdEJyZWFrZG93bjogeyBcclxuICAgICAgICAgIGZhcmU6IDAsIFxyXG4gICAgICAgICAgYWRkaXRpb25hbEZlZXM6IDAsXHJcbiAgICAgICAgICB0b3RhbENvc3Q6IDAgXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY29yZXM6IHtcclxuICAgICAgICAgIG92ZXJhbGw6IDAsXHJcbiAgICAgICAgICB0aW1lOiAwLFxyXG4gICAgICAgICAgY29zdDogMCxcclxuICAgICAgICAgIGNvbWZvcnQ6IDAsXHJcbiAgICAgICAgICB0cmFuc2ZlcnM6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvdXRlQ29sb3I6ICcnLFxyXG4gICAgICAgIHBhdGhEYXRhOiBbXVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgLy8gSGVscGVyIHRvIGNhbGN1bGF0ZSBFVEFcclxuICAgICAgY29uc3QgY2FsY3VsYXRlRVRBID0gKGR1cmF0aW9uTWludXRlczogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgICBjb25zdCBldGEgPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpICsgZHVyYXRpb25NaW51dGVzICogNjAwMDApO1xyXG4gICAgICAgIHJldHVybiBldGEudG9Mb2NhbGVUaW1lU3RyaW5nKFtdLCB7IGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZW5lcmF0ZSBwYXRoIGRhdGEgZm9yIG1hcCB2aXN1YWxpemF0aW9uXHJcbiAgICAgIGNvbnN0IGdlbmVyYXRlUGF0aERhdGEgPSAocm91dGU6IGFueSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhdGhEYXRhOiBhbnlbXSA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBsYXN0Q29vcmRzID0gZnJvbUNvb3JkcztcclxuICAgICAgICByb3V0ZS5zZWdtZW50cy5mb3JFYWNoKChzZWdtZW50OiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBpbmRleCA9PT0gcm91dGUuc2VnbWVudHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgIGNvbnN0IGVuZENvb3JkcyA9IGlzTGFzdFNlZ21lbnQgPyB0b0Nvb3JkcyA6IGdldENvb3JkaW5hdGVzKHNlZ21lbnQuZW5kTG9jYXRpb24pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBGb3IgZGlmZmVyZW50IHRyYW5zcG9ydCBtb2RlcywgZ2VuZXJhdGUgZGlmZmVyZW50IHBhdGggdHlwZXNcclxuICAgICAgICAgIHN3aXRjaChzZWdtZW50Lm1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnc3Vid2F5JzpcclxuICAgICAgICAgICAgICAvLyBTdWJ3YXkgcm91dGVzIHNob3VsZCBmb2xsb3cgbW9zdGx5IHN0cmFpZ2h0IGxpbmVzIHdpdGggc2xpZ2h0IGN1cnZlc1xyXG4gICAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N1YndheScsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0Um91dGVDb2xvckZvck1vZGUoc2VnbWVudC5tb2RlKSxcclxuICAgICAgICAgICAgICAgIHBvaW50czogW1xyXG4gICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzLFxyXG4gICAgICAgICAgICAgICAgICAvLyBBZGQgYSBtaWRwb2ludCB3aXRoIHNsaWdodCBvZmZzZXQgZm9yIGEgbmF0dXJhbCBjdXJ2ZVxyXG4gICAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvb3Jkc1swXSArIChlbmRDb29yZHNbMF0gLSBsYXN0Q29vcmRzWzBdKSAqIDAuNSArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMDEsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvb3Jkc1sxXSArIChlbmRDb29yZHNbMV0gLSBsYXN0Q29vcmRzWzFdKSAqIDAuNSArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMDFcclxuICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgZW5kQ29vcmRzXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2J1cyc6XHJcbiAgICAgICAgICAgICAgLy8gQnVzIHJvdXRlcyBzaG91bGQgZm9sbG93IGEgbW9yZSB6aWd6YWcgc3RyZWV0LWxpa2UgcGF0dGVyblxyXG4gICAgICAgICAgICAgIGNvbnN0IG51bVBvaW50cyA9IE1hdGguY2VpbChjYWxjdWxhdGVEaXN0YW5jZShsYXN0Q29vcmRzWzBdLCBsYXN0Q29vcmRzWzFdLCBlbmRDb29yZHNbMF0sIGVuZENvb3Jkc1sxXSkgKiAyKTtcclxuICAgICAgICAgICAgICBjb25zdCBwb2ludHM6IFtudW1iZXIsIG51bWJlcl1bXSA9IFtsYXN0Q29vcmRzXTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBwb2ludHMgdGhhdCB6aWd6YWcgbGlrZSBjaXR5IHN0cmVldHNcclxuICAgICAgICAgICAgICBsZXQgY3VycmVudFBvaW50OiBbbnVtYmVyLCBudW1iZXJdID0gWy4uLmxhc3RDb29yZHNdIGFzIFtudW1iZXIsIG51bWJlcl07XHJcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gQWx0ZXJuYXRlIGJldHdlZW4gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgbW92ZW1lbnRcclxuICAgICAgICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnQgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvaW50WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludFsxXSArIChlbmRDb29yZHNbMV0gLSBjdXJyZW50UG9pbnRbMV0pICogMC4zXHJcbiAgICAgICAgICAgICAgICAgIF0gYXMgW251bWJlciwgbnVtYmVyXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludCA9IFtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRbMF0gKyAoZW5kQ29vcmRzWzBdIC0gY3VycmVudFBvaW50WzBdKSAqIDAuMyxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRbMV1cclxuICAgICAgICAgICAgICAgICAgXSBhcyBbbnVtYmVyLCBudW1iZXJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3VycmVudFBvaW50KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcG9pbnRzLnB1c2goZW5kQ29vcmRzKTtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBwYXRoRGF0YS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdidXMnLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGdldFJvdXRlQ29sb3JGb3JNb2RlKHNlZ21lbnQubW9kZSksXHJcbiAgICAgICAgICAgICAgICBwb2ludHNcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnd2Fsayc6XHJcbiAgICAgICAgICAgICAgLy8gV2Fsa2luZyBzaG91bGQgYmUgYSByZWxhdGl2ZWx5IGRpcmVjdCBwYXRoXHJcbiAgICAgICAgICAgICAgcGF0aERhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnd2FsaycsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0Um91dGVDb2xvckZvck1vZGUoc2VnbWVudC5tb2RlKSxcclxuICAgICAgICAgICAgICAgIGRhc2hBcnJheTogJzQsNCcsXHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IFtcclxuICAgICAgICAgICAgICAgICAgbGFzdENvb3JkcyxcclxuICAgICAgICAgICAgICAgICAgZW5kQ29vcmRzXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3ViZXInOlxyXG4gICAgICAgICAgICBjYXNlICd0YXhpJzpcclxuICAgICAgICAgICAgICAvLyBDYXIgcm91dGVzIGZvbGxvdyBzdHJlZXRzIGJ1dCBtb3JlIGRpcmVjdCB0aGFuIGJ1c2VzXHJcbiAgICAgICAgICAgICAgcGF0aERhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBzZWdtZW50Lm1vZGUsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0Um91dGVDb2xvckZvck1vZGUoc2VnbWVudC5tb2RlKSxcclxuICAgICAgICAgICAgICAgIHBvaW50czogW1xyXG4gICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzLFxyXG4gICAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvb3Jkc1swXSArIChlbmRDb29yZHNbMF0gLSBsYXN0Q29vcmRzWzBdKSAqIDAuMzMsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvb3Jkc1sxXSArIChlbmRDb29yZHNbMV0gLSBsYXN0Q29vcmRzWzFdKSAqIDAuNjZcclxuICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHNbMF0gKyAoZW5kQ29vcmRzWzBdIC0gbGFzdENvb3Jkc1swXSkgKiAwLjY2LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHNbMV0gKyAoZW5kQ29vcmRzWzFdIC0gbGFzdENvb3Jkc1sxXSkgKiAwLjMzXHJcbiAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgIGVuZENvb3Jkc1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdlYmlrZSc6XHJcbiAgICAgICAgICAgICAgLy8gQmlrZSByb3V0ZXMgc2hvdWxkIGZvbGxvdyBzdHJlZXRzIGJ1dCBtaWdodCB0YWtlIHNob3J0Y3V0c1xyXG4gICAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2ViaWtlJyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRSb3V0ZUNvbG9yRm9yTW9kZShzZWdtZW50Lm1vZGUpLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXHJcbiAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHMsXHJcbiAgICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzWzBdICsgKGVuZENvb3Jkc1swXSAtIGxhc3RDb29yZHNbMF0pICogMC41ICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4wMDUsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvb3Jkc1sxXSArIChlbmRDb29yZHNbMV0gLSBsYXN0Q29vcmRzWzFdKSAqIDAuNSArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMDA1XHJcbiAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgIGVuZENvb3Jkc1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIC8vIERlZmF1bHQgZGlyZWN0IGxpbmVcclxuICAgICAgICAgICAgICBwYXRoRGF0YS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHNlZ21lbnQubW9kZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRSb3V0ZUNvbG9yRm9yTW9kZShzZWdtZW50Lm1vZGUpLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbbGFzdENvb3JkcywgZW5kQ29vcmRzXVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBsYXN0Q29vcmRzID0gZW5kQ29vcmRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBwYXRoRGF0YTtcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIFByb2Nlc3MgYSBjb21wbGV0ZWQgcm91dGUgd2l0aCBhbGwgZGV0YWlsZWQgaW5mb3JtYXRpb25cclxuICAgICAgY29uc3QgZmluYWxpemVSb3V0ZSA9IChyb3V0ZTogYW55KSA9PiB7XHJcbiAgICAgICAgLy8gQ291bnQgdHJhbnNmZXJzIChzZWdtZW50cyB0aGF0IGNoYW5nZSBtb2RlIG9mIHRyYW5zcG9ydGF0aW9uKVxyXG4gICAgICAgIGNvbnN0IG51bVRyYW5zZmVycyA9IHJvdXRlLnNlZ21lbnRzLmxlbmd0aCA+IDAgPyByb3V0ZS5zZWdtZW50cy5sZW5ndGggLSAxIDogMDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpZiByb3V0ZSBoYXMgd2Fsa2luZy9iaWtpbmcgY29tcG9uZW50cyB0byBjb25zaWRlciB0b3BvbG9neVxyXG4gICAgICAgIGNvbnN0IGhhc1RvcG9sb2d5SW1wYWN0ID0gcm91dGUuc2VnbWVudHMuc29tZSgoc2VnbWVudDogYW55KSA9PiBcclxuICAgICAgICAgIHNlZ21lbnQubW9kZSA9PT0gJ3dhbGsnIHx8IHNlZ21lbnQubW9kZSA9PT0gJ2ViaWtlJ1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRyYWZmaWMgaW1wYWN0IGZvciByb2FkLWJhc2VkIHNlZ21lbnRzXHJcbiAgICAgICAgY29uc3Qgcm9hZEJhc2VkU2VnbWVudHMgPSByb3V0ZS5zZWdtZW50cy5maWx0ZXIoKHNlZ21lbnQ6IGFueSkgPT4gXHJcbiAgICAgICAgICBzZWdtZW50Lm1vZGUgPT09ICdidXMnIHx8IHNlZ21lbnQubW9kZSA9PT0gJ3ViZXInIHx8IHNlZ21lbnQubW9kZSA9PT0gJ3RheGknXHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCB0cmFmZmljSW1wYWN0ID0gcm9hZEJhc2VkU2VnbWVudHMubGVuZ3RoID4gMCA/IGF2Z1RyYWZmaWNGYWN0b3IgOiAxLjA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZWVsY2hhaXIgYWNjZXNzaWJpbGl0eVxyXG4gICAgICAgIGNvbnN0IGlzV2hlZWxjaGFpckFjY2Vzc2libGUgPSByb3V0ZS5zZWdtZW50cy5ldmVyeSgoc2VnbWVudDogYW55KSA9PiB7XHJcbiAgICAgICAgICBpZiAoc2VnbWVudC5tb2RlID09PSAnd2FsaycpIHJldHVybiB0cnVlOyAvLyBXYWxraW5nIGlzIGFsd2F5cyBhY2Nlc3NpYmxlXHJcbiAgICAgICAgICBpZiAoc2VnbWVudC5tb2RlID09PSAnc3Vid2F5Jykge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3BlY2lmaWMgc3RhdGlvbiBpcyBhY2Nlc3NpYmxlIC0gaW4gYSByZWFsIGFwcCB0aGlzIHdvdWxkIGNoZWNrIGFjdHVhbCBzdGF0aW9uIGRhdGFcclxuICAgICAgICAgICAgLy8gRm9yIG5vdyB3ZSdsbCBlc3RpbWF0ZSB0aGF0IDQwJSBvZiBzdWJ3YXkgc2VnbWVudHMgYXJlIHdoZWVsY2hhaXIgYWNjZXNzaWJsZVxyXG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudC5oYXNPd25Qcm9wZXJ0eSgnd2hlZWxjaGFpckFjY2Vzc2libGUnKSA/IHNlZ21lbnQud2hlZWxjaGFpckFjY2Vzc2libGUgOiBNYXRoLnJhbmRvbSgpID4gMC42O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHNlZ21lbnQubW9kZSA9PT0gJ2J1cycpIHtcclxuICAgICAgICAgICAgLy8gTW9zdCBidXNlcyBhcmUgYWNjZXNzaWJsZVxyXG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudC5oYXNPd25Qcm9wZXJ0eSgnd2hlZWxjaGFpckFjY2Vzc2libGUnKSA/IHNlZ21lbnQud2hlZWxjaGFpckFjY2Vzc2libGUgOiBNYXRoLnJhbmRvbSgpID4gMC4yO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHNlZ21lbnQubW9kZSA9PT0gJ3ViZXInIHx8IHNlZ21lbnQubW9kZSA9PT0gJ3RheGknKSB7XHJcbiAgICAgICAgICAgIC8vIFNvbWUgdGF4aXMvdWJlcnMgYXJlIHdoZWVsY2hhaXIgYWNjZXNzaWJsZVxyXG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudC5oYXNPd25Qcm9wZXJ0eSgnd2hlZWxjaGFpckFjY2Vzc2libGUnKSA/IHNlZ21lbnQud2hlZWxjaGFpckFjY2Vzc2libGUgOiBNYXRoLnJhbmRvbSgpID4gMC43O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBjb3N0IGJyZWFrZG93blxyXG4gICAgICAgIGNvbnN0IGNvc3RCcmVha2Rvd24gPSB7XHJcbiAgICAgICAgICBmYXJlOiByb3V0ZS5zZWdtZW50cy5yZWR1Y2UoKHRvdGFsOiBudW1iZXIsIHNlZ21lbnQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBPbmx5IGNvdW50IHBvc2l0aXZlIGNvc3RzIChlLmcuLCBleGNsdWRlIGZyZWUgdHJhbnNmZXJzKVxyXG4gICAgICAgICAgICByZXR1cm4gdG90YWwgKyAoc2VnbWVudC5jb3N0ID4gMCA/IHNlZ21lbnQuY29zdCA6IDApO1xyXG4gICAgICAgICAgfSwgMCksXHJcbiAgICAgICAgICBhZGRpdGlvbmFsRmVlczogMCxcclxuICAgICAgICAgIHRvdGFsQ29zdDogcm91dGUuY29zdFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkIGZlZXMgZm9yIFViZXIvVGF4aSBkdXJpbmcgaGlnaCB0cmFmZmljXHJcbiAgICAgICAgaWYgKHJvYWRCYXNlZFNlZ21lbnRzLmxlbmd0aCA+IDAgJiYgdHJhZmZpY0ltcGFjdCA+IDEuMikge1xyXG4gICAgICAgICAgY29zdEJyZWFrZG93bi5hZGRpdGlvbmFsRmVlcyA9IHBhcnNlRmxvYXQoKGNvc3RCcmVha2Rvd24uZmFyZSAqIDAuMTUpLnRvRml4ZWQoMikpO1xyXG4gICAgICAgICAgY29zdEJyZWFrZG93bi50b3RhbENvc3QgPSBwYXJzZUZsb2F0KChjb3N0QnJlYWtkb3duLmZhcmUgKyBjb3N0QnJlYWtkb3duLmFkZGl0aW9uYWxGZWVzKS50b0ZpeGVkKDIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHJvdXRlIHNjb3Jlc1xyXG4gICAgICAgIGNvbnN0IHNjb3JlcyA9IGNhbGN1bGF0ZUJhbGFuY2VkU2NvcmUoXHJcbiAgICAgICAgICByb3V0ZS5kdXJhdGlvbiwgXHJcbiAgICAgICAgICBjb3N0QnJlYWtkb3duLnRvdGFsQ29zdCwgXHJcbiAgICAgICAgICByb3V0ZS5jb21mb3J0LCBcclxuICAgICAgICAgIG51bVRyYW5zZmVycyxcclxuICAgICAgICAgIHVzZXJCYWdzID4gMCxcclxuICAgICAgICAgIGhhc1RvcG9sb2d5SW1wYWN0LFxyXG4gICAgICAgICAgdHJhZmZpY0ltcGFjdCxcclxuICAgICAgICAgIGlzV2hlZWxjaGFpckFjY2Vzc2libGVcclxuICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBFVEFcclxuICAgICAgICBjb25zdCBldGEgPSBjYWxjdWxhdGVFVEEoTWF0aC5yb3VuZChyb3V0ZS5kdXJhdGlvbiAqIHRyYWZmaWNJbXBhY3QpKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBHZW5lcmF0ZSByb3V0ZSBjb2xvciBiYXNlZCBvbiBvdmVyYWxsIHNjb3JlXHJcbiAgICAgICAgY29uc3Qgcm91dGVDb2xvciA9IGdldFJvdXRlQ29sb3JGcm9tU2NvcmUoc2NvcmVzLnNjb3JlKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBHZW5lcmF0ZSBwYXRoIGRhdGEgZm9yIG1hcFxyXG4gICAgICAgIGNvbnN0IHBhdGhEYXRhID0gZ2VuZXJhdGVQYXRoRGF0YShyb3V0ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkIGRldGFpbGVkIGluZm9ybWF0aW9uIHRvIHJvdXRlXHJcbiAgICAgICAgcm91dGUubnVtVHJhbnNmZXJzID0gbnVtVHJhbnNmZXJzO1xyXG4gICAgICAgIHJvdXRlLmhhc1RvcG9sb2d5SW1wYWN0ID0gaGFzVG9wb2xvZ3lJbXBhY3Q7XHJcbiAgICAgICAgcm91dGUudHJhZmZpYyA9IHsgXHJcbiAgICAgICAgICBsZXZlbDogdHJhZmZpY0ltcGFjdCA+IDEuMyA/ICdoaWdoJyA6IHRyYWZmaWNJbXBhY3QgPiAxLjEgPyAnbWVkaXVtJyA6ICdsb3cnLFxyXG4gICAgICAgICAgaW1wYWN0OiB0cmFmZmljSW1wYWN0XHJcbiAgICAgICAgfTtcclxuICAgICAgICByb3V0ZS5ldGEgPSBldGE7XHJcbiAgICAgICAgcm91dGUuY29zdEJyZWFrZG93biA9IGNvc3RCcmVha2Rvd247XHJcbiAgICAgICAgcm91dGUuc2NvcmVzID0gc2NvcmVzO1xyXG4gICAgICAgIHJvdXRlLnJvdXRlQ29sb3IgPSByb3V0ZUNvbG9yO1xyXG4gICAgICAgIHJvdXRlLnBhdGhEYXRhID0gcGF0aERhdGE7XHJcbiAgICAgICAgcm91dGUuaXNXaGVlbGNoYWlyQWNjZXNzaWJsZSA9IGlzV2hlZWxjaGFpckFjY2Vzc2libGU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRW5oYW5jZSBzZWdtZW50cyB3aXRoIHNjb3Jlc1xyXG4gICAgICAgIHJvdXRlLnNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgLy8gU2NvcmUgZWFjaCBzZWdtZW50IGJhc2VkIG9uIG1vZGUgYW5kIGNvbmRpdGlvbnNcclxuICAgICAgICAgIGNvbnN0IHNlZ21lbnRTY29yZSA9IHNlZ21lbnQubW9kZSA9PT0gJ3dhbGsnICYmIGhhc1RvcG9sb2d5SW1wYWN0ID8gXHJcbiAgICAgICAgICAgIE1hdGgubWF4KDMsIDcgLSBNYXRoLmZsb29yKGF2Z1RvcG9sb2d5RGlmZmljdWx0eSAqIDEwKSkgOiAvLyBXYWxraW5nIHNjb3JlIGFmZmVjdGVkIGJ5IGhpbGxzXHJcbiAgICAgICAgICAgIHNlZ21lbnQubW9kZSA9PT0gJ2ViaWtlJyAmJiBoYXNUb3BvbG9neUltcGFjdCA/XHJcbiAgICAgICAgICAgIE1hdGgubWF4KDIsIDYgLSBNYXRoLmZsb29yKGF2Z1RvcG9sb2d5RGlmZmljdWx0eSAqIDEwKSkgOiAvLyBFLWJpa2Ugc2NvcmUgYWZmZWN0ZWQgYnkgaGlsbHNcclxuICAgICAgICAgICAgc2VnbWVudC5tb2RlID09PSAnYnVzJyB8fCBzZWdtZW50Lm1vZGUgPT09ICd1YmVyJyB8fCBzZWdtZW50Lm1vZGUgPT09ICd0YXhpJyA/XHJcbiAgICAgICAgICAgIE1hdGgubWF4KDIsIDkgLSBNYXRoLmZsb29yKCh0cmFmZmljSW1wYWN0IC0gMSkgKiAxMCkpIDogLy8gUm9hZCB0cmFuc3BvcnQgYWZmZWN0ZWQgYnkgdHJhZmZpY1xyXG4gICAgICAgICAgICA3OyAvLyBEZWZhdWx0IHJlYXNvbmFibGUgc2NvcmVcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICBzZWdtZW50LnNjb3JlID0gc2VnbWVudFNjb3JlO1xyXG4gICAgICAgICAgc2VnbWVudC5hZGp1c3RlZER1cmF0aW9uID0gc2VnbWVudC5tb2RlID09PSAnd2FsaycgJiYgaGFzVG9wb2xvZ3lJbXBhY3QgPyBcclxuICAgICAgICAgICAgTWF0aC5yb3VuZChzZWdtZW50LmR1cmF0aW9uICogKDEgKyBhdmdUb3BvbG9neURpZmZpY3VsdHkpKSA6IC8vIFdhbGtpbmcgaXMgc2xvd2VyIGluIGhpbGx5IGFyZWFzXHJcbiAgICAgICAgICAgIChzZWdtZW50Lm1vZGUgPT09ICdidXMnIHx8IHNlZ21lbnQubW9kZSA9PT0gJ3ViZXInIHx8IHNlZ21lbnQubW9kZSA9PT0gJ3RheGknKSA/XHJcbiAgICAgICAgICAgIE1hdGgucm91bmQoc2VnbWVudC5kdXJhdGlvbiAqIHRyYWZmaWNJbXBhY3QpIDogLy8gVHJhZmZpYyBhZmZlY3RzIHJvYWQgdHJhbnNwb3J0XHJcbiAgICAgICAgICAgIHNlZ21lbnQuZHVyYXRpb247IC8vIE5vIGFkanVzdG1lbnQgZm9yIHN1YndheVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByb3V0ZTtcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIERlY2lkZSBvbiB0aGUgYmVzdCBvdmVyYWxsIHJvdXRlIGJhc2VkIG9uIGRpc3RhbmNlXHJcbiAgICAgIGlmIChkaXN0YW5jZSA8IDEpIHtcclxuICAgICAgICAvLyBWZXJ5IHNob3J0IGRpc3RhbmNlIC0gd2Fsa2luZyBtaWdodCBiZSBiZXN0XHJcbiAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcclxuICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMjApLCAvLyAyMCBtaW4gcGVyIG1pbGUgd2Fsa2luZ1xyXG4gICAgICAgICAgY29zdDogMCxcclxuICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBkZXN0aW5hdGlvbicsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5kdXJhdGlvbiA9IE1hdGgucm91bmQoZGlzdGFuY2UgKiAyMCk7XHJcbiAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5jb21mb3J0ID0gJ2hpZ2gnO1xyXG4gICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlIDwgNSAmJiAoYmVzdFN1YndheUxpbmUgfHwgY29ubmVjdGluZ0J1c2VzLmxlbmd0aCA+IDApKSB7XHJcbiAgICAgICAgLy8gTWVkaXVtIGRpc3RhbmNlIHdpdGggdHJhbnNpdCBvcHRpb25zXHJcbiAgICAgICAgLy8gRmlyc3Qgc2VnbWVudCAtIHdhbGsgdG8gc3RhdGlvblxyXG4gICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICBtb2RlOiAnd2FsaycsXHJcbiAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcclxuICAgICAgICAgIGVuZExvY2F0aW9uOiBiZXN0U3Vid2F5TGluZSA/IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7ZnJvbX1gIDogYEJ1cyBTdG9wIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICBkdXJhdGlvbjogNSxcclxuICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICBsaW5lSW5mbzogYFdhbGsgdG8gJHtiZXN0U3Vid2F5TGluZSA/ICdzdGF0aW9uJyA6ICdidXMgc3RvcCd9YCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTZWNvbmQgc2VnbWVudCAtIHRyYW5zaXRcclxuICAgICAgICBpZiAoYmVzdFN1YndheUxpbmUpIHtcclxuICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIG1vZGU6ICdzdWJ3YXknLFxyXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgZW5kTG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA4KSxcclxuICAgICAgICAgICAgY29zdDogMi43NSxcclxuICAgICAgICAgICAgbGluZUluZm86IGAke2Jlc3RTdWJ3YXlMaW5lfSBUcmFpbiR7YmVzdFN1YndheUxpbmUgPT09ICc3JyA/ICcgKEZsdXNoaW5nIExpbmUpJyA6ICcnfWAsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgbW9kZTogJ2J1cycsXHJcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEwKSxcclxuICAgICAgICAgICAgY29zdDogMi43NSxcclxuICAgICAgICAgICAgbGluZUluZm86IGAke2J1c1JvdXRlfSBCdXNgLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIExhc3Qgc2VnbWVudCAtIHdhbGsgdG8gZGVzdGluYXRpb25cclxuICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgc3RhcnRMb2NhdGlvbjogYmVzdFN1YndheUxpbmUgPyBgU3Vid2F5IFN0YXRpb24gbmVhciAke3RvfWAgOiBgQnVzIFN0b3AgbmVhciAke3RvfWAsXHJcbiAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgZHVyYXRpb246IDUsXHJcbiAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGRlc3RpbmF0aW9uJyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmR1cmF0aW9uID0gYmVzdFN1YndheUxpbmUgXHJcbiAgICAgICAgICA/IE1hdGgucm91bmQoZGlzdGFuY2UgKiA4KSArIDEwIC8vIFN1YndheSB0aW1lICsgd2Fsa2luZ1xyXG4gICAgICAgICAgOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTApICsgMTA7IC8vIEJ1cyB0aW1lICsgd2Fsa2luZ1xyXG4gICAgICAgIGJlc3RPdmVyYWxsUm91dGUuY29zdCA9IDIuNzU7XHJcbiAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5jb21mb3J0ID0gYmVzdFN1YndheUxpbmUgPyAnbWVkaXVtJyA6ICdsb3cnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIExvbmdlciBkaXN0YW5jZSBvciBubyBnb29kIHRyYW5zaXQgLSBtaXhlZCBtb2RlIG1pZ2h0IGJlIGJlc3RcclxuICAgICAgICAvLyBTdGFydCB3aXRoIHRyYW5zaXQgaWYgYXZhaWxhYmxlIGZvciBtb3N0IG9mIHRoZSByb3V0ZVxyXG4gICAgICAgIGlmIChiZXN0U3Vid2F5TGluZSB8fCBoYXNUcmFuc2Zlck9wdGlvbnMpIHtcclxuICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgZHVyYXRpb246IDUsXHJcbiAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBzdGF0aW9uJyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoYmVzdFN1YndheUxpbmUpIHtcclxuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICBtb2RlOiAnc3Vid2F5JyxcclxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogNyksXHJcbiAgICAgICAgICAgICAgY29zdDogMi43NSxcclxuICAgICAgICAgICAgICBsaW5lSW5mbzogYCR7YmVzdFN1YndheUxpbmV9IFRyYWluJHtiZXN0U3Vid2F5TGluZSA9PT0gJzcnID8gJyAoRmx1c2hpbmcgTGluZSknIDogJyd9YCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBVc2UgdHJhbnNmZXIgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGNvbnN0IGZyb21MaW5lID0gZnJvbVN1YndheUxpbmVzWzBdO1xyXG4gICAgICAgICAgICBjb25zdCB0b0xpbmUgPSB0b1N1YndheUxpbmVzWzBdO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICBtb2RlOiAnc3Vid2F5JyxcclxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogJ1RyYW5zZmVyIFN0YXRpb24nLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogNCksXHJcbiAgICAgICAgICAgICAgY29zdDogMi43NSxcclxuICAgICAgICAgICAgICBsaW5lSW5mbzogYCR7ZnJvbUxpbmV9IFRyYWluYCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgIG1vZGU6ICdzdWJ3YXknLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246ICdUcmFuc2ZlciBTdGF0aW9uJyxcclxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogNCksXHJcbiAgICAgICAgICAgICAgY29zdDogMCxcclxuICAgICAgICAgICAgICBsaW5lSW5mbzogYCR7dG9MaW5lfSBUcmFpbmAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBGb3IgbG9uZ2VyIGRpc3RhbmNlcywgdXNlIFViZXIgZm9yIHRoZSBsYXN0IG1pbGVcclxuICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDgpIHtcclxuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICBtb2RlOiAndWJlcicsXHJcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgZHVyYXRpb246IDgsXHJcbiAgICAgICAgICAgICAgY29zdDogNy41MCxcclxuICAgICAgICAgICAgICBsaW5lSW5mbzogJ1ViZXJYIChsYXN0IG1pbGUpJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmR1cmF0aW9uID0gTWF0aC5yb3VuZChkaXN0YW5jZSAqIDYpICsgMTM7IC8vIFRyYW5zaXQgKyB1YmVyICsgaW5pdGlhbCB3YWxrXHJcbiAgICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuY29zdCA9IDEwLjI1OyAvLyBTdWJ3YXkgKyB1YmVyXHJcbiAgICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuY29tZm9ydCA9ICdoaWdoJztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA1LFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGRlc3RpbmF0aW9uJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmR1cmF0aW9uID0gYmVzdFN1YndheUxpbmUgXHJcbiAgICAgICAgICAgICAgPyBNYXRoLnJvdW5kKGRpc3RhbmNlICogNykgKyAxMCAvLyBTdWJ3YXkgdGltZSArIHdhbGtpbmdcclxuICAgICAgICAgICAgICA6IE1hdGgucm91bmQoZGlzdGFuY2UgKiA4KSArIDEwOyAvLyBUcmFuc2ZlciBzdWJ3YXkgdGltZSArIHdhbGtpbmdcclxuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5jb3N0ID0gMi43NTtcclxuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5jb21mb3J0ID0gJ21lZGl1bSc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIE5vIGdvb2QgdHJhbnNpdCBvcHRpb24gLSB1c2UgVWJlciBmb3IgZWZmaWNpZW5jeVxyXG4gICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgZW5kTG9jYXRpb246IGBQaWNrdXAgUG9pbnQgbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgZHVyYXRpb246IDMsXHJcbiAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBwaWNrdXAgcG9pbnQnLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIG1vZGU6ICd1YmVyJyxcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFBpY2t1cCBQb2ludCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDgpLFxyXG4gICAgICAgICAgICBjb3N0OiBwYXJzZUZsb2F0KChkaXN0YW5jZSAqIDIuMjUpLnRvRml4ZWQoMikpLFxyXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1ViZXJYJyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmR1cmF0aW9uID0gTWF0aC5yb3VuZChkaXN0YW5jZSAqIDgpICsgMztcclxuICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuY29zdCA9IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi4yNSkudG9GaXhlZCgyKSk7XHJcbiAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmNvbWZvcnQgPSAnaGlnaCc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByb3V0ZXMucHVzaChiZXN0T3ZlcmFsbFJvdXRlKTtcclxuICAgICAgXHJcbiAgICAgIC8vIDEuIElmIHN1YndheSBpcyBhdmFpbGFibGUsIGNyZWF0ZSBhIHN1YndheSByb3V0ZVxyXG4gICAgICBpZiAoYmVzdFN1YndheUxpbmUgfHwgaGFzVHJhbnNmZXJPcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qgc3Vid2F5Um91dGU6IFJvdXRlSXRlbSA9IHtcclxuICAgICAgICAgIGlkOiByb3V0ZXMubGVuZ3RoICsgJycsXHJcbiAgICAgICAgICBuYW1lOiAnRmFzdGVzdCBSb3V0ZScsXHJcbiAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEwKSxcclxuICAgICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKDIuNzUgKyAoZGlzdGFuY2UgPiA1ID8gMyA6IDApKS50b0ZpeGVkKDIpKSxcclxuICAgICAgICAgIGNvbWZvcnQ6IGRpc3RhbmNlIDwgOCA/ICdtZWRpdW0nIDogJ2xvdycsXHJcbiAgICAgICAgICB2ZWN0b3JTY29yZTogMC44OSxcclxuICAgICAgICAgIHNlZ21lbnRzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBtb2RlOiAnd2FsaycsXHJcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA1LFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgICAgbGluZUluZm86IGBXYWxrIHRvIHN0YXRpb25gLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkIHRoZSBzdWJ3YXkgc2VnbWVudChzKVxyXG4gICAgICAgIGlmIChiZXN0U3Vid2F5TGluZSkge1xyXG4gICAgICAgICAgLy8gRGlyZWN0IHN1YndheSBsaW5lXHJcbiAgICAgICAgICBzdWJ3YXlSb3V0ZS5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgbW9kZTogJ3N1YndheScsXHJcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDgpLFxyXG4gICAgICAgICAgICBjb3N0OiAyLjc1LFxyXG4gICAgICAgICAgICBsaW5lSW5mbzogYCR7YmVzdFN1YndheUxpbmV9IFRyYWluJHtiZXN0U3Vid2F5TGluZSA9PT0gJzcnID8gJyAoRmx1c2hpbmcgTGluZSknIDogJyd9YCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaGFzVHJhbnNmZXJPcHRpb25zKSB7XHJcbiAgICAgICAgICAvLyBOZWVkIGEgdHJhbnNmZXJcclxuICAgICAgICAgIGNvbnN0IGZyb21MaW5lID0gZnJvbVN1YndheUxpbmVzWzBdO1xyXG4gICAgICAgICAgY29uc3QgdG9MaW5lID0gdG9TdWJ3YXlMaW5lc1swXTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgc3Vid2F5Um91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIG1vZGU6ICdzdWJ3YXknLFxyXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgZW5kTG9jYXRpb246IGBUcmFuc2ZlciBTdGF0aW9uYCxcclxuICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA0KSxcclxuICAgICAgICAgICAgY29zdDogMi43NSxcclxuICAgICAgICAgICAgbGluZUluZm86IGAke2Zyb21MaW5lfSBUcmFpbmAsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgc3Vid2F5Um91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIG1vZGU6ICdzdWJ3YXknLFxyXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgVHJhbnNmZXIgU3RhdGlvbmAsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke3RvfWAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogNCksXHJcbiAgICAgICAgICAgIGNvc3Q6IDAsIC8vIEZyZWUgdHJhbnNmZXJcclxuICAgICAgICAgICAgbGluZUluZm86IGAke3RvTGluZX0gVHJhaW5gLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCB0aGUgZmluYWwgd2Fsa2luZyBzZWdtZW50XHJcbiAgICAgICAgc3Vid2F5Um91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICBtb2RlOiAnd2FsaycsXHJcbiAgICAgICAgICBzdGFydExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke3RvfWAsXHJcbiAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgZHVyYXRpb246IDcsXHJcbiAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgbGluZUluZm86IGBXYWxrIHRvIGRlc3RpbmF0aW9uYCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByb3V0ZXMucHVzaChzdWJ3YXlSb3V0ZSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIDIuIEFsd2F5cyBjcmVhdGUgYSByaWRlLXNoYXJpbmcgcm91dGUgYXMgYW4gb3B0aW9uXHJcbiAgICAgIGNvbnN0IHViZXJSb3V0ZTogUm91dGVJdGVtID0ge1xyXG4gICAgICAgIGlkOiByb3V0ZXMubGVuZ3RoICsgJycsXHJcbiAgICAgICAgbmFtZTogJ01vc3QgQ29tZm9ydGFibGUgUm91dGUnLFxyXG4gICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTIpLFxyXG4gICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi41KS50b0ZpeGVkKDIpKSxcclxuICAgICAgICBjb21mb3J0OiAnaGlnaCcsXHJcbiAgICAgICAgdmVjdG9yU2NvcmU6IDAuNzgsXHJcbiAgICAgICAgc2VnbWVudHM6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgZW5kTG9jYXRpb246IGBQaWNrdXAgUG9pbnQgbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgZHVyYXRpb246IDMsXHJcbiAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBwaWNrdXAgcG9pbnQnLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbW9kZTogJ3ViZXInLFxyXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgUGlja3VwIFBvaW50IG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgRHJvcC1vZmYgbmVhciAke3RvfWAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTApLFxyXG4gICAgICAgICAgICBjb3N0OiBwYXJzZUZsb2F0KChkaXN0YW5jZSAqIDIuNSkudG9GaXhlZCgyKSksXHJcbiAgICAgICAgICAgIGxpbmVJbmZvOiAnVWJlclgnLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgRHJvcC1vZmYgbmVhciAke3RvfWAsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiA0LFxyXG4gICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gZGVzdGluYXRpb24nLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9O1xyXG4gICAgICByb3V0ZXMucHVzaCh1YmVyUm91dGUpO1xyXG5cclxuICAgICAgLy8gQWRkIGEgdGF4aSByb3V0ZSBvcHRpb25cclxuICAgICAgY29uc3QgdGF4aVJvdXRlOiBSb3V0ZUl0ZW0gPSB7XHJcbiAgICAgICAgaWQ6IHJvdXRlcy5sZW5ndGggKyAnJyxcclxuICAgICAgICBuYW1lOiAnVGF4aSBSb3V0ZScsXHJcbiAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxMSksXHJcbiAgICAgICAgY29zdDogcGFyc2VGbG9hdCgoZGlzdGFuY2UgKiAyLjgpLnRvRml4ZWQoMikpLFxyXG4gICAgICAgIGNvbWZvcnQ6ICdoaWdoJyxcclxuICAgICAgICB2ZWN0b3JTY29yZTogMC43NyxcclxuICAgICAgICBzZWdtZW50czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBtb2RlOiAnd2FsaycsXHJcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYFRheGkgU3RhbmQgbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgZHVyYXRpb246IDQsXHJcbiAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byB0YXhpIHN0YW5kJyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG1vZGU6ICd0YXhpJyxcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFRheGkgU3RhbmQgbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA5KSxcclxuICAgICAgICAgICAgY29zdDogcGFyc2VGbG9hdCgoZGlzdGFuY2UgKiAyLjgpLnRvRml4ZWQoMikpLFxyXG4gICAgICAgICAgICBsaW5lSW5mbzogJ05ZQyBUYXhpJyxcclxuICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICB9O1xyXG4gICAgICByb3V0ZXMucHVzaCh0YXhpUm91dGUpO1xyXG5cclxuICAgICAgLy8gQWRkIGFuIEUtYmlrZSByb3V0ZSBvcHRpb24gaWYgdGhlIGRpc3RhbmNlIGlzIHVuZGVyIDEwIG1pbGVzXHJcbiAgICAgIGlmIChkaXN0YW5jZSA8IDEwKSB7XHJcbiAgICAgICAgY29uc3QgZWJpa2VSb3V0ZTogUm91dGVJdGVtID0ge1xyXG4gICAgICAgICAgaWQ6IHJvdXRlcy5sZW5ndGggKyAnJyxcclxuICAgICAgICAgIG5hbWU6ICdFLUJpa2UgUm91dGUnLFxyXG4gICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxNSksXHJcbiAgICAgICAgICBjb3N0OiA1LjAwLFxyXG4gICAgICAgICAgY29tZm9ydDogJ21lZGl1bScsXHJcbiAgICAgICAgICB2ZWN0b3JTY29yZTogMC43MixcclxuICAgICAgICAgIHNlZ21lbnRzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBtb2RlOiAnd2FsaycsXHJcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBFLUJpa2UgU3RhdGlvbiBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA1LFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGUtYmlrZSBzdGF0aW9uJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIG1vZGU6ICdlYmlrZScsXHJcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYEUtQmlrZSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBFLUJpa2UgU3RhdGlvbiBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEyKSxcclxuICAgICAgICAgICAgICBjb3N0OiA1LjAwLFxyXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiAnQ2l0aSBCaWtlIEUtQmlrZScsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBtb2RlOiAnd2FsaycsXHJcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYEUtQmlrZSBTdGF0aW9uIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgZHVyYXRpb246IDUsXHJcbiAgICAgICAgICAgICAgY29zdDogMCxcclxuICAgICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gZGVzdGluYXRpb24nLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJvdXRlcy5wdXNoKGViaWtlUm91dGUpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyAzLiBUcnkgdG8gY3JlYXRlIGEgYnVzIHJvdXRlIGlmIGF2YWlsYWJsZVxyXG4gICAgICBpZiAoYnVzUm91dGVzRnJvbS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gVXNlIHRoZSBjb25uZWN0aW5nIGJ1cyBvciBhbiBhcmVhLXNwZWNpZmljIGJ1cyByb3V0ZVxyXG4gICAgICAgIGNvbnN0IGJ1c09wdGlvbjogUm91dGVJdGVtID0ge1xyXG4gICAgICAgICAgaWQ6IHJvdXRlcy5sZW5ndGggKyAnJyxcclxuICAgICAgICAgIG5hbWU6ICdDaGVhcGVzdCBSb3V0ZScsXHJcbiAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDE1KSxcclxuICAgICAgICAgIGNvc3Q6IDIuNzUsXHJcbiAgICAgICAgICBjb21mb3J0OiAnbG93JyxcclxuICAgICAgICAgIHZlY3RvclNjb3JlOiAwLjcxLFxyXG4gICAgICAgICAgc2VnbWVudHM6IFtdIGFzIGFueVtdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRmlyc3Qgd2FsayBzZWdtZW50XHJcbiAgICAgICAgYnVzT3B0aW9uLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXHJcbiAgICAgICAgICBlbmRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICBkdXJhdGlvbjogNyxcclxuICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gYnVzIHN0b3AnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENyb3NzLWJvcm91Z2ggdHJpcHMgZ2VuZXJhbGx5IG5lZWQgc3Vid2F5IG9yIGV4cHJlc3MgYnVzXHJcbiAgICAgICAgaWYgKGlzQ3Jvc3NCb3JvdWdoVHJpcCkge1xyXG4gICAgICAgICAgaWYgKGV4cHJlc3NCdXNSb3V0ZSkge1xyXG4gICAgICAgICAgICAvLyBFeHByZXNzIGJ1cyBvcHRpb24gZm9yIGNyb3NzLWJvcm91Z2hcclxuICAgICAgICAgICAgYnVzT3B0aW9uLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgIG1vZGU6ICdidXMnLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgQnVzIFN0b3AgbmVhciAke3RvfWAsXHJcbiAgICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxMCksIC8vIEV4cHJlc3MgYnVzZXMgYXJlIGZhc3RlciB0aGFuIGxvY2FsXHJcbiAgICAgICAgICAgICAgY29zdDogNi43NSwgLy8gRXhwcmVzcyBidXNlcyBjb3N0IG1vcmVcclxuICAgICAgICAgICAgICBsaW5lSW5mbzogYCR7ZXhwcmVzc0J1c1JvdXRlfSBFeHByZXNzIEJ1c2AsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYnVzT3B0aW9uLmNvc3QgPSA2Ljc1O1xyXG4gICAgICAgICAgICBidXNPcHRpb24ubmFtZSA9ICdFeHByZXNzIEJ1cyBSb3V0ZSc7XHJcbiAgICAgICAgICAgIGJ1c09wdGlvbi5jb21mb3J0ID0gJ21lZGl1bSc7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyb21TdWJ3YXlMaW5lcy5sZW5ndGggPiAwICYmIHRvU3Vid2F5TGluZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBVc2UgYSBjb21iaW5hdGlvbiBvZiBsb2NhbCBidXMgYW5kIHN1YndheSBmb3IgY3Jvc3MtYm9yb3VnaFxyXG4gICAgICAgICAgICBidXNPcHRpb24uc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgbW9kZTogJ2J1cycsXHJcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGAke29yaWdpbkJvcm91Z2h9IFN1YndheSBTdGF0aW9uYCxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogMTAsXHJcbiAgICAgICAgICAgICAgY29zdDogMi43NSxcclxuICAgICAgICAgICAgICBsaW5lSW5mbzogYCR7c3BlY2lmaWNGcm9tQnVzZXNbMF19IEJ1cyB0byBzdWJ3YXlgLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEFkZCBzdWJ3YXkgdHJhbnNmZXJcclxuICAgICAgICAgICAgYnVzT3B0aW9uLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgIG1vZGU6ICdzdWJ3YXknLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGAke29yaWdpbkJvcm91Z2h9IFN1YndheSBTdGF0aW9uYCxcclxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYCR7ZGVzdGluYXRpb25Cb3JvdWdofSBTdWJ3YXkgU3RhdGlvbmAsXHJcbiAgICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA3KSxcclxuICAgICAgICAgICAgICBjb3N0OiAwLCAvLyBGcmVlIHRyYW5zZmVyXHJcbiAgICAgICAgICAgICAgbGluZUluZm86IGAke2Zyb21TdWJ3YXlMaW5lc1swXX0gVHJhaW5gLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGJ1c09wdGlvbi5uYW1lID0gJ0J1cyArIFN1YndheSBSb3V0ZSc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBqdXN0IHNob3dpbmcgc3Vid2F5IGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICByZXR1cm4gcm91dGVzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBMb2NhbCBidXMgZm9yIHNhbWUtYm9yb3VnaCB0cmlwc1xyXG4gICAgICAgICAgYnVzT3B0aW9uLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICBtb2RlOiAnYnVzJyxcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgQnVzIFN0b3AgbmVhciAke3RvfWAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTIpLFxyXG4gICAgICAgICAgICBjb3N0OiAyLjc1LFxyXG4gICAgICAgICAgICBsaW5lSW5mbzogYCR7YnVzUm91dGV9IEJ1c2AsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRmluYWwgd2FsayBzZWdtZW50XHJcbiAgICAgICAgYnVzT3B0aW9uLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgc3RhcnRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcclxuICAgICAgICAgIGR1cmF0aW9uOiA4LFxyXG4gICAgICAgICAgY29zdDogMCxcclxuICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBkZXN0aW5hdGlvbicsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVXBkYXRlIGR1cmF0aW9uIGJhc2VkIG9uIHNlZ21lbnRzXHJcbiAgICAgICAgYnVzT3B0aW9uLmR1cmF0aW9uID0gYnVzT3B0aW9uLnNlZ21lbnRzLnJlZHVjZSgodG90YWwsIHNlZ21lbnQpID0+IHRvdGFsICsgc2VnbWVudC5kdXJhdGlvbiwgMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcm91dGVzLnB1c2goYnVzT3B0aW9uKTtcclxuICAgICAgfSBlbHNlIGlmICghYmVzdFN1YndheUxpbmUgJiYgIWhhc1RyYW5zZmVyT3B0aW9ucykge1xyXG4gICAgICAgIC8vIDQuIElmIG5vIHN1YndheSBvciBidXMgaXMgYXZhaWxhYmxlLCBhZGQgYSBiaWtlIG9wdGlvblxyXG4gICAgICAgIGNvbnN0IGJpa2VPcHRpb246IFJvdXRlSXRlbSA9IHtcclxuICAgICAgICAgIGlkOiByb3V0ZXMubGVuZ3RoICsgJycsXHJcbiAgICAgICAgICBuYW1lOiAnRWNvLUZyaWVuZGx5IFJvdXRlJyxcclxuICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTgpLFxyXG4gICAgICAgICAgY29zdDogMy41MCxcclxuICAgICAgICAgIGNvbWZvcnQ6ICdtZWRpdW0nLFxyXG4gICAgICAgICAgdmVjdG9yU2NvcmU6IDAuNjUsXHJcbiAgICAgICAgICBzZWdtZW50czogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgQ2l0aSBCaWtlIFN0YXRpb24gbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcclxuICAgICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBiaWtlIHN0YXRpb24nLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbW9kZTogJ2ViaWtlJyxcclxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgQ2l0aSBCaWtlIFN0YXRpb24gbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYENpdGkgQmlrZSBTdGF0aW9uIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTUpLFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDMuNTAsXHJcbiAgICAgICAgICAgICAgbGluZUluZm86ICdDaXRpIEJpa2UnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBDaXRpIEJpa2UgU3RhdGlvbiBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA1LFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGRlc3RpbmF0aW9uJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICByb3V0ZXMucHVzaChiaWtlT3B0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gU29ydCByb3V0ZXMgYnkgYmFsYW5jZWQgc2NvcmVcclxuICAgICAgcm91dGVzLmZvckVhY2gocm91dGUgPT4ge1xyXG4gICAgICAgIHJvdXRlLmJhbGFuY2VkU2NvcmUgPSBjYWxjdWxhdGVCYWxhbmNlZFNjb3JlKHJvdXRlLmR1cmF0aW9uLCByb3V0ZS5jb3N0LCByb3V0ZS5jb21mb3J0LCAwLCBmYWxzZSwgZmFsc2UsIDEsIHRydWUpO1xyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IG1vY2tSb3V0ZXMgPSByb3V0ZXMubWFwKGZpbmFsaXplUm91dGUpO1xyXG4gICAgICBcclxuICAgICAgLy8gQWx3YXlzIGVuc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IDMgcm91dGVzXHJcbiAgICAgIGlmIChtb2NrUm91dGVzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBtb3JlIGRpdmVyc2Ugcm91dGUgb3B0aW9ucyBpZiBuZWVkZWRcclxuICAgICAgICBpZiAobW9ja1JvdXRlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIC8vIEFkZCBhIHNsb3dlciBidXQgY2hlYXBlciBvcHRpb25cclxuICAgICAgICAgIGNvbnN0IGNoZWFwZXN0Um91dGU6IFJvdXRlSXRlbSA9IHtcclxuICAgICAgICAgICAgaWQ6ICc5OCcsXHJcbiAgICAgICAgICAgIG5hbWU6ICdFY29ub215IE9wdGlvbicsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTgpLFxyXG4gICAgICAgICAgICBjb3N0OiAyLjc1LFxyXG4gICAgICAgICAgICBjb21mb3J0OiAnbG93JyxcclxuICAgICAgICAgICAgdmVjdG9yU2NvcmU6IDAuNjUsXHJcbiAgICAgICAgICAgIHNlZ21lbnRzOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAsXHJcbiAgICAgICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGJ1cyBzdG9wJyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1vZGU6ICdidXMnLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxNCksXHJcbiAgICAgICAgICAgICAgICBjb3N0OiAyLjc1LFxyXG4gICAgICAgICAgICAgICAgbGluZUluZm86IGBMb2NhbCBCdXMgUm91dGVgLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxMCxcclxuICAgICAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gZGVzdGluYXRpb24nLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgbW9ja1JvdXRlcy5wdXNoKGZpbmFsaXplUm91dGUoY2hlYXBlc3RSb3V0ZSkpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBBZGQgYSBmYXN0ZXIgYnV0IGV4cGVuc2l2ZSBvcHRpb25cclxuICAgICAgICAgIGNvbnN0IGZhc3Rlc3RSb3V0ZTogUm91dGVJdGVtID0ge1xyXG4gICAgICAgICAgICBpZDogJzk5JyxcclxuICAgICAgICAgICAgbmFtZTogJ1ByZW1pdW0gRXhwcmVzcycsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogOCksXHJcbiAgICAgICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi41KS50b0ZpeGVkKDIpKSxcclxuICAgICAgICAgICAgY29tZm9ydDogJ2hpZ2gnLFxyXG4gICAgICAgICAgICB2ZWN0b3JTY29yZTogMC43NSxcclxuICAgICAgICAgICAgc2VnbWVudHM6IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtb2RlOiAnd2FsaycsXHJcbiAgICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgUGlja3VwIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMyxcclxuICAgICAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gcGlja3VwIHBvaW50JyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1vZGU6ICd1YmVyJyxcclxuICAgICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBQaWNrdXAgbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDcpLFxyXG4gICAgICAgICAgICAgICAgY29zdDogcGFyc2VGbG9hdCgoZGlzdGFuY2UgKiAyLjUpLnRvRml4ZWQoMikpLFxyXG4gICAgICAgICAgICAgICAgbGluZUluZm86ICdVYmVyWCBEaXJlY3QnLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgbW9ja1JvdXRlcy5wdXNoKGZpbmFsaXplUm91dGUoZmFzdGVzdFJvdXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBGaWx0ZXIgcm91dGVzIGJhc2VkIG9uIHdoZWVsY2hhaXIgYWNjZXNzaWJpbGl0eSBpZiByZXF1aXJlZFxyXG4gICAgICBsZXQgZmlsdGVyZWRSb3V0ZXMgPSBtb2NrUm91dGVzO1xyXG4gICAgICBpZiAocmVxdWlyZVdoZWVsY2hhaXIpIHtcclxuICAgICAgICBmaWx0ZXJlZFJvdXRlcyA9IG1vY2tSb3V0ZXMuZmlsdGVyKHJvdXRlID0+IHJvdXRlLmlzV2hlZWxjaGFpckFjY2Vzc2libGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIG5vIGFjY2Vzc2libGUgcm91dGVzIGFyZSBmb3VuZCwgZ2VuZXJhdGUgYXQgbGVhc3Qgb25lXHJcbiAgICAgICAgaWYgKGZpbHRlcmVkUm91dGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgY29uc3QgYWNjZXNzaWJsZVJvdXRlOiBSb3V0ZUl0ZW0gPSB7XHJcbiAgICAgICAgICAgIGlkOiAnOTknLFxyXG4gICAgICAgICAgICBuYW1lOiAnV2hlZWxjaGFpciBBY2Nlc3NpYmxlIFJvdXRlJyxcclxuICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxMCksXHJcbiAgICAgICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi44KS50b0ZpeGVkKDIpKSwgLy8gU2xpZ2h0bHkgbW9yZSBleHBlbnNpdmUgZm9yIGFjY2Vzc2libGUgdmVoaWNsZXNcclxuICAgICAgICAgICAgY29tZm9ydDogJ2hpZ2gnLFxyXG4gICAgICAgICAgICB2ZWN0b3JTY29yZTogMC43LFxyXG4gICAgICAgICAgICBzZWdtZW50czogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBBY2Nlc3NpYmxlIFBpY2t1cCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDUsXHJcbiAgICAgICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICAgICAgbGluZUluZm86ICdTaG9ydCBhY2Nlc3NpYmxlIHdhbGsgdG8gcGlja3VwJyxcclxuICAgICAgICAgICAgICAgIHdoZWVsY2hhaXJBY2Nlc3NpYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtb2RlOiAndGF4aScsXHJcbiAgICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgUGlja3VwIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA5KSxcclxuICAgICAgICAgICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi44KS50b0ZpeGVkKDIpKSxcclxuICAgICAgICAgICAgICAgIGxpbmVJbmZvOiAnV2hlZWxjaGFpciBhY2Nlc3NpYmxlIHRheGknLFxyXG4gICAgICAgICAgICAgICAgd2hlZWxjaGFpckFjY2Vzc2libGU6IHRydWVcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGlzV2hlZWxjaGFpckFjY2Vzc2libGU6IHRydWVcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBmaWx0ZXJlZFJvdXRlcy5wdXNoKGZpbmFsaXplUm91dGUoYWNjZXNzaWJsZVJvdXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gZmlsdGVyZWRSb3V0ZXM7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zdCByb3V0ZXMgPSBnZW5lcmF0ZVJvdXRlcygpO1xyXG5cclxuICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IFxyXG4gICAgICByb3V0ZXM6IHJvdXRlcyxcclxuICAgICAgZGlzdGFuY2UsXHJcbiAgICAgIGZyb21Db29yZHMsXHJcbiAgICAgIHRvQ29vcmRzLFxyXG4gICAgICBzdWJ3YXlBdmFpbGFibGU6IGJlc3RTdWJ3YXlMaW5lICE9PSBudWxsIHx8IGhhc1RyYW5zZmVyT3B0aW9ucyxcclxuICAgICAgdHJhbnNmZXJSZXF1aXJlZDogIWJlc3RTdWJ3YXlMaW5lICYmIGhhc1RyYW5zZmVyT3B0aW9ucyxcclxuICAgICAgdHJhZmZpYzoge1xyXG4gICAgICAgIG9yaWdpbjogb3JpZ2luVHJhZmZpYyxcclxuICAgICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb25UcmFmZmljLFxyXG4gICAgICAgIGF2ZXJhZ2U6IGF2Z1RyYWZmaWNGYWN0b3JcclxuICAgICAgfSxcclxuICAgICAgdG9wb2xvZ3k6IHtcclxuICAgICAgICBvcmlnaW46IG9yaWdpblRvcG9sb2d5LFxyXG4gICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvblRvcG9sb2d5LFxyXG4gICAgICAgIGF2ZXJhZ2U6IGF2Z1RvcG9sb2d5RGlmZmljdWx0eVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsY3VsYXRpbmcgcm91dGVzOicsIGVycm9yKTtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IG1lc3NhZ2U6ICdFcnJvciBjYWxjdWxhdGluZyByb3V0ZXMnIH0pO1xyXG4gIH1cclxufSAiXSwibmFtZXMiOlsidHJhbnNpdEFQSSIsImxvY2F0aW9uQ29vcmRpbmF0ZXMiLCJ0cmFmZmljQ29uZGl0aW9ucyIsImxldmVsIiwiZmFjdG9yIiwidG9wb2xvZ3lEaWZmaWN1bHR5IiwiZ2V0Q29vcmRpbmF0ZXMiLCJsb2NhdGlvbiIsIm5vcm1hbGl6ZWRMb2NhdGlvbiIsInRvTG93ZXJDYXNlIiwibmFtZSIsImNvb3JkcyIsIk9iamVjdCIsImVudHJpZXMiLCJpbmNsdWRlcyIsImNhbGN1bGF0ZURpc3RhbmNlIiwibGF0MSIsImxuZzEiLCJsYXQyIiwibG5nMiIsIlIiLCJkTGF0IiwiTWF0aCIsIlBJIiwiZExuZyIsImEiLCJzaW4iLCJjb3MiLCJjIiwiYXRhbjIiLCJzcXJ0IiwiZGlzdGFuY2UiLCJnZXRSb3V0ZUNvbG9yIiwibW9kZSIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwibWVzc2FnZSIsImZyb20iLCJ0byIsInByaW9yaXR5Iiwibm9pc2UiLCJzYWZldHkiLCJiYWdzIiwid2hlZWxjaGFpciIsInF1ZXJ5IiwiZnJvbUNvb3JkcyIsInRvQ29vcmRzIiwiY29uc29sZSIsImxvZyIsInVzZXJQcmlvcml0eSIsInVzZXJOb2lzZSIsInVzZXJTYWZldHkiLCJ1c2VyQmFncyIsInBhcnNlSW50IiwicmVxdWlyZVdoZWVsY2hhaXIiLCJzdWJ3YXlTdGF0dXMiLCJnZXRTdWJ3YXlTdGF0dXMiLCJzdWJ3YXlMaW5lc0J5TG9jYXRpb24iLCJmcm9tQXJlYSIsImtleXMiLCJmaW5kIiwiYXJlYSIsInRvQXJlYSIsImZyb21TdWJ3YXlMaW5lcyIsInRvU3Vid2F5TGluZXMiLCJhdmFpbGFibGVTdWJ3YXlMaW5lcyIsImZpbHRlciIsImxpbmUiLCJoYXNUcmFuc2Zlck9wdGlvbnMiLCJsZW5ndGgiLCJvcGVyYXRpbmdTdWJ3YXlMaW5lcyIsImxpbmVTdGF0dXMiLCJzIiwiYmVzdFN1YndheUxpbmUiLCJmcm9tQm9yb3VnaFByZWZpeCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwidG9Cb3JvdWdoUHJlZml4IiwiYnVzUm91dGVzRnJvbSIsImdldEJ1c1JvdXRlcyIsImJ1c1JvdXRlc0J5QXJlYSIsInNwZWNpZmljRnJvbUJ1c2VzIiwic3BlY2lmaWNUb0J1c2VzIiwiY29ubmVjdGluZ0J1c2VzIiwiYnVzIiwib3JpZ2luQm9yb3VnaCIsImRlc3RpbmF0aW9uQm9yb3VnaCIsImlzQ3Jvc3NCb3JvdWdoVHJpcCIsImV4cHJlc3NCdXNSb3V0ZXMiLCJleHByZXNzQnVzUm91dGUiLCJyb3V0ZUtleSIsInJldmVyc2VSb3V0ZUtleSIsImJ1c1JvdXRlIiwiZmxvb3IiLCJyYW5kb20iLCJvcmlnaW5UcmFmZmljIiwiZGVzdGluYXRpb25UcmFmZmljIiwib3JpZ2luVG9wb2xvZ3kiLCJkZXN0aW5hdGlvblRvcG9sb2d5IiwiYXZnVHJhZmZpY0ZhY3RvciIsImF2Z1RvcG9sb2d5RGlmZmljdWx0eSIsImdlbmVyYXRlUm91dGVzIiwicm91dGVzIiwiY2FsY3VsYXRlQmFsYW5jZWRTY29yZSIsImR1cmF0aW9uIiwiY29zdCIsImNvbWZvcnQiLCJudW1UcmFuc2ZlcnMiLCJoYXNCYWdzIiwiaXNIaWxseSIsInRyYWZmaWNJbXBhY3QiLCJpc1doZWVsY2hhaXJBY2Nlc3NpYmxlIiwiY29tZm9ydFNjb3JlIiwibWF4IiwiYWRqdXN0ZWREdXJhdGlvbiIsInRpbWVTY29yZSIsImNvc3RTY29yZSIsInRyYW5zZmVyU2NvcmUiLCJ0aW1lV2VpZ2h0IiwiY29zdFdlaWdodCIsImNvbWZvcnRXZWlnaHQiLCJ0cmFuc2ZlcldlaWdodCIsImFjY2Vzc2liaWxpdHlQZW5hbHR5IiwicmF3U2NvcmUiLCJyYXciLCJzY29yZSIsInJvdW5kIiwiZ2V0Um91dGVDb2xvckZyb21TY29yZSIsImdldFJvdXRlQ29sb3JGb3JNb2RlIiwiYmVzdE92ZXJhbGxSb3V0ZSIsImlkIiwidmVjdG9yU2NvcmUiLCJzZWdtZW50cyIsImhhc1RvcG9sb2d5SW1wYWN0IiwidHJhZmZpYyIsImltcGFjdCIsImV0YSIsImNvc3RCcmVha2Rvd24iLCJmYXJlIiwiYWRkaXRpb25hbEZlZXMiLCJ0b3RhbENvc3QiLCJzY29yZXMiLCJvdmVyYWxsIiwidGltZSIsInRyYW5zZmVycyIsInJvdXRlQ29sb3IiLCJwYXRoRGF0YSIsImNhbGN1bGF0ZUVUQSIsImR1cmF0aW9uTWludXRlcyIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiaG91ciIsIm1pbnV0ZSIsImdlbmVyYXRlUGF0aERhdGEiLCJyb3V0ZSIsImxhc3RDb29yZHMiLCJmb3JFYWNoIiwic2VnbWVudCIsImluZGV4IiwiaXNMYXN0U2VnbWVudCIsImVuZENvb3JkcyIsImVuZExvY2F0aW9uIiwicHVzaCIsInR5cGUiLCJjb2xvciIsInBvaW50cyIsIm51bVBvaW50cyIsImNlaWwiLCJjdXJyZW50UG9pbnQiLCJpIiwiZGFzaEFycmF5IiwiZmluYWxpemVSb3V0ZSIsInNvbWUiLCJyb2FkQmFzZWRTZWdtZW50cyIsImV2ZXJ5IiwiaGFzT3duUHJvcGVydHkiLCJ3aGVlbGNoYWlyQWNjZXNzaWJsZSIsInJlZHVjZSIsInRvdGFsIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJzZWdtZW50U2NvcmUiLCJzdGFydExvY2F0aW9uIiwibGluZUluZm8iLCJmcm9tTGluZSIsInRvTGluZSIsInN1YndheVJvdXRlIiwidWJlclJvdXRlIiwidGF4aVJvdXRlIiwiZWJpa2VSb3V0ZSIsImJ1c09wdGlvbiIsImJpa2VPcHRpb24iLCJiYWxhbmNlZFNjb3JlIiwibW9ja1JvdXRlcyIsIm1hcCIsImNoZWFwZXN0Um91dGUiLCJmYXN0ZXN0Um91dGUiLCJmaWx0ZXJlZFJvdXRlcyIsImFjY2Vzc2libGVSb3V0ZSIsInN1YndheUF2YWlsYWJsZSIsInRyYW5zZmVyUmVxdWlyZWQiLCJvcmlnaW4iLCJkZXN0aW5hdGlvbiIsImF2ZXJhZ2UiLCJ0b3BvbG9neSIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/routes.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%5Cpages%5Capi%5Croutes.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();