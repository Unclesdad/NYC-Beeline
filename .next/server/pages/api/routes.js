"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/routes";
exports.ids = ["pages/api/routes"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Froutes.ts&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Froutes.ts&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/pages/api/routes.ts */ \"(api)/./src/pages/api/routes.ts\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/routes\",\n        pathname: \"/api/routes\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRnJvdXRlcyZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnNyYyUyRnBhZ2VzJTJGYXBpJTJGcm91dGVzLnRzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNMO0FBQzFEO0FBQ3NEO0FBQ3REO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyxxREFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMscURBQVE7QUFDcEM7QUFDTyx3QkFBd0IsZ0hBQW1CO0FBQ2xEO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWJlZWxpbmUvPzUwODkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3NyYy9wYWdlcy9hcGkvcm91dGVzLnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvcm91dGVzXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvcm91dGVzXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogXCJcIixcbiAgICAgICAgZmlsZW5hbWU6IFwiXCJcbiAgICB9LFxuICAgIHVzZXJsYW5kXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMtYXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Froutes.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transitAPI: () => (/* binding */ transitAPI)\n/* harmony export */ });\n// API configuration\nconst API_CONFIG = {\n    MTA_BASE_URL: \"https://api.mta.info/api\",\n    CITIBIKE_BASE_URL: \"https://gbfs.citibikenyc.com/gbfs/en\",\n    UBER_BASE_URL: \"https://api.uber.com/v1\",\n    GOOGLE_MAPS_BASE_URL: \"https://maps.googleapis.com/maps/api\"\n};\n// Mock data (in a real app, these would be API calls)\nconst mockSubwayData = [\n    {\n        line: \"A\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"C\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"E\",\n        status: \"delayed\",\n        delay: 10,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"B\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"D\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"F\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"M\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"G\",\n        status: \"delayed\",\n        delay: 5,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"L\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"N\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"Q\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"R\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"W\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"1\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"2\",\n        status: \"delayed\",\n        delay: 8,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"3\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"4\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"5\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"6\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"7\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"J\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"Z\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"S\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    }\n];\nconst mockBusRoutes = [\n    \"Q58\",\n    \"Q59\",\n    \"Q60\",\n    \"B41\",\n    \"B42\",\n    \"B44\",\n    \"B45\",\n    \"B46\",\n    \"M1\",\n    \"M2\",\n    \"M3\",\n    \"M4\",\n    \"M5\",\n    \"BX1\",\n    \"BX2\",\n    \"BX9\",\n    \"BX10\",\n    \"S40\",\n    \"S44\",\n    \"S46\",\n    \"S48\"\n];\nconst generateMockBusData = ()=>{\n    return mockBusRoutes.map((route)=>({\n            route,\n            location: {\n                lat: 40.7128 + (Math.random() - 0.5) * 0.2,\n                lng: -74.0060 + (Math.random() - 0.5) * 0.2\n            },\n            next_stop: `${route} Stop ${Math.floor(Math.random() * 20) + 1}`,\n            estimated_arrival: new Date(Date.now() + Math.floor(Math.random() * 20) * 60000).toISOString(),\n            crowd_level: [\n                \"low\",\n                \"medium\",\n                \"high\"\n            ][Math.floor(Math.random() * 3)]\n        }));\n};\n// API service functions\nclass TransitAPI {\n    // Subway data\n    async getSubwayStatus() {\n        // In a real app, this would be an API call to MTA\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/subway/status`).then(res => res.data);\n        // Using mock data for now\n        return Promise.resolve(mockSubwayData);\n    }\n    async getSubwayLine(line) {\n        // In a real app, this would be an API call to MTA\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/subway/line/${line}`).then(res => res.data);\n        // Using mock data for now\n        const lineData = mockSubwayData.find((subway)=>subway.line === line);\n        return Promise.resolve(lineData || null);\n    }\n    // Bus data\n    async getBusRoutes(borough) {\n        // In a real app, this would be an API call\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/bus/routes?borough=${borough}`).then(res => res.data);\n        // Using mock data filtered by borough prefix\n        const boroughPrefix = borough.charAt(0).toUpperCase();\n        const routes = mockBusRoutes.filter((route)=>route.startsWith(boroughPrefix));\n        return Promise.resolve(routes);\n    }\n    async getBusLocations(route) {\n        // In a real app, this would be an API call\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/bus/route/${route}/locations`).then(res => res.data);\n        // Using mock data\n        const busData = generateMockBusData().filter((bus)=>bus.route === route);\n        return Promise.resolve(busData);\n    }\n    // Bike data\n    async getBikeStations(lat, lng, radius = 1) {\n        // In a real app, this would be an API call to Citi Bike\n        // return axios.get(`${API_CONFIG.CITIBIKE_BASE_URL}/station_information.json`).then(res => res.data.data.stations);\n        // Generate mock bike stations around the provided coordinates\n        const stations = [];\n        const stationCount = Math.floor(Math.random() * 5) + 3; // 3-7 stations\n        for(let i = 0; i < stationCount; i++){\n            const stationLat = lat + (Math.random() - 0.5) * 0.02 * radius;\n            const stationLng = lng + (Math.random() - 0.5) * 0.02 * radius;\n            stations.push({\n                station_id: `station-${i}`,\n                name: `Bike Station ${i + 1}`,\n                location: {\n                    lat: stationLat,\n                    lng: stationLng\n                },\n                available_bikes: Math.floor(Math.random() * 15),\n                available_docks: Math.floor(Math.random() * 10)\n            });\n        }\n        return Promise.resolve(stations);\n    }\n    // Uber/Taxi data\n    async getUberEstimate(startLat, startLng, endLat, endLng) {\n        // In a real app, this would be an API call to Uber\n        // return axios.get(`${API_CONFIG.UBER_BASE_URL}/estimates/price?start_latitude=${startLat}&start_longitude=${startLng}&end_latitude=${endLat}&end_longitude=${endLng}`).then(res => res.data.prices);\n        // Generate mock Uber options\n        const options = [\n            {\n                product_id: \"uberx\",\n                display_name: \"UberX\"\n            },\n            {\n                product_id: \"uberxl\",\n                display_name: \"UberXL\"\n            },\n            {\n                product_id: \"uberblack\",\n                display_name: \"Uber Black\"\n            },\n            {\n                product_id: \"uberpool\",\n                display_name: \"Uber Pool\"\n            }\n        ];\n        // Calculate mock duration and fare based on distance\n        const distance = this.calculateDistance(startLat, startLng, endLat, endLng);\n        return Promise.resolve(options.map((option)=>({\n                ...option,\n                estimate: {\n                    duration: Math.floor(distance * 120),\n                    fare: Math.floor((option.product_id === \"uberpool\" ? 2.0 : 2.5) * distance * 100) / 100\n                }\n            })));\n    }\n    async getTaxiEstimate(startLat, startLng, endLat, endLng) {\n        // In a real app, this would be an API call or calculation\n        // return axios.get(`${API_CONFIG.TAXI_BASE_URL}/estimate?start_latitude=${startLat}&start_longitude=${startLng}&end_latitude=${endLat}&end_longitude=${endLng}`).then(res => res.data.fare);\n        // Calculate mock taxi fare based on distance\n        const distance = this.calculateDistance(startLat, startLng, endLat, endLng);\n        const baseFare = 2.50;\n        const perMileFare = 2.50;\n        return Promise.resolve(Math.floor((baseFare + distance * perMileFare) * 100) / 100);\n    }\n    // Helper functions\n    calculateDistance(lat1, lng1, lat2, lng2) {\n        const R = 3958.8; // Earth radius in miles\n        const dLat = this.toRadians(lat2 - lat1);\n        const dLng = this.toRadians(lng2 - lng1);\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        const distance = R * c;\n        return distance;\n    }\n    toRadians(degrees) {\n        return degrees * Math.PI / 180;\n    }\n}\n// Export a singleton instance\nconst transitAPI = new TransitAPI();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sS0FBSzlELEtBQUtrRSxHQUFHLENBQUNKLE9BQU8sS0FDckM5RCxLQUFLbUUsR0FBRyxDQUFDLElBQUksQ0FBQ0osU0FBUyxDQUFDTixTQUFTekQsS0FBS21FLEdBQUcsQ0FBQyxJQUFJLENBQUNKLFNBQVMsQ0FBQ0osU0FDekQzRCxLQUFLa0UsR0FBRyxDQUFDRixPQUFPLEtBQUtoRSxLQUFLa0UsR0FBRyxDQUFDRixPQUFPO1FBQ3ZDLE1BQU1JLElBQUksSUFBSXBFLEtBQUtxRSxLQUFLLENBQUNyRSxLQUFLc0UsSUFBSSxDQUFDTCxJQUFJakUsS0FBS3NFLElBQUksQ0FBQyxJQUFJTDtRQUNyRCxNQUFNakIsV0FBV2EsSUFBSU87UUFFckIsT0FBT3BCO0lBQ1Q7SUFFUWUsVUFBVVEsT0FBZSxFQUFVO1FBQ3pDLE9BQU9BLFVBQVV2RSxLQUFLd0UsRUFBRSxHQUFHO0lBQzdCO0FBQ0Y7QUFFQSw4QkFBOEI7QUFDdkIsTUFBTUMsYUFBYSxJQUFJaEUsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1iZWVsaW5lLy4vc3JjL2xpYi9hcGkudHM/MmZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG4vLyBBUEkgY29uZmlndXJhdGlvblxuY29uc3QgQVBJX0NPTkZJRyA9IHtcbiAgTVRBX0JBU0VfVVJMOiAnaHR0cHM6Ly9hcGkubXRhLmluZm8vYXBpJyxcbiAgQ0lUSUJJS0VfQkFTRV9VUkw6ICdodHRwczovL2diZnMuY2l0aWJpa2VueWMuY29tL2diZnMvZW4nLFxuICBVQkVSX0JBU0VfVVJMOiAnaHR0cHM6Ly9hcGkudWJlci5jb20vdjEnLFxuICBHT09HTEVfTUFQU19CQVNFX1VSTDogJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaScsXG59O1xuXG4vLyBUcmFuc2l0IGRhdGEgaW50ZXJmYWNlc1xuZXhwb3J0IGludGVyZmFjZSBTdWJ3YXlEYXRhIHtcbiAgbGluZTogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbiAgZGVsYXk6IG51bWJlcjsgLy8gaW4gbWludXRlc1xuICBjcm93ZF9sZXZlbDogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCdXNEYXRhIHtcbiAgcm91dGU6IHN0cmluZztcbiAgbG9jYXRpb246IHtcbiAgICBsYXQ6IG51bWJlcjtcbiAgICBsbmc6IG51bWJlcjtcbiAgfTtcbiAgbmV4dF9zdG9wOiBzdHJpbmc7XG4gIGVzdGltYXRlZF9hcnJpdmFsOiBzdHJpbmc7XG4gIGNyb3dkX2xldmVsOiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJpa2VEYXRhIHtcbiAgc3RhdGlvbl9pZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGxvY2F0aW9uOiB7XG4gICAgbGF0OiBudW1iZXI7XG4gICAgbG5nOiBudW1iZXI7XG4gIH07XG4gIGF2YWlsYWJsZV9iaWtlczogbnVtYmVyO1xuICBhdmFpbGFibGVfZG9ja3M6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVYmVyRGF0YSB7XG4gIHByb2R1Y3RfaWQ6IHN0cmluZztcbiAgZGlzcGxheV9uYW1lOiBzdHJpbmc7XG4gIGVzdGltYXRlOiB7XG4gICAgZHVyYXRpb246IG51bWJlcjsgLy8gaW4gc2Vjb25kc1xuICAgIGZhcmU6IG51bWJlcjsgLy8gaW4gZG9sbGFyc1xuICB9O1xufVxuXG4vLyBNb2NrIGRhdGEgKGluIGEgcmVhbCBhcHAsIHRoZXNlIHdvdWxkIGJlIEFQSSBjYWxscylcbmNvbnN0IG1vY2tTdWJ3YXlEYXRhOiBTdWJ3YXlEYXRhW10gPSBbXG4gIHsgbGluZTogJ0EnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXG4gIHsgbGluZTogJ0MnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXG4gIHsgbGluZTogJ0UnLCBzdGF0dXM6ICdkZWxheWVkJywgZGVsYXk6IDEwLCBjcm93ZF9sZXZlbDogJ2hpZ2gnIH0sXG4gIHsgbGluZTogJ0InLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXG4gIHsgbGluZTogJ0QnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXG4gIHsgbGluZTogJ0YnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXG4gIHsgbGluZTogJ00nLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXG4gIHsgbGluZTogJ0cnLCBzdGF0dXM6ICdkZWxheWVkJywgZGVsYXk6IDUsIGNyb3dkX2xldmVsOiAnbG93JyB9LFxuICB7IGxpbmU6ICdMJywgc3RhdHVzOiAnbm9ybWFsJywgZGVsYXk6IDAsIGNyb3dkX2xldmVsOiAnaGlnaCcgfSxcbiAgeyBsaW5lOiAnTicsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ21lZGl1bScgfSxcbiAgeyBsaW5lOiAnUScsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ21lZGl1bScgfSxcbiAgeyBsaW5lOiAnUicsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ2xvdycgfSxcbiAgeyBsaW5lOiAnVycsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ2xvdycgfSxcbiAgeyBsaW5lOiAnMScsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ21lZGl1bScgfSxcbiAgeyBsaW5lOiAnMicsIHN0YXR1czogJ2RlbGF5ZWQnLCBkZWxheTogOCwgY3Jvd2RfbGV2ZWw6ICdoaWdoJyB9LFxuICB7IGxpbmU6ICczJywgc3RhdHVzOiAnbm9ybWFsJywgZGVsYXk6IDAsIGNyb3dkX2xldmVsOiAnbWVkaXVtJyB9LFxuICB7IGxpbmU6ICc0Jywgc3RhdHVzOiAnbm9ybWFsJywgZGVsYXk6IDAsIGNyb3dkX2xldmVsOiAnaGlnaCcgfSxcbiAgeyBsaW5lOiAnNScsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ21lZGl1bScgfSxcbiAgeyBsaW5lOiAnNicsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ2hpZ2gnIH0sXG4gIHsgbGluZTogJzcnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXG4gIHsgbGluZTogJ0onLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXG4gIHsgbGluZTogJ1onLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXG4gIHsgbGluZTogJ1MnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXG5dO1xuXG5jb25zdCBtb2NrQnVzUm91dGVzOiBzdHJpbmdbXSA9IFsnUTU4JywgJ1E1OScsICdRNjAnLCAnQjQxJywgJ0I0MicsICdCNDQnLCAnQjQ1JywgJ0I0NicsICdNMScsICdNMicsICdNMycsICdNNCcsICdNNScsICdCWDEnLCAnQlgyJywgJ0JYOScsICdCWDEwJywgJ1M0MCcsICdTNDQnLCAnUzQ2JywgJ1M0OCddO1xuXG5jb25zdCBnZW5lcmF0ZU1vY2tCdXNEYXRhID0gKCk6IEJ1c0RhdGFbXSA9PiB7XG4gIHJldHVybiBtb2NrQnVzUm91dGVzLm1hcChyb3V0ZSA9PiAoe1xuICAgIHJvdXRlLFxuICAgIGxvY2F0aW9uOiB7XG4gICAgICBsYXQ6IDQwLjcxMjggKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjIsXG4gICAgICBsbmc6IC03NC4wMDYwICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4yLFxuICAgIH0sXG4gICAgbmV4dF9zdG9wOiBgJHtyb3V0ZX0gU3RvcCAke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwKSArIDF9YCxcbiAgICBlc3RpbWF0ZWRfYXJyaXZhbDogbmV3IERhdGUoRGF0ZS5ub3coKSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwKSAqIDYwMDAwKS50b0lTT1N0cmluZygpLFxuICAgIGNyb3dkX2xldmVsOiBbJ2xvdycsICdtZWRpdW0nLCAnaGlnaCddW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMpXSBhcyAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnLFxuICB9KSk7XG59O1xuXG4vLyBBUEkgc2VydmljZSBmdW5jdGlvbnNcbmNsYXNzIFRyYW5zaXRBUEkge1xuICAvLyBTdWJ3YXkgZGF0YVxuICBhc3luYyBnZXRTdWJ3YXlTdGF0dXMoKTogUHJvbWlzZTxTdWJ3YXlEYXRhW10+IHtcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIGFuIEFQSSBjYWxsIHRvIE1UQVxuICAgIC8vIHJldHVybiBheGlvcy5nZXQoYCR7QVBJX0NPTkZJRy5NVEFfQkFTRV9VUkx9L3N1YndheS9zdGF0dXNgKS50aGVuKHJlcyA9PiByZXMuZGF0YSk7XG4gICAgXG4gICAgLy8gVXNpbmcgbW9jayBkYXRhIGZvciBub3dcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1vY2tTdWJ3YXlEYXRhKTtcbiAgfVxuXG4gIGFzeW5jIGdldFN1YndheUxpbmUobGluZTogc3RyaW5nKTogUHJvbWlzZTxTdWJ3YXlEYXRhIHwgbnVsbD4ge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgYmUgYW4gQVBJIGNhbGwgdG8gTVRBXG4gICAgLy8gcmV0dXJuIGF4aW9zLmdldChgJHtBUElfQ09ORklHLk1UQV9CQVNFX1VSTH0vc3Vid2F5L2xpbmUvJHtsaW5lfWApLnRoZW4ocmVzID0+IHJlcy5kYXRhKTtcbiAgICBcbiAgICAvLyBVc2luZyBtb2NrIGRhdGEgZm9yIG5vd1xuICAgIGNvbnN0IGxpbmVEYXRhID0gbW9ja1N1YndheURhdGEuZmluZChzdWJ3YXkgPT4gc3Vid2F5LmxpbmUgPT09IGxpbmUpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobGluZURhdGEgfHwgbnVsbCk7XG4gIH1cblxuICAvLyBCdXMgZGF0YVxuICBhc3luYyBnZXRCdXNSb3V0ZXMoYm9yb3VnaDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgYmUgYW4gQVBJIGNhbGxcbiAgICAvLyByZXR1cm4gYXhpb3MuZ2V0KGAke0FQSV9DT05GSUcuTVRBX0JBU0VfVVJMfS9idXMvcm91dGVzP2Jvcm91Z2g9JHtib3JvdWdofWApLnRoZW4ocmVzID0+IHJlcy5kYXRhKTtcbiAgICBcbiAgICAvLyBVc2luZyBtb2NrIGRhdGEgZmlsdGVyZWQgYnkgYm9yb3VnaCBwcmVmaXhcbiAgICBjb25zdCBib3JvdWdoUHJlZml4ID0gYm9yb3VnaC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCByb3V0ZXMgPSBtb2NrQnVzUm91dGVzLmZpbHRlcihyb3V0ZSA9PiByb3V0ZS5zdGFydHNXaXRoKGJvcm91Z2hQcmVmaXgpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJvdXRlcyk7XG4gIH1cblxuICBhc3luYyBnZXRCdXNMb2NhdGlvbnMocm91dGU6IHN0cmluZyk6IFByb21pc2U8QnVzRGF0YVtdPiB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZSBhbiBBUEkgY2FsbFxuICAgIC8vIHJldHVybiBheGlvcy5nZXQoYCR7QVBJX0NPTkZJRy5NVEFfQkFTRV9VUkx9L2J1cy9yb3V0ZS8ke3JvdXRlfS9sb2NhdGlvbnNgKS50aGVuKHJlcyA9PiByZXMuZGF0YSk7XG4gICAgXG4gICAgLy8gVXNpbmcgbW9jayBkYXRhXG4gICAgY29uc3QgYnVzRGF0YSA9IGdlbmVyYXRlTW9ja0J1c0RhdGEoKS5maWx0ZXIoYnVzID0+IGJ1cy5yb3V0ZSA9PT0gcm91dGUpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYnVzRGF0YSk7XG4gIH1cblxuICAvLyBCaWtlIGRhdGFcbiAgYXN5bmMgZ2V0QmlrZVN0YXRpb25zKGxhdDogbnVtYmVyLCBsbmc6IG51bWJlciwgcmFkaXVzOiBudW1iZXIgPSAxKTogUHJvbWlzZTxCaWtlRGF0YVtdPiB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZSBhbiBBUEkgY2FsbCB0byBDaXRpIEJpa2VcbiAgICAvLyByZXR1cm4gYXhpb3MuZ2V0KGAke0FQSV9DT05GSUcuQ0lUSUJJS0VfQkFTRV9VUkx9L3N0YXRpb25faW5mb3JtYXRpb24uanNvbmApLnRoZW4ocmVzID0+IHJlcy5kYXRhLmRhdGEuc3RhdGlvbnMpO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIG1vY2sgYmlrZSBzdGF0aW9ucyBhcm91bmQgdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGVzXG4gICAgY29uc3Qgc3RhdGlvbnM6IEJpa2VEYXRhW10gPSBbXTtcbiAgICBjb25zdCBzdGF0aW9uQ291bnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1KSArIDM7IC8vIDMtNyBzdGF0aW9uc1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXRpb25MYXQgPSBsYXQgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAyICogcmFkaXVzO1xuICAgICAgY29uc3Qgc3RhdGlvbkxuZyA9IGxuZyArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMDIgKiByYWRpdXM7XG4gICAgICBcbiAgICAgIHN0YXRpb25zLnB1c2goe1xuICAgICAgICBzdGF0aW9uX2lkOiBgc3RhdGlvbi0ke2l9YCxcbiAgICAgICAgbmFtZTogYEJpa2UgU3RhdGlvbiAke2kgKyAxfWAsXG4gICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgbGF0OiBzdGF0aW9uTGF0LFxuICAgICAgICAgIGxuZzogc3RhdGlvbkxuZyxcbiAgICAgICAgfSxcbiAgICAgICAgYXZhaWxhYmxlX2Jpa2VzOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNSksXG4gICAgICAgIGF2YWlsYWJsZV9kb2NrczogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApLFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3RhdGlvbnMpO1xuICB9XG5cbiAgLy8gVWJlci9UYXhpIGRhdGFcbiAgYXN5bmMgZ2V0VWJlckVzdGltYXRlKHN0YXJ0TGF0OiBudW1iZXIsIHN0YXJ0TG5nOiBudW1iZXIsIGVuZExhdDogbnVtYmVyLCBlbmRMbmc6IG51bWJlcik6IFByb21pc2U8VWJlckRhdGFbXT4ge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgYmUgYW4gQVBJIGNhbGwgdG8gVWJlclxuICAgIC8vIHJldHVybiBheGlvcy5nZXQoYCR7QVBJX0NPTkZJRy5VQkVSX0JBU0VfVVJMfS9lc3RpbWF0ZXMvcHJpY2U/c3RhcnRfbGF0aXR1ZGU9JHtzdGFydExhdH0mc3RhcnRfbG9uZ2l0dWRlPSR7c3RhcnRMbmd9JmVuZF9sYXRpdHVkZT0ke2VuZExhdH0mZW5kX2xvbmdpdHVkZT0ke2VuZExuZ31gKS50aGVuKHJlcyA9PiByZXMuZGF0YS5wcmljZXMpO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIG1vY2sgVWJlciBvcHRpb25zXG4gICAgY29uc3Qgb3B0aW9ucyA9IFtcbiAgICAgIHsgcHJvZHVjdF9pZDogJ3ViZXJ4JywgZGlzcGxheV9uYW1lOiAnVWJlclgnIH0sXG4gICAgICB7IHByb2R1Y3RfaWQ6ICd1YmVyeGwnLCBkaXNwbGF5X25hbWU6ICdVYmVyWEwnIH0sXG4gICAgICB7IHByb2R1Y3RfaWQ6ICd1YmVyYmxhY2snLCBkaXNwbGF5X25hbWU6ICdVYmVyIEJsYWNrJyB9LFxuICAgICAgeyBwcm9kdWN0X2lkOiAndWJlcnBvb2wnLCBkaXNwbGF5X25hbWU6ICdVYmVyIFBvb2wnIH0sXG4gICAgXTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgbW9jayBkdXJhdGlvbiBhbmQgZmFyZSBiYXNlZCBvbiBkaXN0YW5jZVxuICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShzdGFydExhdCwgc3RhcnRMbmcsIGVuZExhdCwgZW5kTG5nKTtcbiAgICBcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMubWFwKG9wdGlvbiA9PiAoe1xuICAgICAgLi4ub3B0aW9uLFxuICAgICAgZXN0aW1hdGU6IHtcbiAgICAgICAgZHVyYXRpb246IE1hdGguZmxvb3IoZGlzdGFuY2UgKiAxMjApLCAvLyAxMjAgc2Vjb25kcyBwZXIgbWlsZVxuICAgICAgICBmYXJlOiBNYXRoLmZsb29yKChvcHRpb24ucHJvZHVjdF9pZCA9PT0gJ3ViZXJwb29sJyA/IDIuMCA6IDIuNSkgKiBkaXN0YW5jZSAqIDEwMCkgLyAxMDAsXG4gICAgICB9LFxuICAgIH0pKSk7XG4gIH1cblxuICBhc3luYyBnZXRUYXhpRXN0aW1hdGUoc3RhcnRMYXQ6IG51bWJlciwgc3RhcnRMbmc6IG51bWJlciwgZW5kTGF0OiBudW1iZXIsIGVuZExuZzogbnVtYmVyKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIGFuIEFQSSBjYWxsIG9yIGNhbGN1bGF0aW9uXG4gICAgLy8gcmV0dXJuIGF4aW9zLmdldChgJHtBUElfQ09ORklHLlRBWElfQkFTRV9VUkx9L2VzdGltYXRlP3N0YXJ0X2xhdGl0dWRlPSR7c3RhcnRMYXR9JnN0YXJ0X2xvbmdpdHVkZT0ke3N0YXJ0TG5nfSZlbmRfbGF0aXR1ZGU9JHtlbmRMYXR9JmVuZF9sb25naXR1ZGU9JHtlbmRMbmd9YCkudGhlbihyZXMgPT4gcmVzLmRhdGEuZmFyZSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIG1vY2sgdGF4aSBmYXJlIGJhc2VkIG9uIGRpc3RhbmNlXG4gICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKHN0YXJ0TGF0LCBzdGFydExuZywgZW5kTGF0LCBlbmRMbmcpO1xuICAgIGNvbnN0IGJhc2VGYXJlID0gMi41MDtcbiAgICBjb25zdCBwZXJNaWxlRmFyZSA9IDIuNTA7XG4gICAgXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShNYXRoLmZsb29yKChiYXNlRmFyZSArIGRpc3RhbmNlICogcGVyTWlsZUZhcmUpICogMTAwKSAvIDEwMCk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb25zXG4gIHByaXZhdGUgY2FsY3VsYXRlRGlzdGFuY2UobGF0MTogbnVtYmVyLCBsbmcxOiBudW1iZXIsIGxhdDI6IG51bWJlciwgbG5nMjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBSID0gMzk1OC44OyAvLyBFYXJ0aCByYWRpdXMgaW4gbWlsZXNcbiAgICBjb25zdCBkTGF0ID0gdGhpcy50b1JhZGlhbnMobGF0MiAtIGxhdDEpO1xuICAgIGNvbnN0IGRMbmcgPSB0aGlzLnRvUmFkaWFucyhsbmcyIC0gbG5nMSk7XG4gICAgY29uc3QgYSA9XG4gICAgICBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xuICAgICAgTWF0aC5jb3ModGhpcy50b1JhZGlhbnMobGF0MSkpICogTWF0aC5jb3ModGhpcy50b1JhZGlhbnMobGF0MikpICpcbiAgICAgIE1hdGguc2luKGRMbmcgLyAyKSAqIE1hdGguc2luKGRMbmcgLyAyKTtcbiAgICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IFIgKiBjO1xuICAgIFxuICAgIHJldHVybiBkaXN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgdG9SYWRpYW5zKGRlZ3JlZXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xuICB9XG59XG5cbi8vIEV4cG9ydCBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IHRyYW5zaXRBUEkgPSBuZXcgVHJhbnNpdEFQSSgpOyAiXSwibmFtZXMiOlsiQVBJX0NPTkZJRyIsIk1UQV9CQVNFX1VSTCIsIkNJVElCSUtFX0JBU0VfVVJMIiwiVUJFUl9CQVNFX1VSTCIsIkdPT0dMRV9NQVBTX0JBU0VfVVJMIiwibW9ja1N1YndheURhdGEiLCJsaW5lIiwic3RhdHVzIiwiZGVsYXkiLCJjcm93ZF9sZXZlbCIsIm1vY2tCdXNSb3V0ZXMiLCJnZW5lcmF0ZU1vY2tCdXNEYXRhIiwibWFwIiwicm91dGUiLCJsb2NhdGlvbiIsImxhdCIsIk1hdGgiLCJyYW5kb20iLCJsbmciLCJuZXh0X3N0b3AiLCJmbG9vciIsImVzdGltYXRlZF9hcnJpdmFsIiwiRGF0ZSIsIm5vdyIsInRvSVNPU3RyaW5nIiwiVHJhbnNpdEFQSSIsImdldFN1YndheVN0YXR1cyIsIlByb21pc2UiLCJyZXNvbHZlIiwiZ2V0U3Vid2F5TGluZSIsImxpbmVEYXRhIiwiZmluZCIsInN1YndheSIsImdldEJ1c1JvdXRlcyIsImJvcm91Z2giLCJib3JvdWdoUHJlZml4IiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJyb3V0ZXMiLCJmaWx0ZXIiLCJzdGFydHNXaXRoIiwiZ2V0QnVzTG9jYXRpb25zIiwiYnVzRGF0YSIsImJ1cyIsImdldEJpa2VTdGF0aW9ucyIsInJhZGl1cyIsInN0YXRpb25zIiwic3RhdGlvbkNvdW50IiwiaSIsInN0YXRpb25MYXQiLCJzdGF0aW9uTG5nIiwicHVzaCIsInN0YXRpb25faWQiLCJuYW1lIiwiYXZhaWxhYmxlX2Jpa2VzIiwiYXZhaWxhYmxlX2RvY2tzIiwiZ2V0VWJlckVzdGltYXRlIiwic3RhcnRMYXQiLCJzdGFydExuZyIsImVuZExhdCIsImVuZExuZyIsIm9wdGlvbnMiLCJwcm9kdWN0X2lkIiwiZGlzcGxheV9uYW1lIiwiZGlzdGFuY2UiLCJjYWxjdWxhdGVEaXN0YW5jZSIsIm9wdGlvbiIsImVzdGltYXRlIiwiZHVyYXRpb24iLCJmYXJlIiwiZ2V0VGF4aUVzdGltYXRlIiwiYmFzZUZhcmUiLCJwZXJNaWxlRmFyZSIsImxhdDEiLCJsbmcxIiwibGF0MiIsImxuZzIiLCJSIiwiZExhdCIsInRvUmFkaWFucyIsImRMbmciLCJhIiwic2luIiwiY29zIiwiYyIsImF0YW4yIiwic3FydCIsImRlZ3JlZXMiLCJQSSIsInRyYW5zaXRBUEkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./src/lib/api.ts\n");

/***/ }),

/***/ "(api)/./src/pages/api/routes.ts":
/*!*********************************!*\
  !*** ./src/pages/api/routes.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

<<<<<<< HEAD
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/api */ \"(api)/./src/lib/api.ts\");\n\n// Mock coordinates for some NYC locations\nconst locationCoordinates = {\n    \"Manhattan\": [\n        40.7831,\n        -73.9712\n    ],\n    \"Brooklyn\": [\n        40.6782,\n        -73.9442\n    ],\n    \"Queens\": [\n        40.7282,\n        -73.7949\n    ],\n    \"Bronx\": [\n        40.8448,\n        -73.8648\n    ],\n    \"Staten Island\": [\n        40.5795,\n        -74.1502\n    ],\n    \"Times Square\": [\n        40.7580,\n        -73.9855\n    ],\n    \"Central Park\": [\n        40.7829,\n        -73.9654\n    ],\n    \"Prospect Park\": [\n        40.6602,\n        -73.9690\n    ],\n    \"Flushing Meadows\": [\n        40.7466,\n        -73.8422\n    ],\n    \"Flushing\": [\n        40.7654,\n        -73.8318\n    ],\n    \"Bayside\": [\n        40.7612,\n        -73.7716\n    ],\n    \"Main St\": [\n        40.7590,\n        -73.8300\n    ],\n    \"Yankee Stadium\": [\n        40.8296,\n        -73.9262\n    ]\n};\n// Traffic data mock (in a real app this would be real-time data)\nconst trafficConditions = {\n    \"Manhattan\": {\n        level: \"high\",\n        factor: 1.5\n    },\n    \"Brooklyn\": {\n        level: \"medium\",\n        factor: 1.3\n    },\n    \"Queens\": {\n        level: \"medium\",\n        factor: 1.2\n    },\n    \"Bronx\": {\n        level: \"medium\",\n        factor: 1.25\n    },\n    \"Staten Island\": {\n        level: \"low\",\n        factor: 1.1\n    },\n    \"Flushing\": {\n        level: \"medium\",\n        factor: 1.2\n    },\n    \"Bayside\": {\n        level: \"low\",\n        factor: 1.1\n    },\n    \"Times Square\": {\n        level: \"high\",\n        factor: 1.6\n    },\n    \"Central Park\": {\n        level: \"medium\",\n        factor: 1.3\n    }\n};\n// Topology data - elevation changes that affect walking/biking comfort\nconst topologyDifficulty = {\n    \"Manhattan\": 0.2,\n    \"Brooklyn\": 0.1,\n    \"Queens\": 0.1,\n    \"Bronx\": 0.4,\n    \"Staten Island\": 0.5,\n    \"Flushing\": 0.1,\n    \"Bayside\": 0.2,\n    \"Times Square\": 0.1,\n    \"Central Park\": 0.3\n};\n// Helper function to get coordinates from a location string\nconst getCoordinates = (location)=>{\n    // Normalize the location string for better matching\n    const normalizedLocation = location.toLowerCase();\n    // First try exact matches for specific neighborhoods/locations\n    for (const [name, coords] of Object.entries(locationCoordinates)){\n        if (normalizedLocation.includes(name.toLowerCase())) {\n            return coords;\n        }\n    }\n    // If no specific match, try to determine which borough it's in\n    if (normalizedLocation.includes(\"queens\") || normalizedLocation.includes(\"flushing\") || normalizedLocation.includes(\"bayside\") || normalizedLocation.includes(\"jamaica\") || normalizedLocation.includes(\"astoria\")) {\n        return locationCoordinates[\"Queens\"];\n    }\n    if (normalizedLocation.includes(\"brooklyn\") || normalizedLocation.includes(\"williamsburg\") || normalizedLocation.includes(\"park slope\")) {\n        return locationCoordinates[\"Brooklyn\"];\n    }\n    if (normalizedLocation.includes(\"bronx\")) {\n        return locationCoordinates[\"Bronx\"];\n    }\n    if (normalizedLocation.includes(\"staten\")) {\n        return locationCoordinates[\"Staten Island\"];\n    }\n    // Default to Manhattan if not found\n    return locationCoordinates[\"Manhattan\"];\n};\n// Helper function to calculate distance between two coordinates\nconst calculateDistance = (lat1, lng1, lat2, lng2)=>{\n    const R = 3958.8; // Earth radius in miles\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c;\n    return distance;\n};\n// Define the route colors for different modes\nconst getRouteColor = (mode)=>{\n    switch(mode){\n        case \"subway\":\n            return \"#3b82f6\"; // blue-500\n        case \"bus\":\n            return \"#22c55e\"; // green-500\n        case \"walk\":\n            return \"#6b7280\"; // gray-500\n        case \"bike\":\n        case \"ebike\":\n            return \"#8b5cf6\"; // purple-500\n        case \"ferry\":\n            return \"#06b6d4\"; // cyan-500\n        case \"taxi\":\n        case \"uber\":\n            return \"#f59e0b\"; // amber-500\n        default:\n            return \"#ef4444\"; // red-500\n    }\n};\nasync function handler(req, res) {\n    if (req.method !== \"GET\") {\n        return res.status(405).json({\n            message: \"Method Not Allowed\"\n        });\n    }\n    const { from, to, priority, noise, safety, bags, wheelchair } = req.query;\n    if (!from || !to) {\n        return res.status(400).json({\n            message: \"Origin and destination are required\"\n        });\n    }\n    try {\n        // In a real app, we would use geocoding to get coordinates\n        const fromCoords = getCoordinates(from);\n        const toCoords = getCoordinates(to);\n        // Log the coordinates for debugging\n        console.log(`From location: \"${from}\" → coordinates: [${fromCoords[0]}, ${fromCoords[1]}]`);\n        console.log(`To location: \"${to}\" → coordinates: [${toCoords[0]}, ${toCoords[1]}]`);\n        // Get user preferences\n        const userPriority = priority || \"balanced\";\n        const userNoise = noise || \"moderate\";\n        const userSafety = safety || \"moderate\";\n        const userBags = parseInt(bags || \"0\", 10);\n        const requireWheelchair = wheelchair === \"true\";\n        // Calculate distance\n        const distance = calculateDistance(fromCoords[0], fromCoords[1], toCoords[0], toCoords[1]);\n        // Get real-time transit data\n        const subwayStatus = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.transitAPI.getSubwayStatus();\n        // Determine available subway lines based on location\n        const subwayLinesByLocation = {\n            \"Manhattan\": [\n                \"1\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"A\",\n                \"C\",\n                \"E\",\n                \"B\",\n                \"D\",\n                \"F\",\n                \"M\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"W\",\n                \"L\"\n            ],\n            \"Brooklyn\": [\n                \"A\",\n                \"C\",\n                \"G\",\n                \"J\",\n                \"Z\",\n                \"L\",\n                \"M\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\"\n            ],\n            \"Queens\": [\n                \"E\",\n                \"F\",\n                \"M\",\n                \"R\",\n                \"N\",\n                \"W\",\n                \"G\",\n                \"7\"\n            ],\n            \"Bronx\": [\n                \"1\",\n                \"2\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"B\",\n                \"D\"\n            ],\n            \"Staten Island\": [\n                \"SIR\"\n            ],\n            \"Flushing\": [\n                \"7\"\n            ],\n            \"Main St\": [\n                \"7\"\n            ],\n            \"Times Square\": [\n                \"1\",\n                \"2\",\n                \"3\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"W\",\n                \"7\",\n                \"S\"\n            ],\n            \"Central Park\": [\n                \"A\",\n                \"B\",\n                \"C\",\n                \"D\",\n                \"1\"\n            ],\n            \"Yankee Stadium\": [\n                \"4\",\n                \"B\",\n                \"D\"\n            ],\n            \"JFK Airport\": [\n                \"A\",\n                \"E\"\n            ],\n            \"LaGuardia Airport\": [],\n            \"Prospect Park\": [\n                \"B\",\n                \"Q\",\n                \"S\"\n            ]\n        };\n        // Determine from and to areas to check subway availability\n        const fromArea = Object.keys(locationCoordinates).find((area)=>from.toLowerCase().includes(area.toLowerCase())) || \"Manhattan\";\n        const toArea = Object.keys(locationCoordinates).find((area)=>to.toLowerCase().includes(area.toLowerCase())) || \"Manhattan\";\n        // Check available subway lines for the route\n        const fromSubwayLines = subwayLinesByLocation[fromArea] || [];\n        const toSubwayLines = subwayLinesByLocation[toArea] || [];\n        // Find common subway lines or lines that can get you there with a transfer\n        let availableSubwayLines = fromSubwayLines.filter((line)=>toSubwayLines.includes(line));\n        // If no direct lines, consider options with transfers\n        const hasTransferOptions = fromSubwayLines.length > 0 && toSubwayLines.length > 0;\n        // Check subway status to see if the lines are operating normally\n        const operatingSubwayLines = availableSubwayLines.filter((line)=>{\n            const lineStatus = subwayStatus.find((s)=>s.line === line);\n            return lineStatus && lineStatus.status === \"normal\";\n        });\n        // Filter to just get one operating line if available\n        const bestSubwayLine = operatingSubwayLines.length > 0 ? operatingSubwayLines[0] : null;\n        // Get all the bus routes for both areas\n        const fromBoroughPrefix = fromArea.charAt(0).toUpperCase();\n        const toBoroughPrefix = toArea.charAt(0).toUpperCase();\n        const busRoutesFrom = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.transitAPI.getBusRoutes(fromArea);\n        // Map specific neighborhoods to appropriate bus routes\n        const busRoutesByArea = {\n            \"Manhattan\": [\n                \"M1\",\n                \"M2\",\n                \"M3\",\n                \"M4\",\n                \"M5\",\n                \"M15\",\n                \"M31\",\n                \"M42\",\n                \"M60\"\n            ],\n            \"Brooklyn\": [\n                \"B41\",\n                \"B42\",\n                \"B44\",\n                \"B46\",\n                \"B67\",\n                \"B68\",\n                \"B69\"\n            ],\n            \"Queens\": [\n                \"Q58\",\n                \"Q59\",\n                \"Q60\",\n                \"Q65\",\n                \"Q66\",\n                \"Q44\",\n                \"Q46\"\n            ],\n            \"Bronx\": [\n                \"BX1\",\n                \"BX2\",\n                \"BX9\",\n                \"BX10\",\n                \"BX12\",\n                \"BX22\"\n            ],\n            \"Staten Island\": [\n                \"S40\",\n                \"S44\",\n                \"S46\",\n                \"S48\",\n                \"S51\",\n                \"S53\"\n            ],\n            \"Flushing\": [\n                \"Q65\",\n                \"Q66\",\n                \"Q17\",\n                \"Q27\",\n                \"Q44\"\n            ],\n            \"Bayside\": [\n                \"Q27\",\n                \"Q31\",\n                \"Q76\",\n                \"Q13\"\n            ],\n            \"Times Square\": [\n                \"M42\",\n                \"M104\",\n                \"Q104\"\n            ],\n            \"JFK Airport\": [\n                \"Q3\",\n                \"Q10\",\n                \"B15\"\n            ],\n            \"LaGuardia Airport\": [\n                \"Q70\",\n                \"M60\"\n            ]\n        };\n        // Get specific bus routes for origin and destination\n        const specificFromBuses = busRoutesByArea[fromArea] || [];\n        const specificToBuses = busRoutesByArea[toArea] || [];\n        // Find bus routes that might connect the two areas\n        let connectingBuses = specificFromBuses.filter((bus)=>specificToBuses.includes(bus));\n        // Check if origin and destination are in different boroughs\n        const originBorough = fromArea === \"Manhattan\" || fromArea === \"Times Square\" || fromArea === \"Central Park\" ? \"Manhattan\" : fromArea === \"Brooklyn\" || fromArea === \"Prospect Park\" ? \"Brooklyn\" : fromArea === \"Queens\" || fromArea === \"Flushing\" || fromArea === \"Bayside\" || fromArea === \"JFK Airport\" ? \"Queens\" : fromArea === \"Bronx\" || fromArea === \"Yankee Stadium\" ? \"Bronx\" : fromArea === \"Staten Island\" ? \"Staten Island\" : \"Manhattan\";\n        const destinationBorough = toArea === \"Manhattan\" || toArea === \"Times Square\" || toArea === \"Central Park\" ? \"Manhattan\" : toArea === \"Brooklyn\" || toArea === \"Prospect Park\" ? \"Brooklyn\" : toArea === \"Queens\" || toArea === \"Flushing\" || toArea === \"Bayside\" || toArea === \"JFK Airport\" ? \"Queens\" : toArea === \"Bronx\" || toArea === \"Yankee Stadium\" ? \"Bronx\" : toArea === \"Staten Island\" ? \"Staten Island\" : \"Manhattan\";\n        // Check if this is a cross-borough trip requiring transfers\n        const isCrossBoroughTrip = originBorough !== destinationBorough;\n        // Express Bus routes for cross-borough travel\n        const expressBusRoutes = {\n            \"Queens-Manhattan\": [\n                \"QM1\",\n                \"QM5\",\n                \"QM7\",\n                \"QM8\"\n            ],\n            \"Brooklyn-Manhattan\": [\n                \"BM1\",\n                \"BM2\",\n                \"BM3\",\n                \"BM4\"\n            ],\n            \"Bronx-Manhattan\": [\n                \"BxM1\",\n                \"BxM2\",\n                \"BxM3\",\n                \"BxM4\"\n            ],\n            \"Staten Island-Manhattan\": [\n                \"SIM1\",\n                \"SIM3\",\n                \"SIM4\",\n                \"SIM5\"\n            ]\n        };\n        // Get appropriate express bus if this is cross-borough\n        let expressBusRoute = \"\";\n        if (isCrossBoroughTrip) {\n            const routeKey = `${originBorough}-${destinationBorough}`;\n            const reverseRouteKey = `${destinationBorough}-${originBorough}`;\n            if (expressBusRoutes[routeKey]) {\n                expressBusRoute = expressBusRoutes[routeKey][0];\n            } else if (expressBusRoutes[reverseRouteKey]) {\n                expressBusRoute = expressBusRoutes[reverseRouteKey][0];\n            }\n        }\n        // If no direct connection, pick a bus from origin for local trips only\n        // For cross-borough trips without express buses, we'll rely on subway instead\n        if (connectingBuses.length === 0 && specificFromBuses.length > 0 && !isCrossBoroughTrip) {\n            connectingBuses = [\n                specificFromBuses[0]\n            ];\n        }\n        // Default to a borough-specific bus if nothing else is available\n        const busRoute = connectingBuses.length > 0 ? connectingBuses[0] : expressBusRoute || `${fromBoroughPrefix}${Math.floor(Math.random() * 50) + 1}`;\n        // Get traffic conditions for origin and destination areas\n        const originTraffic = trafficConditions[originBorough] || {\n            level: \"medium\",\n            factor: 1.25\n        };\n        const destinationTraffic = trafficConditions[destinationBorough] || {\n            level: \"medium\",\n            factor: 1.25\n        };\n        // Get topology difficulty for each area\n        const originTopology = topologyDifficulty[originBorough] || 0.2;\n        const destinationTopology = topologyDifficulty[destinationBorough] || 0.2;\n        // Calculate average traffic and topology difficulty\n        const avgTrafficFactor = (originTraffic.factor + destinationTraffic.factor) / 2;\n        const avgTopologyDifficulty = (originTopology + destinationTopology) / 2;\n        // Routes generation logic\n        const generateRoutes = ()=>{\n            const routes = [];\n            // Calculate a balanced score to determine which route should be \"Best Overall\"\n            const calculateBalancedScore = (duration, cost, comfort, numTransfers, hasBags, isHilly, trafficImpact, isWheelchairAccessible)=>{\n                // Base comfort score from comfort level\n                let comfortScore = comfort === \"high\" ? 0.9 : comfort === \"medium\" ? 0.6 : 0.3;\n                // Adjust comfort for number of bags\n                if (userBags > 0) {\n                    // Each bag reduces comfort, especially for walking/biking\n                    comfortScore = Math.max(0.1, comfortScore - userBags * 0.1);\n                }\n                // Adjust comfort for topology if route involves walking or biking\n                if (isHilly) {\n                    comfortScore = Math.max(0.1, comfortScore - avgTopologyDifficulty);\n                }\n                // Normalize time and cost on a scale where lower is better\n                // Traffic factor increases duration for road-based transport\n                const adjustedDuration = duration * trafficImpact;\n                const timeScore = Math.max(0, 1 - adjustedDuration / 120); // Assume 120 mins is worst case\n                const costScore = Math.max(0, 1 - cost / 30); // Assume $30 is worst case\n                // Transfer penalty\n                const transferScore = Math.max(0, 1 - numTransfers * 0.15);\n                // Adjust weights based on user priority\n                let timeWeight = 0.70; // Significantly increased base time weight\n                let costWeight = 0.15;\n                let comfortWeight = 0.10;\n                let transferWeight = 0.05;\n                switch(userPriority){\n                    case \"speed\":\n                        timeWeight = 0.85; // Even more emphasis on time\n                        costWeight = 0.08;\n                        comfortWeight = 0.04;\n                        transferWeight = 0.03;\n                        break;\n                    case \"cost\":\n                        timeWeight = 0.60; // Still maintain high time priority\n                        costWeight = 0.25;\n                        comfortWeight = 0.10;\n                        transferWeight = 0.05;\n                        break;\n                    case \"comfort\":\n                        timeWeight = 0.60; // Still maintain high time priority\n                        costWeight = 0.15;\n                        comfortWeight = 0.20;\n                        transferWeight = 0.05;\n                        break;\n                    default:\n                        break;\n                }\n                // Further adjust comfort weight based on noise sensitivity\n                if (userNoise === \"high\") {\n                    // Reduce the comfort weight adjustment to maintain time priority\n                    comfortWeight += 0.05;\n                    // And reduce other weights proportionally, taking more from cost than time\n                    timeWeight -= 0.02;\n                    costWeight -= 0.02;\n                    transferWeight -= 0.01;\n                }\n                // Adjust for safety preference\n                if (userSafety === \"high\") {\n                    // Minimal adjustments to maintain time priority\n                    transferWeight += 0.03;\n                    comfortWeight += 0.02;\n                    timeWeight -= 0.02;\n                    costWeight -= 0.03;\n                }\n                // Add wheelchair accessibility factor if needed\n                let accessibilityPenalty = 0;\n                if (requireWheelchair && !isWheelchairAccessible) {\n                    // Significantly penalize non-accessible routes when wheelchair is required\n                    accessibilityPenalty = 0.5;\n                }\n                const rawScore = (timeScore * timeWeight + costScore * costWeight + comfortScore * comfortWeight + transferScore * transferWeight) * (1 - accessibilityPenalty);\n                // Convert to 1-10 scale\n                return {\n                    raw: rawScore,\n                    score: Math.round(rawScore * 10),\n                    timeScore: Math.round(timeScore * 10),\n                    costScore: Math.round(costScore * 10),\n                    comfortScore: Math.round(comfortScore * 10),\n                    transferScore: Math.round(transferScore * 10)\n                };\n            };\n            // Function to generate route color based on score\n            const getRouteColorFromScore = (score)=>{\n                // Color gradient from red (1) to yellow (5) to green (10)\n                if (score <= 3) return \"#ef4444\"; // red-500\n                if (score <= 5) return \"#f59e0b\"; // amber-500\n                if (score <= 7) return \"#facc15\"; // yellow-400\n                if (score <= 9) return \"#65a30d\"; // lime-600\n                return \"#16a34a\"; // green-600\n            };\n            // Reference the outer getRouteColor function or redefine it here\n            const getRouteColorForMode = (mode)=>{\n                return getRouteColor(mode);\n            };\n            // 0. Best Overall route\n            const bestOverallRoute = {\n                id: \"0\",\n                name: \"Best Overall Route\",\n                duration: 0,\n                cost: 0,\n                comfort: \"medium\",\n                vectorScore: 0.95,\n                segments: [],\n                // Additional detailed information\n                hasTopologyImpact: false,\n                numTransfers: 0,\n                traffic: {\n                    level: \"medium\",\n                    impact: 1.0\n                },\n                eta: \"\",\n                costBreakdown: {\n                    fare: 0,\n                    additionalFees: 0,\n                    totalCost: 0\n                },\n                scores: {\n                    overall: 0,\n                    time: 0,\n                    cost: 0,\n                    comfort: 0,\n                    transfers: 0\n                },\n                routeColor: \"\",\n                pathData: []\n            };\n            // Helper to calculate ETA\n            const calculateETA = (durationMinutes)=>{\n                const now = new Date();\n                const eta = new Date(now.getTime() + durationMinutes * 60000);\n                return eta.toLocaleTimeString([], {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\"\n                });\n            };\n            // Generate path data for map visualization\n            const generatePathData = (route)=>{\n                const pathData = [];\n                let lastCoords = fromCoords;\n                route.segments.forEach((segment, index)=>{\n                    const isLastSegment = index === route.segments.length - 1;\n                    const endCoords = isLastSegment ? toCoords : getCoordinates(segment.endLocation);\n                    // For different transport modes, generate different path types\n                    switch(segment.mode){\n                        case \"subway\":\n                            // Subway routes should follow mostly straight lines with slight curves\n                            pathData.push({\n                                type: \"subway\",\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    // Add a midpoint with slight offset for a natural curve\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.5 + (Math.random() - 0.5) * 0.01,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.5 + (Math.random() - 0.5) * 0.01\n                                    ],\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        case \"bus\":\n                            // Bus routes should follow a more zigzag street-like pattern\n                            const numPoints = Math.ceil(calculateDistance(lastCoords[0], lastCoords[1], endCoords[0], endCoords[1]) * 2);\n                            const points = [\n                                lastCoords\n                            ];\n                            // Generate points that zigzag like city streets\n                            let currentPoint = [\n                                ...lastCoords\n                            ];\n                            for(let i = 0; i < numPoints; i++){\n                                // Alternate between horizontal and vertical movement\n                                if (i % 2 === 0) {\n                                    currentPoint = [\n                                        currentPoint[0],\n                                        currentPoint[1] + (endCoords[1] - currentPoint[1]) * 0.3\n                                    ];\n                                } else {\n                                    currentPoint = [\n                                        currentPoint[0] + (endCoords[0] - currentPoint[0]) * 0.3,\n                                        currentPoint[1]\n                                    ];\n                                }\n                                points.push(currentPoint);\n                            }\n                            points.push(endCoords);\n                            pathData.push({\n                                type: \"bus\",\n                                color: getRouteColorForMode(segment.mode),\n                                points\n                            });\n                            break;\n                        case \"walk\":\n                            // Walking should be a relatively direct path\n                            pathData.push({\n                                type: \"walk\",\n                                color: getRouteColorForMode(segment.mode),\n                                dashArray: \"4,4\",\n                                points: [\n                                    lastCoords,\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        case \"uber\":\n                        case \"taxi\":\n                            // Car routes follow streets but more direct than buses\n                            pathData.push({\n                                type: segment.mode,\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.33,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.66\n                                    ],\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.66,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.33\n                                    ],\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        case \"ebike\":\n                            // Bike routes should follow streets but might take shortcuts\n                            pathData.push({\n                                type: \"ebike\",\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.5 + (Math.random() - 0.5) * 0.005,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.5 + (Math.random() - 0.5) * 0.005\n                                    ],\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        default:\n                            // Default direct line\n                            pathData.push({\n                                type: segment.mode,\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    endCoords\n                                ]\n                            });\n                    }\n                    lastCoords = endCoords;\n                });\n                return pathData;\n            };\n            // Process a completed route with all detailed information\n            const finalizeRoute = (route)=>{\n                // Count transfers (segments that change mode of transportation)\n                const numTransfers = route.segments.length > 0 ? route.segments.length - 1 : 0;\n                // Check if route has walking/biking components to consider topology\n                const hasTopologyImpact = route.segments.some((segment)=>segment.mode === \"walk\" || segment.mode === \"ebike\");\n                // Calculate traffic impact for road-based segments\n                const roadBasedSegments = route.segments.filter((segment)=>segment.mode === \"bus\" || segment.mode === \"uber\" || segment.mode === \"taxi\");\n                const trafficImpact = roadBasedSegments.length > 0 ? avgTrafficFactor : 1.0;\n                // Determine wheelchair accessibility\n                const isWheelchairAccessible = route.segments.every((segment)=>{\n                    if (segment.mode === \"walk\") return true; // Walking is always accessible\n                    if (segment.mode === \"subway\") {\n                        // Check if the specific station is accessible - in a real app this would check actual station data\n                        // For now we'll estimate that 40% of subway segments are wheelchair accessible\n                        return segment.hasOwnProperty(\"wheelchairAccessible\") ? segment.wheelchairAccessible : Math.random() > 0.6;\n                    }\n                    if (segment.mode === \"bus\") {\n                        // Most buses are accessible\n                        return segment.hasOwnProperty(\"wheelchairAccessible\") ? segment.wheelchairAccessible : Math.random() > 0.2;\n                    }\n                    if (segment.mode === \"uber\" || segment.mode === \"taxi\") {\n                        // Some taxis/ubers are wheelchair accessible\n                        return segment.hasOwnProperty(\"wheelchairAccessible\") ? segment.wheelchairAccessible : Math.random() > 0.7;\n                    }\n                    return false;\n                });\n                // Calculate cost breakdown\n                const costBreakdown = {\n                    fare: route.segments.reduce((total, segment)=>{\n                        // Only count positive costs (e.g., exclude free transfers)\n                        return total + (segment.cost > 0 ? segment.cost : 0);\n                    }, 0),\n                    additionalFees: 0,\n                    totalCost: route.cost\n                };\n                // Add fees for Uber/Taxi during high traffic\n                if (roadBasedSegments.length > 0 && trafficImpact > 1.2) {\n                    costBreakdown.additionalFees = parseFloat((costBreakdown.fare * 0.15).toFixed(2));\n                    costBreakdown.totalCost = parseFloat((costBreakdown.fare + costBreakdown.additionalFees).toFixed(2));\n                }\n                // Calculate route scores\n                const scores = calculateBalancedScore(route.duration, costBreakdown.totalCost, route.comfort, numTransfers, userBags > 0, hasTopologyImpact, trafficImpact, isWheelchairAccessible);\n                // Calculate ETA\n                const eta = calculateETA(Math.round(route.duration * trafficImpact));\n                // Generate route color based on overall score\n                const routeColor = getRouteColorFromScore(scores.score);\n                // Generate path data for map\n                const pathData = generatePathData(route);\n                // Add detailed information to route\n                route.numTransfers = numTransfers;\n                route.hasTopologyImpact = hasTopologyImpact;\n                route.traffic = {\n                    level: trafficImpact > 1.3 ? \"high\" : trafficImpact > 1.1 ? \"medium\" : \"low\",\n                    impact: trafficImpact\n                };\n                route.eta = eta;\n                route.costBreakdown = costBreakdown;\n                route.scores = scores;\n                route.routeColor = routeColor;\n                route.pathData = pathData;\n                route.isWheelchairAccessible = isWheelchairAccessible;\n                // Enhance segments with scores\n                route.segments.forEach((segment)=>{\n                    // Score each segment based on mode and conditions\n                    const segmentScore = segment.mode === \"walk\" && hasTopologyImpact ? Math.max(3, 7 - Math.floor(avgTopologyDifficulty * 10)) : segment.mode === \"ebike\" && hasTopologyImpact ? Math.max(2, 6 - Math.floor(avgTopologyDifficulty * 10)) : segment.mode === \"bus\" || segment.mode === \"uber\" || segment.mode === \"taxi\" ? Math.max(2, 9 - Math.floor((trafficImpact - 1) * 10)) : 7; // Default reasonable score\n                    segment.score = segmentScore;\n                    segment.adjustedDuration = segment.mode === \"walk\" && hasTopologyImpact ? Math.round(segment.duration * (1 + avgTopologyDifficulty)) : segment.mode === \"bus\" || segment.mode === \"uber\" || segment.mode === \"taxi\" ? Math.round(segment.duration * trafficImpact) : segment.duration; // No adjustment for subway\n                });\n                return route;\n            };\n            // Decide on the best overall route based on distance\n            if (distance < 1) {\n                // Very short distance - walking might be best\n                bestOverallRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: from,\n                    endLocation: to,\n                    duration: Math.round(distance * 20),\n                    cost: 0,\n                    lineInfo: \"Walk to destination\"\n                });\n                bestOverallRoute.duration = Math.round(distance * 20);\n                bestOverallRoute.comfort = \"high\";\n            } else if (distance < 5 && (bestSubwayLine || connectingBuses.length > 0)) {\n                // Medium distance with transit options\n                // First segment - walk to station\n                bestOverallRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: from,\n                    endLocation: bestSubwayLine ? `Subway Station near ${from}` : `Bus Stop near ${from}`,\n                    duration: 5,\n                    cost: 0,\n                    lineInfo: `Walk to ${bestSubwayLine ? \"station\" : \"bus stop\"}`\n                });\n                // Second segment - transit\n                if (bestSubwayLine) {\n                    bestOverallRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Subway Station near ${from}`,\n                        endLocation: `Subway Station near ${to}`,\n                        duration: Math.round(distance * 8),\n                        cost: 2.75,\n                        lineInfo: `${bestSubwayLine} Train${bestSubwayLine === \"7\" ? \" (Flushing Line)\" : \"\"}`\n                    });\n                } else {\n                    bestOverallRoute.segments.push({\n                        mode: \"bus\",\n                        startLocation: `Bus Stop near ${from}`,\n                        endLocation: `Bus Stop near ${to}`,\n                        duration: Math.round(distance * 10),\n                        cost: 2.75,\n                        lineInfo: `${busRoute} Bus`\n                    });\n                }\n                // Last segment - walk to destination\n                bestOverallRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: bestSubwayLine ? `Subway Station near ${to}` : `Bus Stop near ${to}`,\n                    endLocation: to,\n                    duration: 5,\n                    cost: 0,\n                    lineInfo: \"Walk to destination\"\n                });\n                bestOverallRoute.duration = bestSubwayLine ? Math.round(distance * 8) + 10 // Subway time + walking\n                 : Math.round(distance * 10) + 10; // Bus time + walking\n                bestOverallRoute.cost = 2.75;\n                bestOverallRoute.comfort = bestSubwayLine ? \"medium\" : \"low\";\n            } else {\n                // Longer distance or no good transit - mixed mode might be best\n                // Start with transit if available for most of the route\n                if (bestSubwayLine || hasTransferOptions) {\n                    bestOverallRoute.segments.push({\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Subway Station near ${from}`,\n                        duration: 5,\n                        cost: 0,\n                        lineInfo: \"Walk to station\"\n                    });\n                    if (bestSubwayLine) {\n                        bestOverallRoute.segments.push({\n                            mode: \"subway\",\n                            startLocation: `Subway Station near ${from}`,\n                            endLocation: `Subway Station near ${to}`,\n                            duration: Math.round(distance * 7),\n                            cost: 2.75,\n                            lineInfo: `${bestSubwayLine} Train${bestSubwayLine === \"7\" ? \" (Flushing Line)\" : \"\"}`\n                        });\n                    } else {\n                        // Use transfer if needed\n                        const fromLine = fromSubwayLines[0];\n                        const toLine = toSubwayLines[0];\n                        bestOverallRoute.segments.push({\n                            mode: \"subway\",\n                            startLocation: `Subway Station near ${from}`,\n                            endLocation: \"Transfer Station\",\n                            duration: Math.round(distance * 4),\n                            cost: 2.75,\n                            lineInfo: `${fromLine} Train`\n                        });\n                        bestOverallRoute.segments.push({\n                            mode: \"subway\",\n                            startLocation: \"Transfer Station\",\n                            endLocation: `Subway Station near ${to}`,\n                            duration: Math.round(distance * 4),\n                            cost: 0,\n                            lineInfo: `${toLine} Train`\n                        });\n                    }\n                    // For longer distances, use Uber for the last mile\n                    if (distance > 8) {\n                        bestOverallRoute.segments.push({\n                            mode: \"uber\",\n                            startLocation: `Subway Station near ${to}`,\n                            endLocation: to,\n                            duration: 8,\n                            cost: 7.50,\n                            lineInfo: \"UberX (last mile)\"\n                        });\n                        bestOverallRoute.duration = Math.round(distance * 6) + 13; // Transit + uber + initial walk\n                        bestOverallRoute.cost = 10.25; // Subway + uber\n                        bestOverallRoute.comfort = \"high\";\n                    } else {\n                        bestOverallRoute.segments.push({\n                            mode: \"walk\",\n                            startLocation: `Subway Station near ${to}`,\n                            endLocation: to,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to destination\"\n                        });\n                        bestOverallRoute.duration = bestSubwayLine ? Math.round(distance * 7) + 10 // Subway time + walking\n                         : Math.round(distance * 8) + 10; // Transfer subway time + walking\n                        bestOverallRoute.cost = 2.75;\n                        bestOverallRoute.comfort = \"medium\";\n                    }\n                } else {\n                    // No good transit option - use Uber for efficiency\n                    bestOverallRoute.segments.push({\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Pickup Point near ${from}`,\n                        duration: 3,\n                        cost: 0,\n                        lineInfo: \"Walk to pickup point\"\n                    });\n                    bestOverallRoute.segments.push({\n                        mode: \"uber\",\n                        startLocation: `Pickup Point near ${from}`,\n                        endLocation: to,\n                        duration: Math.round(distance * 8),\n                        cost: parseFloat((distance * 2.25).toFixed(2)),\n                        lineInfo: \"UberX\"\n                    });\n                    bestOverallRoute.duration = Math.round(distance * 8) + 3;\n                    bestOverallRoute.cost = parseFloat((distance * 2.25).toFixed(2));\n                    bestOverallRoute.comfort = \"high\";\n                }\n            }\n            routes.push(bestOverallRoute);\n            // 1. If subway is available, create a subway route\n            if (bestSubwayLine || hasTransferOptions) {\n                const subwayRoute = {\n                    id: routes.length + \"\",\n                    name: \"Fastest Route\",\n                    duration: Math.round(distance * 10),\n                    cost: parseFloat((2.75 + (distance > 5 ? 3 : 0)).toFixed(2)),\n                    comfort: distance < 8 ? \"medium\" : \"low\",\n                    vectorScore: 0.89,\n                    segments: [\n                        {\n                            mode: \"walk\",\n                            startLocation: from,\n                            endLocation: `Subway Station near ${from}`,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: `Walk to station`\n                        }\n                    ]\n                };\n                // Add the subway segment(s)\n                if (bestSubwayLine) {\n                    // Direct subway line\n                    subwayRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Subway Station near ${from}`,\n                        endLocation: `Subway Station near ${to}`,\n                        duration: Math.round(distance * 8),\n                        cost: 2.75,\n                        lineInfo: `${bestSubwayLine} Train${bestSubwayLine === \"7\" ? \" (Flushing Line)\" : \"\"}`\n                    });\n                } else if (hasTransferOptions) {\n                    // Need a transfer\n                    const fromLine = fromSubwayLines[0];\n                    const toLine = toSubwayLines[0];\n                    subwayRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Subway Station near ${from}`,\n                        endLocation: `Transfer Station`,\n                        duration: Math.round(distance * 4),\n                        cost: 2.75,\n                        lineInfo: `${fromLine} Train`\n                    });\n                    subwayRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Transfer Station`,\n                        endLocation: `Subway Station near ${to}`,\n                        duration: Math.round(distance * 4),\n                        cost: 0,\n                        lineInfo: `${toLine} Train`\n                    });\n                }\n                // Add the final walking segment\n                subwayRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: `Subway Station near ${to}`,\n                    endLocation: to,\n                    duration: 7,\n                    cost: 0,\n                    lineInfo: `Walk to destination`\n                });\n                routes.push(subwayRoute);\n            }\n            // 2. Always create a ride-sharing route as an option\n            const uberRoute = {\n                id: routes.length + \"\",\n                name: \"Most Comfortable Route\",\n                duration: Math.round(distance * 12),\n                cost: parseFloat((distance * 2.5).toFixed(2)),\n                comfort: \"high\",\n                vectorScore: 0.78,\n                segments: [\n                    {\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Pickup Point near ${from}`,\n                        duration: 3,\n                        cost: 0,\n                        lineInfo: \"Walk to pickup point\"\n                    },\n                    {\n                        mode: \"uber\",\n                        startLocation: `Pickup Point near ${from}`,\n                        endLocation: `Drop-off near ${to}`,\n                        duration: Math.round(distance * 10),\n                        cost: parseFloat((distance * 2.5).toFixed(2)),\n                        lineInfo: \"UberX\"\n                    },\n                    {\n                        mode: \"walk\",\n                        startLocation: `Drop-off near ${to}`,\n                        endLocation: to,\n                        duration: 4,\n                        cost: 0,\n                        lineInfo: \"Walk to destination\"\n                    }\n                ]\n            };\n            routes.push(uberRoute);\n            // Add a taxi route option\n            const taxiRoute = {\n                id: routes.length + \"\",\n                name: \"Taxi Route\",\n                duration: Math.round(distance * 11),\n                cost: parseFloat((distance * 2.8).toFixed(2)),\n                comfort: \"high\",\n                vectorScore: 0.77,\n                segments: [\n                    {\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Taxi Stand near ${from}`,\n                        duration: 4,\n                        cost: 0,\n                        lineInfo: \"Walk to taxi stand\"\n                    },\n                    {\n                        mode: \"taxi\",\n                        startLocation: `Taxi Stand near ${from}`,\n                        endLocation: to,\n                        duration: Math.round(distance * 9),\n                        cost: parseFloat((distance * 2.8).toFixed(2)),\n                        lineInfo: \"NYC Taxi\"\n                    }\n                ]\n            };\n            routes.push(taxiRoute);\n            // Add an E-bike route option if the distance is under 10 miles\n            if (distance < 10) {\n                const ebikeRoute = {\n                    id: routes.length + \"\",\n                    name: \"E-Bike Route\",\n                    duration: Math.round(distance * 15),\n                    cost: 5.00,\n                    comfort: \"medium\",\n                    vectorScore: 0.72,\n                    segments: [\n                        {\n                            mode: \"walk\",\n                            startLocation: from,\n                            endLocation: `E-Bike Station near ${from}`,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to e-bike station\"\n                        },\n                        {\n                            mode: \"ebike\",\n                            startLocation: `E-Bike Station near ${from}`,\n                            endLocation: `E-Bike Station near ${to}`,\n                            duration: Math.round(distance * 12),\n                            cost: 5.00,\n                            lineInfo: \"Citi Bike E-Bike\"\n                        },\n                        {\n                            mode: \"walk\",\n                            startLocation: `E-Bike Station near ${to}`,\n                            endLocation: to,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to destination\"\n                        }\n                    ]\n                };\n                routes.push(ebikeRoute);\n            }\n            // 3. Try to create a bus route if available\n            if (busRoutesFrom.length > 0) {\n                // Use the connecting bus or an area-specific bus route\n                const busOption = {\n                    id: routes.length + \"\",\n                    name: \"Cheapest Route\",\n                    duration: Math.round(distance * 15),\n                    cost: 2.75,\n                    comfort: \"low\",\n                    vectorScore: 0.71,\n                    segments: []\n                };\n                // First walk segment\n                busOption.segments.push({\n                    mode: \"walk\",\n                    startLocation: from,\n                    endLocation: `Bus Stop near ${from}`,\n                    duration: 7,\n                    cost: 0,\n                    lineInfo: \"Walk to bus stop\"\n                });\n                // Cross-borough trips generally need subway or express bus\n                if (isCrossBoroughTrip) {\n                    if (expressBusRoute) {\n                        // Express bus option for cross-borough\n                        busOption.segments.push({\n                            mode: \"bus\",\n                            startLocation: `Bus Stop near ${from}`,\n                            endLocation: `Bus Stop near ${to}`,\n                            duration: Math.round(distance * 10),\n                            cost: 6.75,\n                            lineInfo: `${expressBusRoute} Express Bus`\n                        });\n                        busOption.cost = 6.75;\n                        busOption.name = \"Express Bus Route\";\n                        busOption.comfort = \"medium\";\n                    } else if (fromSubwayLines.length > 0 && toSubwayLines.length > 0) {\n                        // Use a combination of local bus and subway for cross-borough\n                        busOption.segments.push({\n                            mode: \"bus\",\n                            startLocation: `Bus Stop near ${from}`,\n                            endLocation: `${originBorough} Subway Station`,\n                            duration: 10,\n                            cost: 2.75,\n                            lineInfo: `${specificFromBuses[0]} Bus to subway`\n                        });\n                        // Add subway transfer\n                        busOption.segments.push({\n                            mode: \"subway\",\n                            startLocation: `${originBorough} Subway Station`,\n                            endLocation: `${destinationBorough} Subway Station`,\n                            duration: Math.round(distance * 7),\n                            cost: 0,\n                            lineInfo: `${fromSubwayLines[0]} Train`\n                        });\n                        busOption.name = \"Bus + Subway Route\";\n                    } else {\n                        // Fallback to just showing subway if it exists\n                        return routes;\n                    }\n                } else {\n                    // Local bus for same-borough trips\n                    busOption.segments.push({\n                        mode: \"bus\",\n                        startLocation: `Bus Stop near ${from}`,\n                        endLocation: `Bus Stop near ${to}`,\n                        duration: Math.round(distance * 12),\n                        cost: 2.75,\n                        lineInfo: `${busRoute} Bus`\n                    });\n                }\n                // Final walk segment\n                busOption.segments.push({\n                    mode: \"walk\",\n                    startLocation: `Bus Stop near ${to}`,\n                    endLocation: to,\n                    duration: 8,\n                    cost: 0,\n                    lineInfo: \"Walk to destination\"\n                });\n                // Update duration based on segments\n                busOption.duration = busOption.segments.reduce((total, segment)=>total + segment.duration, 0);\n                routes.push(busOption);\n            } else if (!bestSubwayLine && !hasTransferOptions) {\n                // 4. If no subway or bus is available, add a bike option\n                const bikeOption = {\n                    id: routes.length + \"\",\n                    name: \"Eco-Friendly Route\",\n                    duration: Math.round(distance * 18),\n                    cost: 3.50,\n                    comfort: \"medium\",\n                    vectorScore: 0.65,\n                    segments: [\n                        {\n                            mode: \"walk\",\n                            startLocation: from,\n                            endLocation: `Citi Bike Station near ${from}`,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to bike station\"\n                        },\n                        {\n                            mode: \"ebike\",\n                            startLocation: `Citi Bike Station near ${from}`,\n                            endLocation: `Citi Bike Station near ${to}`,\n                            duration: Math.round(distance * 15),\n                            cost: 3.50,\n                            lineInfo: \"Citi Bike\"\n                        },\n                        {\n                            mode: \"walk\",\n                            startLocation: `Citi Bike Station near ${to}`,\n                            endLocation: to,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to destination\"\n                        }\n                    ]\n                };\n                routes.push(bikeOption);\n            }\n            // Sort routes by balanced score\n            routes.forEach((route)=>{\n                route.balancedScore = calculateBalancedScore(route.duration, route.cost, route.comfort, 0, false, false, 1, true);\n            });\n            const mockRoutes = routes.map(finalizeRoute);\n            // Always ensure we have at least 3 routes\n            if (mockRoutes.length < 3) {\n                // Generate more diverse route options if needed\n                if (mockRoutes.length === 1) {\n                    // Add a slower but cheaper option\n                    const cheapestRoute = {\n                        id: \"98\",\n                        name: \"Economy Option\",\n                        duration: Math.round(distance * 18),\n                        cost: 2.75,\n                        comfort: \"low\",\n                        vectorScore: 0.65,\n                        segments: [\n                            {\n                                mode: \"walk\",\n                                startLocation: from,\n                                endLocation: `Bus Stop near ${from}`,\n                                duration: 10,\n                                cost: 0,\n                                lineInfo: \"Walk to bus stop\"\n                            },\n                            {\n                                mode: \"bus\",\n                                startLocation: `Bus Stop near ${from}`,\n                                endLocation: `Bus Stop near ${to}`,\n                                duration: Math.round(distance * 14),\n                                cost: 2.75,\n                                lineInfo: `Local Bus Route`\n                            },\n                            {\n                                mode: \"walk\",\n                                startLocation: `Bus Stop near ${to}`,\n                                endLocation: to,\n                                duration: 10,\n                                cost: 0,\n                                lineInfo: \"Walk to destination\"\n                            }\n                        ]\n                    };\n                    mockRoutes.push(finalizeRoute(cheapestRoute));\n                    // Add a faster but expensive option\n                    const fastestRoute = {\n                        id: \"99\",\n                        name: \"Premium Express\",\n                        duration: Math.round(distance * 8),\n                        cost: parseFloat((distance * 2.5).toFixed(2)),\n                        comfort: \"high\",\n                        vectorScore: 0.75,\n                        segments: [\n                            {\n                                mode: \"walk\",\n                                startLocation: from,\n                                endLocation: `Pickup near ${from}`,\n                                duration: 3,\n                                cost: 0,\n                                lineInfo: \"Walk to pickup point\"\n                            },\n                            {\n                                mode: \"uber\",\n                                startLocation: `Pickup near ${from}`,\n                                endLocation: to,\n                                duration: Math.round(distance * 7),\n                                cost: parseFloat((distance * 2.5).toFixed(2)),\n                                lineInfo: \"UberX Direct\"\n                            }\n                        ]\n                    };\n                    mockRoutes.push(finalizeRoute(fastestRoute));\n                }\n            }\n            // Filter routes based on wheelchair accessibility if required\n            let filteredRoutes = mockRoutes;\n            if (requireWheelchair) {\n                filteredRoutes = mockRoutes.filter((route)=>route.isWheelchairAccessible);\n                // If no accessible routes are found, generate at least one\n                if (filteredRoutes.length === 0) {\n                    const accessibleRoute = {\n                        id: \"99\",\n                        name: \"Wheelchair Accessible Route\",\n                        duration: Math.round(distance * 10),\n                        cost: parseFloat((distance * 2.8).toFixed(2)),\n                        comfort: \"high\",\n                        vectorScore: 0.7,\n                        segments: [\n                            {\n                                mode: \"walk\",\n                                startLocation: from,\n                                endLocation: `Accessible Pickup near ${from}`,\n                                duration: 5,\n                                cost: 0,\n                                lineInfo: \"Short accessible walk to pickup\",\n                                wheelchairAccessible: true\n                            },\n                            {\n                                mode: \"taxi\",\n                                startLocation: `Pickup near ${from}`,\n                                endLocation: to,\n                                duration: Math.round(distance * 9),\n                                cost: parseFloat((distance * 2.8).toFixed(2)),\n                                lineInfo: \"Wheelchair accessible taxi\",\n                                wheelchairAccessible: true\n                            }\n                        ],\n                        isWheelchairAccessible: true\n                    };\n                    filteredRoutes.push(finalizeRoute(accessibleRoute));\n                }\n            }\n            return filteredRoutes;\n        };\n        const routes = generateRoutes();\n        // Ensure we always provide at least 6 routes\n        if (routes.length < 6) {\n            // If we have fewer than 6 routes, create alternative versions with minor variations\n            const existingRoutesCount = routes.length;\n            for(let i = existingRoutesCount; i < 6; i++){\n                // Clone a route with slight modifications\n                const baseRoute = routes[i % existingRoutesCount];\n                const variationFactor = 0.05 + Math.random() * 0.15; // 5% to 20% variation\n                // Create a variation of the route\n                const variation = {\n                    ...JSON.parse(JSON.stringify(baseRoute)),\n                    id: `${baseRoute.id}-var${i}`,\n                    name: `Alternative Route ${i + 1}`,\n                    duration: Math.round(baseRoute.duration * (1 + (Math.random() > 0.5 ? variationFactor : -variationFactor))),\n                    cost: Math.round(baseRoute.cost * (1 + (Math.random() > 0.5 ? variationFactor : -variationFactor)) * 100) / 100,\n                    vectorScore: baseRoute.vectorScore * (1 - variationFactor * 0.5)\n                };\n                // Adjust segments slightly\n                if (variation.segments && variation.segments.length > 0) {\n                    variation.segments = variation.segments.map((segment)=>{\n                        // Small variations in durations and costs\n                        return {\n                            ...segment,\n                            duration: Math.max(1, Math.round(segment.duration * (1 + (Math.random() * 0.1 - 0.05)))),\n                            cost: Math.max(0, Math.round(segment.cost * (1 + (Math.random() * 0.1 - 0.05)) * 100) / 100)\n                        };\n                    });\n                    // Occasionally swap a segment for a different mode if possible\n                    if (variation.segments.length > 1 && Math.random() > 0.7) {\n                        const segmentToChange = Math.floor(Math.random() * variation.segments.length);\n                        const currentMode = variation.segments[segmentToChange].mode;\n                        // Choose a different mode\n                        const availableModes = [\n                            \"subway\",\n                            \"bus\",\n                            \"walk\",\n                            \"bike\",\n                            \"ebike\",\n                            \"taxi\"\n                        ];\n                        const alternativeModes = availableModes.filter((mode)=>mode !== currentMode);\n                        const newMode = alternativeModes[Math.floor(Math.random() * alternativeModes.length)];\n                        variation.segments[segmentToChange].mode = newMode;\n                        variation.segments[segmentToChange].color = getRouteColor(newMode);\n                    }\n                }\n                // Add the variation to the routes array\n                routes.push(variation);\n            }\n        }\n        return res.status(200).json({\n            routes: routes.slice(0, 6),\n            distance,\n            fromCoords,\n            toCoords,\n            subwayAvailable: bestSubwayLine !== null || hasTransferOptions,\n            transferRequired: !bestSubwayLine && hasTransferOptions,\n            traffic: {\n                origin: originTraffic,\n                destination: destinationTraffic,\n                average: avgTrafficFactor\n            },\n            topology: {\n                origin: originTopology,\n                destination: destinationTopology,\n                average: avgTopologyDifficulty\n            }\n        });\n    } catch (error) {\n        console.error(\"Error calculating routes:\", error);\n        return res.status(500).json({\n            message: \"Error calculating routes\"\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBSyxHQUFHMUksY0FBY3dMO29CQUM1RDtnQkFDRjtnQkFFQSx3Q0FBd0M7Z0JBQ3hDOUcsT0FBTzhELElBQUksQ0FBQ3dDO1lBQ2Q7UUFDRjtRQUVBLE9BQU81SyxJQUFJRSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQzFCbUUsUUFBUUEsT0FBTytHLEtBQUssQ0FBQyxHQUFHO1lBQ3hCMUw7WUFDQWtCO1lBQ0FDO1lBQ0F3SyxpQkFBaUI3SSxtQkFBbUIsUUFBUUw7WUFDNUNtSixrQkFBa0IsQ0FBQzlJLGtCQUFrQkw7WUFDckNrRSxTQUFTO2dCQUNQa0YsUUFBUXpIO2dCQUNSMEgsYUFBYXpIO2dCQUNiMEgsU0FBU3ZIO1lBQ1g7WUFDQXdILFVBQVU7Z0JBQ1JILFFBQVF2SDtnQkFDUndILGFBQWF2SDtnQkFDYndILFNBQVN0SDtZQUNYO1FBQ0Y7SUFDRixFQUFFLE9BQU93SCxPQUFPO1FBQ2Q3SyxRQUFRNkssS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0MsT0FBTzVMLElBQUlFLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7WUFBRUMsU0FBUztRQUEyQjtJQUNwRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWJlZWxpbmUvLi9zcmMvcGFnZXMvYXBpL3JvdXRlcy50cz9mMTRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gJ25leHQnO1xuaW1wb3J0IHsgdHJhbnNpdEFQSSB9IGZyb20gJ0AvbGliL2FwaSc7XG5pbXBvcnQgeyB0cmFuc3BvcnRNb2RlcywgZmluZE9wdGltYWxSb3V0ZXMgfSBmcm9tICdAL3V0aWxzL3ZlY3RvckNhbGN1bGF0aW9uJztcblxuLy8gTW9jayBjb29yZGluYXRlcyBmb3Igc29tZSBOWUMgbG9jYXRpb25zXG5jb25zdCBsb2NhdGlvbkNvb3JkaW5hdGVzOiBSZWNvcmQ8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdPiA9IHtcbiAgJ01hbmhhdHRhbic6IFs0MC43ODMxLCAtNzMuOTcxMl0sXG4gICdCcm9va2x5bic6IFs0MC42NzgyLCAtNzMuOTQ0Ml0sXG4gICdRdWVlbnMnOiBbNDAuNzI4MiwgLTczLjc5NDldLFxuICAnQnJvbngnOiBbNDAuODQ0OCwgLTczLjg2NDhdLFxuICAnU3RhdGVuIElzbGFuZCc6IFs0MC41Nzk1LCAtNzQuMTUwMl0sXG4gICdUaW1lcyBTcXVhcmUnOiBbNDAuNzU4MCwgLTczLjk4NTVdLFxuICAnQ2VudHJhbCBQYXJrJzogWzQwLjc4MjksIC03My45NjU0XSxcbiAgJ1Byb3NwZWN0IFBhcmsnOiBbNDAuNjYwMiwgLTczLjk2OTBdLFxuICAnRmx1c2hpbmcgTWVhZG93cyc6IFs0MC43NDY2LCAtNzMuODQyMl0sXG4gICdGbHVzaGluZyc6IFs0MC43NjU0LCAtNzMuODMxOF0sXG4gICdCYXlzaWRlJzogWzQwLjc2MTIsIC03My43NzE2XSxcbiAgJ01haW4gU3QnOiBbNDAuNzU5MCwgLTczLjgzMDBdLFxuICAnWWFua2VlIFN0YWRpdW0nOiBbNDAuODI5NiwgLTczLjkyNjJdLFxufTtcblxuLy8gVHJhZmZpYyBkYXRhIG1vY2sgKGluIGEgcmVhbCBhcHAgdGhpcyB3b3VsZCBiZSByZWFsLXRpbWUgZGF0YSlcbmNvbnN0IHRyYWZmaWNDb25kaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCB7IGxldmVsOiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnLCBmYWN0b3I6IG51bWJlciB9PiA9IHtcbiAgJ01hbmhhdHRhbic6IHsgbGV2ZWw6ICdoaWdoJywgZmFjdG9yOiAxLjUgfSxcbiAgJ0Jyb29rbHluJzogeyBsZXZlbDogJ21lZGl1bScsIGZhY3RvcjogMS4zIH0sXG4gICdRdWVlbnMnOiB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjIgfSxcbiAgJ0Jyb254JzogeyBsZXZlbDogJ21lZGl1bScsIGZhY3RvcjogMS4yNSB9LFxuICAnU3RhdGVuIElzbGFuZCc6IHsgbGV2ZWw6ICdsb3cnLCBmYWN0b3I6IDEuMSB9LFxuICAnRmx1c2hpbmcnOiB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjIgfSxcbiAgJ0JheXNpZGUnOiB7IGxldmVsOiAnbG93JywgZmFjdG9yOiAxLjEgfSxcbiAgJ1RpbWVzIFNxdWFyZSc6IHsgbGV2ZWw6ICdoaWdoJywgZmFjdG9yOiAxLjYgfSxcbiAgJ0NlbnRyYWwgUGFyayc6IHsgbGV2ZWw6ICdtZWRpdW0nLCBmYWN0b3I6IDEuMyB9LFxufTtcblxuLy8gVG9wb2xvZ3kgZGF0YSAtIGVsZXZhdGlvbiBjaGFuZ2VzIHRoYXQgYWZmZWN0IHdhbGtpbmcvYmlraW5nIGNvbWZvcnRcbmNvbnN0IHRvcG9sb2d5RGlmZmljdWx0eTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgJ01hbmhhdHRhbic6IDAuMiwgLy8gU29tZSBoaWxsc1xuICAnQnJvb2tseW4nOiAwLjEsIC8vIE1vc3RseSBmbGF0XG4gICdRdWVlbnMnOiAwLjEsIC8vIE1vc3RseSBmbGF0XG4gICdCcm9ueCc6IDAuNCwgLy8gSGlsbHlcbiAgJ1N0YXRlbiBJc2xhbmQnOiAwLjUsIC8vIFZlcnkgaGlsbHlcbiAgJ0ZsdXNoaW5nJzogMC4xLCAvLyBNb3N0bHkgZmxhdFxuICAnQmF5c2lkZSc6IDAuMiwgLy8gU29tZSBoaWxsc1xuICAnVGltZXMgU3F1YXJlJzogMC4xLCAvLyBGbGF0XG4gICdDZW50cmFsIFBhcmsnOiAwLjMsIC8vIFJvbGxpbmcgaGlsbHNcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgY29vcmRpbmF0ZXMgZnJvbSBhIGxvY2F0aW9uIHN0cmluZ1xuY29uc3QgZ2V0Q29vcmRpbmF0ZXMgPSAobG9jYXRpb246IHN0cmluZyk6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xuICAvLyBOb3JtYWxpemUgdGhlIGxvY2F0aW9uIHN0cmluZyBmb3IgYmV0dGVyIG1hdGNoaW5nXG4gIGNvbnN0IG5vcm1hbGl6ZWRMb2NhdGlvbiA9IGxvY2F0aW9uLnRvTG93ZXJDYXNlKCk7XG4gIFxuICAvLyBGaXJzdCB0cnkgZXhhY3QgbWF0Y2hlcyBmb3Igc3BlY2lmaWMgbmVpZ2hib3Job29kcy9sb2NhdGlvbnNcbiAgZm9yIChjb25zdCBbbmFtZSwgY29vcmRzXSBvZiBPYmplY3QuZW50cmllcyhsb2NhdGlvbkNvb3JkaW5hdGVzKSkge1xuICAgIGlmIChub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9XG4gIH1cbiAgXG4gIC8vIElmIG5vIHNwZWNpZmljIG1hdGNoLCB0cnkgdG8gZGV0ZXJtaW5lIHdoaWNoIGJvcm91Z2ggaXQncyBpblxuICBpZiAobm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKCdxdWVlbnMnKSB8fCBcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnZmx1c2hpbmcnKSB8fCBcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnYmF5c2lkZScpIHx8XG4gICAgICBub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMoJ2phbWFpY2EnKSB8fFxuICAgICAgbm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKCdhc3RvcmlhJykpIHtcbiAgICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snUXVlZW5zJ107XG4gIH1cbiAgXG4gIGlmIChub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMoJ2Jyb29rbHluJykgfHxcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnd2lsbGlhbXNidXJnJykgfHxcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygncGFyayBzbG9wZScpKSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uQ29vcmRpbmF0ZXNbJ0Jyb29rbHluJ107XG4gIH1cbiAgXG4gIGlmIChub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMoJ2Jyb254JykpIHtcbiAgICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snQnJvbngnXTtcbiAgfVxuICBcbiAgaWYgKG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnc3RhdGVuJykpIHtcbiAgICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snU3RhdGVuIElzbGFuZCddO1xuICB9XG4gIFxuICAvLyBEZWZhdWx0IHRvIE1hbmhhdHRhbiBpZiBub3QgZm91bmRcbiAgcmV0dXJuIGxvY2F0aW9uQ29vcmRpbmF0ZXNbJ01hbmhhdHRhbiddO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuY29uc3QgY2FsY3VsYXRlRGlzdGFuY2UgPSAoXG4gIGxhdDE6IG51bWJlciwgXG4gIGxuZzE6IG51bWJlciwgXG4gIGxhdDI6IG51bWJlciwgXG4gIGxuZzI6IG51bWJlclxuKTogbnVtYmVyID0+IHtcbiAgY29uc3QgUiA9IDM5NTguODsgLy8gRWFydGggcmFkaXVzIGluIG1pbGVzXG4gIGNvbnN0IGRMYXQgPSAobGF0MiAtIGxhdDEpICogTWF0aC5QSSAvIDE4MDtcbiAgY29uc3QgZExuZyA9IChsbmcyIC0gbG5nMSkgKiBNYXRoLlBJIC8gMTgwO1xuICBjb25zdCBhID1cbiAgICBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xuICAgIE1hdGguY29zKGxhdDEgKiBNYXRoLlBJIC8gMTgwKSAqIE1hdGguY29zKGxhdDIgKiBNYXRoLlBJIC8gMTgwKSAqXG4gICAgTWF0aC5zaW4oZExuZyAvIDIpICogTWF0aC5zaW4oZExuZyAvIDIpO1xuICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcbiAgY29uc3QgZGlzdGFuY2UgPSBSICogYztcbiAgXG4gIHJldHVybiBkaXN0YW5jZTtcbn07XG5cbi8vIERlZmluZSB0aGUgcm91dGUgY29sb3JzIGZvciBkaWZmZXJlbnQgbW9kZXNcbmNvbnN0IGdldFJvdXRlQ29sb3IgPSAobW9kZTogc3RyaW5nKSA9PiB7XG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ3N1YndheSc6XG4gICAgICByZXR1cm4gJyMzYjgyZjYnOyAgLy8gYmx1ZS01MDBcbiAgICBjYXNlICdidXMnOlxuICAgICAgcmV0dXJuICcjMjJjNTVlJzsgIC8vIGdyZWVuLTUwMFxuICAgIGNhc2UgJ3dhbGsnOlxuICAgICAgcmV0dXJuICcjNmI3MjgwJzsgIC8vIGdyYXktNTAwXG4gICAgY2FzZSAnYmlrZSc6XG4gICAgY2FzZSAnZWJpa2UnOlxuICAgICAgcmV0dXJuICcjOGI1Y2Y2JzsgIC8vIHB1cnBsZS01MDBcbiAgICBjYXNlICdmZXJyeSc6XG4gICAgICByZXR1cm4gJyMwNmI2ZDQnOyAgLy8gY3lhbi01MDBcbiAgICBjYXNlICd0YXhpJzpcbiAgICBjYXNlICd1YmVyJzpcbiAgICAgIHJldHVybiAnI2Y1OWUwYic7ICAvLyBhbWJlci01MDBcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcjZWY0NDQ0JzsgIC8vIHJlZC01MDBcbiAgfVxufTtcblxuLy8gRGVmaW5lIHRoZSByb3V0ZSB0eXBlXG5pbnRlcmZhY2UgUm91dGVJdGVtIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICBjb3N0OiBudW1iZXI7XG4gIGNvbWZvcnQ6IHN0cmluZztcbiAgdmVjdG9yU2NvcmU6IG51bWJlcjtcbiAgc2VnbWVudHM6IGFueVtdO1xuICBiYWxhbmNlZFNjb3JlPzoge1xuICAgIHJhdzogbnVtYmVyO1xuICAgIHNjb3JlOiBudW1iZXI7XG4gICAgdGltZVNjb3JlOiBudW1iZXI7XG4gICAgY29zdFNjb3JlOiBudW1iZXI7XG4gICAgY29tZm9ydFNjb3JlOiBudW1iZXI7XG4gICAgdHJhbnNmZXJTY29yZTogbnVtYmVyO1xuICB9O1xuICAvLyBBZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgaGFzVG9wb2xvZ3lJbXBhY3Q/OiBib29sZWFuO1xuICBudW1UcmFuc2ZlcnM/OiBudW1iZXI7XG4gIHRyYWZmaWM/OiB7IGxldmVsOiBzdHJpbmc7IGltcGFjdDogbnVtYmVyIH07XG4gIGV0YT86IHN0cmluZztcbiAgY28yPzogbnVtYmVyO1xuICBpc1doZWVsY2hhaXJBY2Nlc3NpYmxlPzogYm9vbGVhbjtcbiAgc2NvcmVzPzogYW55O1xuICByb3V0ZUNvbG9yPzogc3RyaW5nO1xuICBwYXRoRGF0YT86IGFueVtdO1xuICBjb3N0QnJlYWtkb3duPzogYW55O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZVxuKSB7XG4gIGlmIChyZXEubWV0aG9kICE9PSAnR0VUJykge1xuICAgIHJldHVybiByZXMuc3RhdHVzKDQwNSkuanNvbih7IG1lc3NhZ2U6ICdNZXRob2QgTm90IEFsbG93ZWQnIH0pO1xuICB9XG5cbiAgY29uc3QgeyBmcm9tLCB0bywgcHJpb3JpdHksIG5vaXNlLCBzYWZldHksIGJhZ3MsIHdoZWVsY2hhaXIgfSA9IHJlcS5xdWVyeTtcblxuICBpZiAoIWZyb20gfHwgIXRvKSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgbWVzc2FnZTogJ09yaWdpbiBhbmQgZGVzdGluYXRpb24gYXJlIHJlcXVpcmVkJyB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgd2Ugd291bGQgdXNlIGdlb2NvZGluZyB0byBnZXQgY29vcmRpbmF0ZXNcbiAgICBjb25zdCBmcm9tQ29vcmRzID0gZ2V0Q29vcmRpbmF0ZXMoZnJvbSBhcyBzdHJpbmcpO1xuICAgIGNvbnN0IHRvQ29vcmRzID0gZ2V0Q29vcmRpbmF0ZXModG8gYXMgc3RyaW5nKTtcbiAgICBcbiAgICAvLyBMb2cgdGhlIGNvb3JkaW5hdGVzIGZvciBkZWJ1Z2dpbmdcbiAgICBjb25zb2xlLmxvZyhgRnJvbSBsb2NhdGlvbjogXCIke2Zyb219XCIg4oaSIGNvb3JkaW5hdGVzOiBbJHtmcm9tQ29vcmRzWzBdfSwgJHtmcm9tQ29vcmRzWzFdfV1gKTtcbiAgICBjb25zb2xlLmxvZyhgVG8gbG9jYXRpb246IFwiJHt0b31cIiDihpIgY29vcmRpbmF0ZXM6IFske3RvQ29vcmRzWzBdfSwgJHt0b0Nvb3Jkc1sxXX1dYCk7XG4gICAgXG4gICAgLy8gR2V0IHVzZXIgcHJlZmVyZW5jZXNcbiAgICBjb25zdCB1c2VyUHJpb3JpdHkgPSBwcmlvcml0eSBhcyBzdHJpbmcgfHwgJ2JhbGFuY2VkJztcbiAgICBjb25zdCB1c2VyTm9pc2UgPSBub2lzZSBhcyBzdHJpbmcgfHwgJ21vZGVyYXRlJztcbiAgICBjb25zdCB1c2VyU2FmZXR5ID0gc2FmZXR5IGFzIHN0cmluZyB8fCAnbW9kZXJhdGUnO1xuICAgIGNvbnN0IHVzZXJCYWdzID0gcGFyc2VJbnQoYmFncyBhcyBzdHJpbmcgfHwgJzAnLCAxMCk7XG4gICAgY29uc3QgcmVxdWlyZVdoZWVsY2hhaXIgPSB3aGVlbGNoYWlyID09PSAndHJ1ZSc7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlXG4gICAgY29uc3QgZGlzdGFuY2UgPSBjYWxjdWxhdGVEaXN0YW5jZShcbiAgICAgIGZyb21Db29yZHNbMF0sIGZyb21Db29yZHNbMV0sIFxuICAgICAgdG9Db29yZHNbMF0sIHRvQ29vcmRzWzFdXG4gICAgKTtcblxuICAgIC8vIEdldCByZWFsLXRpbWUgdHJhbnNpdCBkYXRhXG4gICAgY29uc3Qgc3Vid2F5U3RhdHVzID0gYXdhaXQgdHJhbnNpdEFQSS5nZXRTdWJ3YXlTdGF0dXMoKTtcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgYXZhaWxhYmxlIHN1YndheSBsaW5lcyBiYXNlZCBvbiBsb2NhdGlvblxuICAgIGNvbnN0IHN1YndheUxpbmVzQnlMb2NhdGlvbjogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge1xuICAgICAgJ01hbmhhdHRhbic6IFsnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnQScsICdDJywgJ0UnLCAnQicsICdEJywgJ0YnLCAnTScsICdOJywgJ1EnLCAnUicsICdXJywgJ0wnXSxcbiAgICAgICdCcm9va2x5bic6IFsnQScsICdDJywgJ0cnLCAnSicsICdaJywgJ0wnLCAnTScsICdOJywgJ1EnLCAnUicsICcyJywgJzMnLCAnNCcsICc1J10sXG4gICAgICAnUXVlZW5zJzogWydFJywgJ0YnLCAnTScsICdSJywgJ04nLCAnVycsICdHJywgJzcnXSxcbiAgICAgICdCcm9ueCc6IFsnMScsICcyJywgJzQnLCAnNScsICc2JywgJ0InLCAnRCddLFxuICAgICAgJ1N0YXRlbiBJc2xhbmQnOiBbJ1NJUiddLFxuICAgICAgJ0ZsdXNoaW5nJzogWyc3J10sXG4gICAgICAnTWFpbiBTdCc6IFsnNyddLFxuICAgICAgJ1RpbWVzIFNxdWFyZSc6IFsnMScsICcyJywgJzMnLCAnTicsICdRJywgJ1InLCAnVycsICc3JywgJ1MnXSxcbiAgICAgICdDZW50cmFsIFBhcmsnOiBbJ0EnLCAnQicsICdDJywgJ0QnLCAnMSddLFxuICAgICAgJ1lhbmtlZSBTdGFkaXVtJzogWyc0JywgJ0InLCAnRCddLFxuICAgICAgJ0pGSyBBaXJwb3J0JzogWydBJywgJ0UnXSxcbiAgICAgICdMYUd1YXJkaWEgQWlycG9ydCc6IFtdLFxuICAgICAgJ1Byb3NwZWN0IFBhcmsnOiBbJ0InLCAnUScsICdTJ10sXG4gICAgfTtcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgZnJvbSBhbmQgdG8gYXJlYXMgdG8gY2hlY2sgc3Vid2F5IGF2YWlsYWJpbGl0eVxuICAgIGNvbnN0IGZyb21BcmVhID0gT2JqZWN0LmtleXMobG9jYXRpb25Db29yZGluYXRlcykuZmluZChhcmVhID0+IFxuICAgICAgKGZyb20gYXMgc3RyaW5nKS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGFyZWEudG9Mb3dlckNhc2UoKSlcbiAgICApIHx8ICdNYW5oYXR0YW4nO1xuICAgIFxuICAgIGNvbnN0IHRvQXJlYSA9IE9iamVjdC5rZXlzKGxvY2F0aW9uQ29vcmRpbmF0ZXMpLmZpbmQoYXJlYSA9PiBcbiAgICAgICh0byBhcyBzdHJpbmcpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoYXJlYS50b0xvd2VyQ2FzZSgpKVxuICAgICkgfHwgJ01hbmhhdHRhbic7XG4gICAgXG4gICAgLy8gQ2hlY2sgYXZhaWxhYmxlIHN1YndheSBsaW5lcyBmb3IgdGhlIHJvdXRlXG4gICAgY29uc3QgZnJvbVN1YndheUxpbmVzID0gc3Vid2F5TGluZXNCeUxvY2F0aW9uW2Zyb21BcmVhXSB8fCBbXTtcbiAgICBjb25zdCB0b1N1YndheUxpbmVzID0gc3Vid2F5TGluZXNCeUxvY2F0aW9uW3RvQXJlYV0gfHwgW107XG4gICAgXG4gICAgLy8gRmluZCBjb21tb24gc3Vid2F5IGxpbmVzIG9yIGxpbmVzIHRoYXQgY2FuIGdldCB5b3UgdGhlcmUgd2l0aCBhIHRyYW5zZmVyXG4gICAgbGV0IGF2YWlsYWJsZVN1YndheUxpbmVzID0gZnJvbVN1YndheUxpbmVzLmZpbHRlcihsaW5lID0+IHRvU3Vid2F5TGluZXMuaW5jbHVkZXMobGluZSkpO1xuICAgIFxuICAgIC8vIElmIG5vIGRpcmVjdCBsaW5lcywgY29uc2lkZXIgb3B0aW9ucyB3aXRoIHRyYW5zZmVyc1xuICAgIGNvbnN0IGhhc1RyYW5zZmVyT3B0aW9ucyA9IGZyb21TdWJ3YXlMaW5lcy5sZW5ndGggPiAwICYmIHRvU3Vid2F5TGluZXMubGVuZ3RoID4gMDtcbiAgICBcbiAgICAvLyBDaGVjayBzdWJ3YXkgc3RhdHVzIHRvIHNlZSBpZiB0aGUgbGluZXMgYXJlIG9wZXJhdGluZyBub3JtYWxseVxuICAgIGNvbnN0IG9wZXJhdGluZ1N1YndheUxpbmVzID0gYXZhaWxhYmxlU3Vid2F5TGluZXMuZmlsdGVyKGxpbmUgPT4ge1xuICAgICAgY29uc3QgbGluZVN0YXR1cyA9IHN1YndheVN0YXR1cy5maW5kKHMgPT4gcy5saW5lID09PSBsaW5lKTtcbiAgICAgIHJldHVybiBsaW5lU3RhdHVzICYmIGxpbmVTdGF0dXMuc3RhdHVzID09PSAnbm9ybWFsJztcbiAgICB9KTtcbiAgICBcbiAgICAvLyBGaWx0ZXIgdG8ganVzdCBnZXQgb25lIG9wZXJhdGluZyBsaW5lIGlmIGF2YWlsYWJsZVxuICAgIGNvbnN0IGJlc3RTdWJ3YXlMaW5lID0gb3BlcmF0aW5nU3Vid2F5TGluZXMubGVuZ3RoID4gMCA/IG9wZXJhdGluZ1N1YndheUxpbmVzWzBdIDogbnVsbDtcbiAgICBcbiAgICAvLyBHZXQgYWxsIHRoZSBidXMgcm91dGVzIGZvciBib3RoIGFyZWFzXG4gICAgY29uc3QgZnJvbUJvcm91Z2hQcmVmaXggPSBmcm9tQXJlYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCB0b0Jvcm91Z2hQcmVmaXggPSB0b0FyZWEuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgYnVzUm91dGVzRnJvbSA9IGF3YWl0IHRyYW5zaXRBUEkuZ2V0QnVzUm91dGVzKGZyb21BcmVhKTtcbiAgICBcbiAgICAvLyBNYXAgc3BlY2lmaWMgbmVpZ2hib3Job29kcyB0byBhcHByb3ByaWF0ZSBidXMgcm91dGVzXG4gICAgY29uc3QgYnVzUm91dGVzQnlBcmVhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7XG4gICAgICAnTWFuaGF0dGFuJzogWydNMScsICdNMicsICdNMycsICdNNCcsICdNNScsICdNMTUnLCAnTTMxJywgJ000MicsICdNNjAnXSxcbiAgICAgICdCcm9va2x5bic6IFsnQjQxJywgJ0I0MicsICdCNDQnLCAnQjQ2JywgJ0I2NycsICdCNjgnLCAnQjY5J10sXG4gICAgICAnUXVlZW5zJzogWydRNTgnLCAnUTU5JywgJ1E2MCcsICdRNjUnLCAnUTY2JywgJ1E0NCcsICdRNDYnXSxcbiAgICAgICdCcm9ueCc6IFsnQlgxJywgJ0JYMicsICdCWDknLCAnQlgxMCcsICdCWDEyJywgJ0JYMjInXSxcbiAgICAgICdTdGF0ZW4gSXNsYW5kJzogWydTNDAnLCAnUzQ0JywgJ1M0NicsICdTNDgnLCAnUzUxJywgJ1M1MyddLFxuICAgICAgJ0ZsdXNoaW5nJzogWydRNjUnLCAnUTY2JywgJ1ExNycsICdRMjcnLCAnUTQ0J10sXG4gICAgICAnQmF5c2lkZSc6IFsnUTI3JywgJ1EzMScsICdRNzYnLCAnUTEzJ10sXG4gICAgICAnVGltZXMgU3F1YXJlJzogWydNNDInLCAnTTEwNCcsICdRMTA0J10sXG4gICAgICAnSkZLIEFpcnBvcnQnOiBbJ1EzJywgJ1ExMCcsICdCMTUnXSxcbiAgICAgICdMYUd1YXJkaWEgQWlycG9ydCc6IFsnUTcwJywgJ002MCddLFxuICAgIH07XG4gICAgXG4gICAgLy8gR2V0IHNwZWNpZmljIGJ1cyByb3V0ZXMgZm9yIG9yaWdpbiBhbmQgZGVzdGluYXRpb25cbiAgICBjb25zdCBzcGVjaWZpY0Zyb21CdXNlcyA9IGJ1c1JvdXRlc0J5QXJlYVtmcm9tQXJlYV0gfHwgW107XG4gICAgY29uc3Qgc3BlY2lmaWNUb0J1c2VzID0gYnVzUm91dGVzQnlBcmVhW3RvQXJlYV0gfHwgW107XG4gICAgXG4gICAgLy8gRmluZCBidXMgcm91dGVzIHRoYXQgbWlnaHQgY29ubmVjdCB0aGUgdHdvIGFyZWFzXG4gICAgbGV0IGNvbm5lY3RpbmdCdXNlcyA9IHNwZWNpZmljRnJvbUJ1c2VzLmZpbHRlcihidXMgPT4gc3BlY2lmaWNUb0J1c2VzLmluY2x1ZGVzKGJ1cykpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gYXJlIGluIGRpZmZlcmVudCBib3JvdWdoc1xuICAgIGNvbnN0IG9yaWdpbkJvcm91Z2ggPSBcbiAgICAgIGZyb21BcmVhID09PSAnTWFuaGF0dGFuJyB8fCBmcm9tQXJlYSA9PT0gJ1RpbWVzIFNxdWFyZScgfHwgZnJvbUFyZWEgPT09ICdDZW50cmFsIFBhcmsnID8gJ01hbmhhdHRhbicgOlxuICAgICAgZnJvbUFyZWEgPT09ICdCcm9va2x5bicgfHwgZnJvbUFyZWEgPT09ICdQcm9zcGVjdCBQYXJrJyA/ICdCcm9va2x5bicgOlxuICAgICAgZnJvbUFyZWEgPT09ICdRdWVlbnMnIHx8IGZyb21BcmVhID09PSAnRmx1c2hpbmcnIHx8IGZyb21BcmVhID09PSAnQmF5c2lkZScgfHwgZnJvbUFyZWEgPT09ICdKRksgQWlycG9ydCcgPyAnUXVlZW5zJyA6XG4gICAgICBmcm9tQXJlYSA9PT0gJ0Jyb254JyB8fCBmcm9tQXJlYSA9PT0gJ1lhbmtlZSBTdGFkaXVtJyA/ICdCcm9ueCcgOlxuICAgICAgZnJvbUFyZWEgPT09ICdTdGF0ZW4gSXNsYW5kJyA/ICdTdGF0ZW4gSXNsYW5kJyA6ICdNYW5oYXR0YW4nO1xuICAgIFxuICAgIGNvbnN0IGRlc3RpbmF0aW9uQm9yb3VnaCA9IFxuICAgICAgdG9BcmVhID09PSAnTWFuaGF0dGFuJyB8fCB0b0FyZWEgPT09ICdUaW1lcyBTcXVhcmUnIHx8IHRvQXJlYSA9PT0gJ0NlbnRyYWwgUGFyaycgPyAnTWFuaGF0dGFuJyA6XG4gICAgICB0b0FyZWEgPT09ICdCcm9va2x5bicgfHwgdG9BcmVhID09PSAnUHJvc3BlY3QgUGFyaycgPyAnQnJvb2tseW4nIDpcbiAgICAgIHRvQXJlYSA9PT0gJ1F1ZWVucycgfHwgdG9BcmVhID09PSAnRmx1c2hpbmcnIHx8IHRvQXJlYSA9PT0gJ0JheXNpZGUnIHx8IHRvQXJlYSA9PT0gJ0pGSyBBaXJwb3J0JyA/ICdRdWVlbnMnIDpcbiAgICAgIHRvQXJlYSA9PT0gJ0Jyb254JyB8fCB0b0FyZWEgPT09ICdZYW5rZWUgU3RhZGl1bScgPyAnQnJvbngnIDpcbiAgICAgIHRvQXJlYSA9PT0gJ1N0YXRlbiBJc2xhbmQnID8gJ1N0YXRlbiBJc2xhbmQnIDogJ01hbmhhdHRhbic7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGNyb3NzLWJvcm91Z2ggdHJpcCByZXF1aXJpbmcgdHJhbnNmZXJzXG4gICAgY29uc3QgaXNDcm9zc0Jvcm91Z2hUcmlwID0gb3JpZ2luQm9yb3VnaCAhPT0gZGVzdGluYXRpb25Cb3JvdWdoO1xuICAgIFxuICAgIC8vIEV4cHJlc3MgQnVzIHJvdXRlcyBmb3IgY3Jvc3MtYm9yb3VnaCB0cmF2ZWxcbiAgICBjb25zdCBleHByZXNzQnVzUm91dGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7XG4gICAgICAnUXVlZW5zLU1hbmhhdHRhbic6IFsnUU0xJywgJ1FNNScsICdRTTcnLCAnUU04J10sXG4gICAgICAnQnJvb2tseW4tTWFuaGF0dGFuJzogWydCTTEnLCAnQk0yJywgJ0JNMycsICdCTTQnXSxcbiAgICAgICdCcm9ueC1NYW5oYXR0YW4nOiBbJ0J4TTEnLCAnQnhNMicsICdCeE0zJywgJ0J4TTQnXSxcbiAgICAgICdTdGF0ZW4gSXNsYW5kLU1hbmhhdHRhbic6IFsnU0lNMScsICdTSU0zJywgJ1NJTTQnLCAnU0lNNSddLFxuICAgIH07XG4gICAgXG4gICAgLy8gR2V0IGFwcHJvcHJpYXRlIGV4cHJlc3MgYnVzIGlmIHRoaXMgaXMgY3Jvc3MtYm9yb3VnaFxuICAgIGxldCBleHByZXNzQnVzUm91dGUgPSAnJztcbiAgICBpZiAoaXNDcm9zc0Jvcm91Z2hUcmlwKSB7XG4gICAgICBjb25zdCByb3V0ZUtleSA9IGAke29yaWdpbkJvcm91Z2h9LSR7ZGVzdGluYXRpb25Cb3JvdWdofWA7XG4gICAgICBjb25zdCByZXZlcnNlUm91dGVLZXkgPSBgJHtkZXN0aW5hdGlvbkJvcm91Z2h9LSR7b3JpZ2luQm9yb3VnaH1gO1xuICAgICAgXG4gICAgICBpZiAoZXhwcmVzc0J1c1JvdXRlc1tyb3V0ZUtleV0pIHtcbiAgICAgICAgZXhwcmVzc0J1c1JvdXRlID0gZXhwcmVzc0J1c1JvdXRlc1tyb3V0ZUtleV1bMF07XG4gICAgICB9IGVsc2UgaWYgKGV4cHJlc3NCdXNSb3V0ZXNbcmV2ZXJzZVJvdXRlS2V5XSkge1xuICAgICAgICBleHByZXNzQnVzUm91dGUgPSBleHByZXNzQnVzUm91dGVzW3JldmVyc2VSb3V0ZUtleV1bMF07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIElmIG5vIGRpcmVjdCBjb25uZWN0aW9uLCBwaWNrIGEgYnVzIGZyb20gb3JpZ2luIGZvciBsb2NhbCB0cmlwcyBvbmx5XG4gICAgLy8gRm9yIGNyb3NzLWJvcm91Z2ggdHJpcHMgd2l0aG91dCBleHByZXNzIGJ1c2VzLCB3ZSdsbCByZWx5IG9uIHN1YndheSBpbnN0ZWFkXG4gICAgaWYgKGNvbm5lY3RpbmdCdXNlcy5sZW5ndGggPT09IDAgJiYgc3BlY2lmaWNGcm9tQnVzZXMubGVuZ3RoID4gMCAmJiAhaXNDcm9zc0Jvcm91Z2hUcmlwKSB7XG4gICAgICBjb25uZWN0aW5nQnVzZXMgPSBbc3BlY2lmaWNGcm9tQnVzZXNbMF1dO1xuICAgIH1cbiAgICBcbiAgICAvLyBEZWZhdWx0IHRvIGEgYm9yb3VnaC1zcGVjaWZpYyBidXMgaWYgbm90aGluZyBlbHNlIGlzIGF2YWlsYWJsZVxuICAgIGNvbnN0IGJ1c1JvdXRlID0gY29ubmVjdGluZ0J1c2VzLmxlbmd0aCA+IDAgXG4gICAgICA/IGNvbm5lY3RpbmdCdXNlc1swXSBcbiAgICAgIDogKGV4cHJlc3NCdXNSb3V0ZSB8fCBgJHtmcm9tQm9yb3VnaFByZWZpeH0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwKSArIDF9YCk7XG4gICAgXG4gICAgLy8gR2V0IHRyYWZmaWMgY29uZGl0aW9ucyBmb3Igb3JpZ2luIGFuZCBkZXN0aW5hdGlvbiBhcmVhc1xuICAgIGNvbnN0IG9yaWdpblRyYWZmaWMgPSB0cmFmZmljQ29uZGl0aW9uc1tvcmlnaW5Cb3JvdWdoXSB8fCB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjI1IH07XG4gICAgY29uc3QgZGVzdGluYXRpb25UcmFmZmljID0gdHJhZmZpY0NvbmRpdGlvbnNbZGVzdGluYXRpb25Cb3JvdWdoXSB8fCB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjI1IH07XG4gICAgXG4gICAgLy8gR2V0IHRvcG9sb2d5IGRpZmZpY3VsdHkgZm9yIGVhY2ggYXJlYVxuICAgIGNvbnN0IG9yaWdpblRvcG9sb2d5ID0gdG9wb2xvZ3lEaWZmaWN1bHR5W29yaWdpbkJvcm91Z2hdIHx8IDAuMjtcbiAgICBjb25zdCBkZXN0aW5hdGlvblRvcG9sb2d5ID0gdG9wb2xvZ3lEaWZmaWN1bHR5W2Rlc3RpbmF0aW9uQm9yb3VnaF0gfHwgMC4yO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIHRyYWZmaWMgYW5kIHRvcG9sb2d5IGRpZmZpY3VsdHlcbiAgICBjb25zdCBhdmdUcmFmZmljRmFjdG9yID0gKG9yaWdpblRyYWZmaWMuZmFjdG9yICsgZGVzdGluYXRpb25UcmFmZmljLmZhY3RvcikgLyAyO1xuICAgIGNvbnN0IGF2Z1RvcG9sb2d5RGlmZmljdWx0eSA9IChvcmlnaW5Ub3BvbG9neSArIGRlc3RpbmF0aW9uVG9wb2xvZ3kpIC8gMjtcbiAgICBcbiAgICAvLyBSb3V0ZXMgZ2VuZXJhdGlvbiBsb2dpY1xuICAgIGNvbnN0IGdlbmVyYXRlUm91dGVzID0gKCkgPT4ge1xuICAgICAgY29uc3Qgcm91dGVzOiBSb3V0ZUl0ZW1bXSA9IFtdO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgYSBiYWxhbmNlZCBzY29yZSB0byBkZXRlcm1pbmUgd2hpY2ggcm91dGUgc2hvdWxkIGJlIFwiQmVzdCBPdmVyYWxsXCJcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZUJhbGFuY2VkU2NvcmUgPSAoZHVyYXRpb246IG51bWJlciwgY29zdDogbnVtYmVyLCBjb21mb3J0OiBzdHJpbmcsIG51bVRyYW5zZmVyczogbnVtYmVyLCBoYXNCYWdzOiBib29sZWFuLCBpc0hpbGx5OiBib29sZWFuLCB0cmFmZmljSW1wYWN0OiBudW1iZXIsIGlzV2hlZWxjaGFpckFjY2Vzc2libGU6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgLy8gQmFzZSBjb21mb3J0IHNjb3JlIGZyb20gY29tZm9ydCBsZXZlbFxuICAgICAgICBsZXQgY29tZm9ydFNjb3JlID0gY29tZm9ydCA9PT0gJ2hpZ2gnID8gMC45IDogY29tZm9ydCA9PT0gJ21lZGl1bScgPyAwLjYgOiAwLjM7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGp1c3QgY29tZm9ydCBmb3IgbnVtYmVyIG9mIGJhZ3NcbiAgICAgICAgaWYgKHVzZXJCYWdzID4gMCkge1xuICAgICAgICAgIC8vIEVhY2ggYmFnIHJlZHVjZXMgY29tZm9ydCwgZXNwZWNpYWxseSBmb3Igd2Fsa2luZy9iaWtpbmdcbiAgICAgICAgICBjb21mb3J0U2NvcmUgPSBNYXRoLm1heCgwLjEsIGNvbWZvcnRTY29yZSAtICh1c2VyQmFncyAqIDAuMSkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBZGp1c3QgY29tZm9ydCBmb3IgdG9wb2xvZ3kgaWYgcm91dGUgaW52b2x2ZXMgd2Fsa2luZyBvciBiaWtpbmdcbiAgICAgICAgaWYgKGlzSGlsbHkpIHtcbiAgICAgICAgICBjb21mb3J0U2NvcmUgPSBNYXRoLm1heCgwLjEsIGNvbWZvcnRTY29yZSAtIGF2Z1RvcG9sb2d5RGlmZmljdWx0eSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aW1lIGFuZCBjb3N0IG9uIGEgc2NhbGUgd2hlcmUgbG93ZXIgaXMgYmV0dGVyXG4gICAgICAgIC8vIFRyYWZmaWMgZmFjdG9yIGluY3JlYXNlcyBkdXJhdGlvbiBmb3Igcm9hZC1iYXNlZCB0cmFuc3BvcnRcbiAgICAgICAgY29uc3QgYWRqdXN0ZWREdXJhdGlvbiA9IGR1cmF0aW9uICogdHJhZmZpY0ltcGFjdDtcbiAgICAgICAgY29uc3QgdGltZVNjb3JlID0gTWF0aC5tYXgoMCwgMSAtIChhZGp1c3RlZER1cmF0aW9uIC8gMTIwKSk7IC8vIEFzc3VtZSAxMjAgbWlucyBpcyB3b3JzdCBjYXNlXG4gICAgICAgIGNvbnN0IGNvc3RTY29yZSA9IE1hdGgubWF4KDAsIDEgLSAoY29zdCAvIDMwKSk7ICAgICAgLy8gQXNzdW1lICQzMCBpcyB3b3JzdCBjYXNlXG4gICAgICAgIFxuICAgICAgICAvLyBUcmFuc2ZlciBwZW5hbHR5XG4gICAgICAgIGNvbnN0IHRyYW5zZmVyU2NvcmUgPSBNYXRoLm1heCgwLCAxIC0gKG51bVRyYW5zZmVycyAqIDAuMTUpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkanVzdCB3ZWlnaHRzIGJhc2VkIG9uIHVzZXIgcHJpb3JpdHlcbiAgICAgICAgbGV0IHRpbWVXZWlnaHQgPSAwLjcwOyAgLy8gU2lnbmlmaWNhbnRseSBpbmNyZWFzZWQgYmFzZSB0aW1lIHdlaWdodFxuICAgICAgICBsZXQgY29zdFdlaWdodCA9IDAuMTU7XG4gICAgICAgIGxldCBjb21mb3J0V2VpZ2h0ID0gMC4xMDtcbiAgICAgICAgbGV0IHRyYW5zZmVyV2VpZ2h0ID0gMC4wNTtcbiAgICAgICAgXG4gICAgICAgIHN3aXRjaCAodXNlclByaW9yaXR5KSB7XG4gICAgICAgICAgY2FzZSAnc3BlZWQnOlxuICAgICAgICAgICAgdGltZVdlaWdodCA9IDAuODU7ICAgIC8vIEV2ZW4gbW9yZSBlbXBoYXNpcyBvbiB0aW1lXG4gICAgICAgICAgICBjb3N0V2VpZ2h0ID0gMC4wODtcbiAgICAgICAgICAgIGNvbWZvcnRXZWlnaHQgPSAwLjA0O1xuICAgICAgICAgICAgdHJhbnNmZXJXZWlnaHQgPSAwLjAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY29zdCc6XG4gICAgICAgICAgICB0aW1lV2VpZ2h0ID0gMC42MDsgICAgLy8gU3RpbGwgbWFpbnRhaW4gaGlnaCB0aW1lIHByaW9yaXR5XG4gICAgICAgICAgICBjb3N0V2VpZ2h0ID0gMC4yNTtcbiAgICAgICAgICAgIGNvbWZvcnRXZWlnaHQgPSAwLjEwO1xuICAgICAgICAgICAgdHJhbnNmZXJXZWlnaHQgPSAwLjA1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY29tZm9ydCc6XG4gICAgICAgICAgICB0aW1lV2VpZ2h0ID0gMC42MDsgICAgLy8gU3RpbGwgbWFpbnRhaW4gaGlnaCB0aW1lIHByaW9yaXR5XG4gICAgICAgICAgICBjb3N0V2VpZ2h0ID0gMC4xNTtcbiAgICAgICAgICAgIGNvbWZvcnRXZWlnaHQgPSAwLjIwO1xuICAgICAgICAgICAgdHJhbnNmZXJXZWlnaHQgPSAwLjA1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDogLy8gJ2JhbGFuY2VkJ1xuICAgICAgICAgICAgLy8gS2VlcCB0aGUgZGVmYXVsdCB3ZWlnaHRzIGRlZmluZWQgYWJvdmVcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGdXJ0aGVyIGFkanVzdCBjb21mb3J0IHdlaWdodCBiYXNlZCBvbiBub2lzZSBzZW5zaXRpdml0eVxuICAgICAgICBpZiAodXNlck5vaXNlID09PSAnaGlnaCcpIHtcbiAgICAgICAgICAvLyBSZWR1Y2UgdGhlIGNvbWZvcnQgd2VpZ2h0IGFkanVzdG1lbnQgdG8gbWFpbnRhaW4gdGltZSBwcmlvcml0eVxuICAgICAgICAgIGNvbWZvcnRXZWlnaHQgKz0gMC4wNTtcbiAgICAgICAgICAvLyBBbmQgcmVkdWNlIG90aGVyIHdlaWdodHMgcHJvcG9ydGlvbmFsbHksIHRha2luZyBtb3JlIGZyb20gY29zdCB0aGFuIHRpbWVcbiAgICAgICAgICB0aW1lV2VpZ2h0IC09IDAuMDI7XG4gICAgICAgICAgY29zdFdlaWdodCAtPSAwLjAyO1xuICAgICAgICAgIHRyYW5zZmVyV2VpZ2h0IC09IDAuMDE7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkanVzdCBmb3Igc2FmZXR5IHByZWZlcmVuY2VcbiAgICAgICAgaWYgKHVzZXJTYWZldHkgPT09ICdoaWdoJykge1xuICAgICAgICAgIC8vIE1pbmltYWwgYWRqdXN0bWVudHMgdG8gbWFpbnRhaW4gdGltZSBwcmlvcml0eVxuICAgICAgICAgIHRyYW5zZmVyV2VpZ2h0ICs9IDAuMDM7XG4gICAgICAgICAgY29tZm9ydFdlaWdodCArPSAwLjAyO1xuICAgICAgICAgIHRpbWVXZWlnaHQgLT0gMC4wMjtcbiAgICAgICAgICBjb3N0V2VpZ2h0IC09IDAuMDM7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCB3aGVlbGNoYWlyIGFjY2Vzc2liaWxpdHkgZmFjdG9yIGlmIG5lZWRlZFxuICAgICAgICBsZXQgYWNjZXNzaWJpbGl0eVBlbmFsdHkgPSAwO1xuICAgICAgICBpZiAocmVxdWlyZVdoZWVsY2hhaXIgJiYgIWlzV2hlZWxjaGFpckFjY2Vzc2libGUpIHtcbiAgICAgICAgICAvLyBTaWduaWZpY2FudGx5IHBlbmFsaXplIG5vbi1hY2Nlc3NpYmxlIHJvdXRlcyB3aGVuIHdoZWVsY2hhaXIgaXMgcmVxdWlyZWRcbiAgICAgICAgICBhY2Nlc3NpYmlsaXR5UGVuYWx0eSA9IDAuNTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgcmF3U2NvcmUgPSAoKHRpbWVTY29yZSAqIHRpbWVXZWlnaHQpICsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChjb3N0U2NvcmUgKiBjb3N0V2VpZ2h0KSArIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoY29tZm9ydFNjb3JlICogY29tZm9ydFdlaWdodCkgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKHRyYW5zZmVyU2NvcmUgKiB0cmFuc2ZlcldlaWdodCkpICogXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgxIC0gYWNjZXNzaWJpbGl0eVBlbmFsdHkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCB0byAxLTEwIHNjYWxlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmF3OiByYXdTY29yZSxcbiAgICAgICAgICBzY29yZTogTWF0aC5yb3VuZChyYXdTY29yZSAqIDEwKSxcbiAgICAgICAgICB0aW1lU2NvcmU6IE1hdGgucm91bmQodGltZVNjb3JlICogMTApLFxuICAgICAgICAgIGNvc3RTY29yZTogTWF0aC5yb3VuZChjb3N0U2NvcmUgKiAxMCksXG4gICAgICAgICAgY29tZm9ydFNjb3JlOiBNYXRoLnJvdW5kKGNvbWZvcnRTY29yZSAqIDEwKSxcbiAgICAgICAgICB0cmFuc2ZlclNjb3JlOiBNYXRoLnJvdW5kKHRyYW5zZmVyU2NvcmUgKiAxMClcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEZ1bmN0aW9uIHRvIGdlbmVyYXRlIHJvdXRlIGNvbG9yIGJhc2VkIG9uIHNjb3JlXG4gICAgICBjb25zdCBnZXRSb3V0ZUNvbG9yRnJvbVNjb3JlID0gKHNjb3JlOiBudW1iZXIpID0+IHtcbiAgICAgICAgLy8gQ29sb3IgZ3JhZGllbnQgZnJvbSByZWQgKDEpIHRvIHllbGxvdyAoNSkgdG8gZ3JlZW4gKDEwKVxuICAgICAgICBpZiAoc2NvcmUgPD0gMykgcmV0dXJuICcjZWY0NDQ0JzsgLy8gcmVkLTUwMFxuICAgICAgICBpZiAoc2NvcmUgPD0gNSkgcmV0dXJuICcjZjU5ZTBiJzsgLy8gYW1iZXItNTAwXG4gICAgICAgIGlmIChzY29yZSA8PSA3KSByZXR1cm4gJyNmYWNjMTUnOyAvLyB5ZWxsb3ctNDAwXG4gICAgICAgIGlmIChzY29yZSA8PSA5KSByZXR1cm4gJyM2NWEzMGQnOyAvLyBsaW1lLTYwMFxuICAgICAgICByZXR1cm4gJyMxNmEzNGEnOyAvLyBncmVlbi02MDBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFJlZmVyZW5jZSB0aGUgb3V0ZXIgZ2V0Um91dGVDb2xvciBmdW5jdGlvbiBvciByZWRlZmluZSBpdCBoZXJlXG4gICAgICBjb25zdCBnZXRSb3V0ZUNvbG9yRm9yTW9kZSA9IChtb2RlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIGdldFJvdXRlQ29sb3IobW9kZSk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyAwLiBCZXN0IE92ZXJhbGwgcm91dGVcbiAgICAgIGNvbnN0IGJlc3RPdmVyYWxsUm91dGU6IFJvdXRlSXRlbSA9IHtcbiAgICAgICAgaWQ6ICcwJyxcbiAgICAgICAgbmFtZTogJ0Jlc3QgT3ZlcmFsbCBSb3V0ZScsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICBjb3N0OiAwLFxuICAgICAgICBjb21mb3J0OiAnbWVkaXVtJyBhcyAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnLFxuICAgICAgICB2ZWN0b3JTY29yZTogMC45NSxcbiAgICAgICAgc2VnbWVudHM6IFtdLFxuICAgICAgICAvLyBBZGRpdGlvbmFsIGRldGFpbGVkIGluZm9ybWF0aW9uXG4gICAgICAgIGhhc1RvcG9sb2d5SW1wYWN0OiBmYWxzZSxcbiAgICAgICAgbnVtVHJhbnNmZXJzOiAwLFxuICAgICAgICB0cmFmZmljOiB7IGxldmVsOiAnbWVkaXVtJywgaW1wYWN0OiAxLjAgfSxcbiAgICAgICAgZXRhOiAnJyxcbiAgICAgICAgY29zdEJyZWFrZG93bjogeyBcbiAgICAgICAgICBmYXJlOiAwLCBcbiAgICAgICAgICBhZGRpdGlvbmFsRmVlczogMCxcbiAgICAgICAgICB0b3RhbENvc3Q6IDAgXG4gICAgICAgIH0sXG4gICAgICAgIHNjb3Jlczoge1xuICAgICAgICAgIG92ZXJhbGw6IDAsXG4gICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICBjb3N0OiAwLFxuICAgICAgICAgIGNvbWZvcnQ6IDAsXG4gICAgICAgICAgdHJhbnNmZXJzOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHJvdXRlQ29sb3I6ICcnLFxuICAgICAgICBwYXRoRGF0YTogW11cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEhlbHBlciB0byBjYWxjdWxhdGUgRVRBXG4gICAgICBjb25zdCBjYWxjdWxhdGVFVEEgPSAoZHVyYXRpb25NaW51dGVzOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgZXRhID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIGR1cmF0aW9uTWludXRlcyAqIDYwMDAwKTtcbiAgICAgICAgcmV0dXJuIGV0YS50b0xvY2FsZVRpbWVTdHJpbmcoW10sIHsgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JyB9KTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEdlbmVyYXRlIHBhdGggZGF0YSBmb3IgbWFwIHZpc3VhbGl6YXRpb25cbiAgICAgIGNvbnN0IGdlbmVyYXRlUGF0aERhdGEgPSAocm91dGU6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBwYXRoRGF0YTogYW55W10gPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGxldCBsYXN0Q29vcmRzID0gZnJvbUNvb3JkcztcbiAgICAgICAgcm91dGUuc2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudDogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNMYXN0U2VnbWVudCA9IGluZGV4ID09PSByb3V0ZS5zZWdtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgIGNvbnN0IGVuZENvb3JkcyA9IGlzTGFzdFNlZ21lbnQgPyB0b0Nvb3JkcyA6IGdldENvb3JkaW5hdGVzKHNlZ21lbnQuZW5kTG9jYXRpb24pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBkaWZmZXJlbnQgdHJhbnNwb3J0IG1vZGVzLCBnZW5lcmF0ZSBkaWZmZXJlbnQgcGF0aCB0eXBlc1xuICAgICAgICAgIHN3aXRjaChzZWdtZW50Lm1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N1YndheSc6XG4gICAgICAgICAgICAgIC8vIFN1YndheSByb3V0ZXMgc2hvdWxkIGZvbGxvdyBtb3N0bHkgc3RyYWlnaHQgbGluZXMgd2l0aCBzbGlnaHQgY3VydmVzXG4gICAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdWJ3YXknLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRSb3V0ZUNvbG9yRm9yTW9kZShzZWdtZW50Lm1vZGUpLFxuICAgICAgICAgICAgICAgIHBvaW50czogW1xuICAgICAgICAgICAgICAgICAgbGFzdENvb3JkcyxcbiAgICAgICAgICAgICAgICAgIC8vIEFkZCBhIG1pZHBvaW50IHdpdGggc2xpZ2h0IG9mZnNldCBmb3IgYSBuYXR1cmFsIGN1cnZlXG4gICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHNbMF0gKyAoZW5kQ29vcmRzWzBdIC0gbGFzdENvb3Jkc1swXSkgKiAwLjUgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAxLFxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzWzFdICsgKGVuZENvb3Jkc1sxXSAtIGxhc3RDb29yZHNbMV0pICogMC41ICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4wMVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIGVuZENvb3Jkc1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYnVzJzpcbiAgICAgICAgICAgICAgLy8gQnVzIHJvdXRlcyBzaG91bGQgZm9sbG93IGEgbW9yZSB6aWd6YWcgc3RyZWV0LWxpa2UgcGF0dGVyblxuICAgICAgICAgICAgICBjb25zdCBudW1Qb2ludHMgPSBNYXRoLmNlaWwoY2FsY3VsYXRlRGlzdGFuY2UobGFzdENvb3Jkc1swXSwgbGFzdENvb3Jkc1sxXSwgZW5kQ29vcmRzWzBdLCBlbmRDb29yZHNbMV0pICogMik7XG4gICAgICAgICAgICAgIGNvbnN0IHBvaW50czogW251bWJlciwgbnVtYmVyXVtdID0gW2xhc3RDb29yZHNdO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgcG9pbnRzIHRoYXQgemlnemFnIGxpa2UgY2l0eSBzdHJlZXRzXG4gICAgICAgICAgICAgIGxldCBjdXJyZW50UG9pbnQ6IFtudW1iZXIsIG51bWJlcl0gPSBbLi4ubGFzdENvb3Jkc10gYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIEFsdGVybmF0ZSBiZXR3ZWVuIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIG1vdmVtZW50XG4gICAgICAgICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludFswXSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvaW50WzFdICsgKGVuZENvb3Jkc1sxXSAtIGN1cnJlbnRQb2ludFsxXSkgKiAwLjNcbiAgICAgICAgICAgICAgICAgIF0gYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFBvaW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRbMF0gKyAoZW5kQ29vcmRzWzBdIC0gY3VycmVudFBvaW50WzBdKSAqIDAuMyxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvaW50WzFdXG4gICAgICAgICAgICAgICAgICBdIGFzIFtudW1iZXIsIG51bWJlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN1cnJlbnRQb2ludCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcG9pbnRzLnB1c2goZW5kQ29vcmRzKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdidXMnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRSb3V0ZUNvbG9yRm9yTW9kZShzZWdtZW50Lm1vZGUpLFxuICAgICAgICAgICAgICAgIHBvaW50c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3YWxrJzpcbiAgICAgICAgICAgICAgLy8gV2Fsa2luZyBzaG91bGQgYmUgYSByZWxhdGl2ZWx5IGRpcmVjdCBwYXRoXG4gICAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICd3YWxrJyxcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0Um91dGVDb2xvckZvck1vZGUoc2VnbWVudC5tb2RlKSxcbiAgICAgICAgICAgICAgICBkYXNoQXJyYXk6ICc0LDQnLFxuICAgICAgICAgICAgICAgIHBvaW50czogW1xuICAgICAgICAgICAgICAgICAgbGFzdENvb3JkcyxcbiAgICAgICAgICAgICAgICAgIGVuZENvb3Jkc1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndWJlcic6XG4gICAgICAgICAgICBjYXNlICd0YXhpJzpcbiAgICAgICAgICAgICAgLy8gQ2FyIHJvdXRlcyBmb2xsb3cgc3RyZWV0cyBidXQgbW9yZSBkaXJlY3QgdGhhbiBidXNlc1xuICAgICAgICAgICAgICBwYXRoRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBzZWdtZW50Lm1vZGUsXG4gICAgICAgICAgICAgICAgY29sb3I6IGdldFJvdXRlQ29sb3JGb3JNb2RlKHNlZ21lbnQubW9kZSksXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXG4gICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzLFxuICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzWzBdICsgKGVuZENvb3Jkc1swXSAtIGxhc3RDb29yZHNbMF0pICogMC4zMyxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvb3Jkc1sxXSArIChlbmRDb29yZHNbMV0gLSBsYXN0Q29vcmRzWzFdKSAqIDAuNjZcbiAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHNbMF0gKyAoZW5kQ29vcmRzWzBdIC0gbGFzdENvb3Jkc1swXSkgKiAwLjY2LFxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzWzFdICsgKGVuZENvb3Jkc1sxXSAtIGxhc3RDb29yZHNbMV0pICogMC4zM1xuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIGVuZENvb3Jkc1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZWJpa2UnOlxuICAgICAgICAgICAgICAvLyBCaWtlIHJvdXRlcyBzaG91bGQgZm9sbG93IHN0cmVldHMgYnV0IG1pZ2h0IHRha2Ugc2hvcnRjdXRzXG4gICAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlYmlrZScsXG4gICAgICAgICAgICAgICAgY29sb3I6IGdldFJvdXRlQ29sb3JGb3JNb2RlKHNlZ21lbnQubW9kZSksXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXG4gICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzLFxuICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzWzBdICsgKGVuZENvb3Jkc1swXSAtIGxhc3RDb29yZHNbMF0pICogMC41ICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4wMDUsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHNbMV0gKyAoZW5kQ29vcmRzWzFdIC0gbGFzdENvb3Jkc1sxXSkgKiAwLjUgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAwNVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIGVuZENvb3Jkc1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gRGVmYXVsdCBkaXJlY3QgbGluZVxuICAgICAgICAgICAgICBwYXRoRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBzZWdtZW50Lm1vZGUsXG4gICAgICAgICAgICAgICAgY29sb3I6IGdldFJvdXRlQ29sb3JGb3JNb2RlKHNlZ21lbnQubW9kZSksXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbbGFzdENvb3JkcywgZW5kQ29vcmRzXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgbGFzdENvb3JkcyA9IGVuZENvb3JkcztcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcGF0aERhdGE7XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGEgY29tcGxldGVkIHJvdXRlIHdpdGggYWxsIGRldGFpbGVkIGluZm9ybWF0aW9uXG4gICAgICBjb25zdCBmaW5hbGl6ZVJvdXRlID0gKHJvdXRlOiBhbnkpID0+IHtcbiAgICAgICAgLy8gQ291bnQgdHJhbnNmZXJzIChzZWdtZW50cyB0aGF0IGNoYW5nZSBtb2RlIG9mIHRyYW5zcG9ydGF0aW9uKVxuICAgICAgICBjb25zdCBudW1UcmFuc2ZlcnMgPSByb3V0ZS5zZWdtZW50cy5sZW5ndGggPiAwID8gcm91dGUuc2VnbWVudHMubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiByb3V0ZSBoYXMgd2Fsa2luZy9iaWtpbmcgY29tcG9uZW50cyB0byBjb25zaWRlciB0b3BvbG9neVxuICAgICAgICBjb25zdCBoYXNUb3BvbG9neUltcGFjdCA9IHJvdXRlLnNlZ21lbnRzLnNvbWUoKHNlZ21lbnQ6IGFueSkgPT4gXG4gICAgICAgICAgc2VnbWVudC5tb2RlID09PSAnd2FsaycgfHwgc2VnbWVudC5tb2RlID09PSAnZWJpa2UnXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgdHJhZmZpYyBpbXBhY3QgZm9yIHJvYWQtYmFzZWQgc2VnbWVudHNcbiAgICAgICAgY29uc3Qgcm9hZEJhc2VkU2VnbWVudHMgPSByb3V0ZS5zZWdtZW50cy5maWx0ZXIoKHNlZ21lbnQ6IGFueSkgPT4gXG4gICAgICAgICAgc2VnbWVudC5tb2RlID09PSAnYnVzJyB8fCBzZWdtZW50Lm1vZGUgPT09ICd1YmVyJyB8fCBzZWdtZW50Lm1vZGUgPT09ICd0YXhpJ1xuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdHJhZmZpY0ltcGFjdCA9IHJvYWRCYXNlZFNlZ21lbnRzLmxlbmd0aCA+IDAgPyBhdmdUcmFmZmljRmFjdG9yIDogMS4wO1xuICAgICAgICBcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZWVsY2hhaXIgYWNjZXNzaWJpbGl0eVxuICAgICAgICBjb25zdCBpc1doZWVsY2hhaXJBY2Nlc3NpYmxlID0gcm91dGUuc2VnbWVudHMuZXZlcnkoKHNlZ21lbnQ6IGFueSkgPT4ge1xuICAgICAgICAgIGlmIChzZWdtZW50Lm1vZGUgPT09ICd3YWxrJykgcmV0dXJuIHRydWU7IC8vIFdhbGtpbmcgaXMgYWx3YXlzIGFjY2Vzc2libGVcbiAgICAgICAgICBpZiAoc2VnbWVudC5tb2RlID09PSAnc3Vid2F5Jykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNwZWNpZmljIHN0YXRpb24gaXMgYWNjZXNzaWJsZSAtIGluIGEgcmVhbCBhcHAgdGhpcyB3b3VsZCBjaGVjayBhY3R1YWwgc3RhdGlvbiBkYXRhXG4gICAgICAgICAgICAvLyBGb3Igbm93IHdlJ2xsIGVzdGltYXRlIHRoYXQgNDAlIG9mIHN1YndheSBzZWdtZW50cyBhcmUgd2hlZWxjaGFpciBhY2Nlc3NpYmxlXG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudC5oYXNPd25Qcm9wZXJ0eSgnd2hlZWxjaGFpckFjY2Vzc2libGUnKSA/IHNlZ21lbnQud2hlZWxjaGFpckFjY2Vzc2libGUgOiBNYXRoLnJhbmRvbSgpID4gMC42O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VnbWVudC5tb2RlID09PSAnYnVzJykge1xuICAgICAgICAgICAgLy8gTW9zdCBidXNlcyBhcmUgYWNjZXNzaWJsZVxuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQuaGFzT3duUHJvcGVydHkoJ3doZWVsY2hhaXJBY2Nlc3NpYmxlJykgPyBzZWdtZW50LndoZWVsY2hhaXJBY2Nlc3NpYmxlIDogTWF0aC5yYW5kb20oKSA+IDAuMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlZ21lbnQubW9kZSA9PT0gJ3ViZXInIHx8IHNlZ21lbnQubW9kZSA9PT0gJ3RheGknKSB7XG4gICAgICAgICAgICAvLyBTb21lIHRheGlzL3ViZXJzIGFyZSB3aGVlbGNoYWlyIGFjY2Vzc2libGVcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50Lmhhc093blByb3BlcnR5KCd3aGVlbGNoYWlyQWNjZXNzaWJsZScpID8gc2VnbWVudC53aGVlbGNoYWlyQWNjZXNzaWJsZSA6IE1hdGgucmFuZG9tKCkgPiAwLjc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgY29zdCBicmVha2Rvd25cbiAgICAgICAgY29uc3QgY29zdEJyZWFrZG93biA9IHtcbiAgICAgICAgICBmYXJlOiByb3V0ZS5zZWdtZW50cy5yZWR1Y2UoKHRvdGFsOiBudW1iZXIsIHNlZ21lbnQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBjb3VudCBwb3NpdGl2ZSBjb3N0cyAoZS5nLiwgZXhjbHVkZSBmcmVlIHRyYW5zZmVycylcbiAgICAgICAgICAgIHJldHVybiB0b3RhbCArIChzZWdtZW50LmNvc3QgPiAwID8gc2VnbWVudC5jb3N0IDogMCk7XG4gICAgICAgICAgfSwgMCksXG4gICAgICAgICAgYWRkaXRpb25hbEZlZXM6IDAsXG4gICAgICAgICAgdG90YWxDb3N0OiByb3V0ZS5jb3N0XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgZmVlcyBmb3IgVWJlci9UYXhpIGR1cmluZyBoaWdoIHRyYWZmaWNcbiAgICAgICAgaWYgKHJvYWRCYXNlZFNlZ21lbnRzLmxlbmd0aCA+IDAgJiYgdHJhZmZpY0ltcGFjdCA+IDEuMikge1xuICAgICAgICAgIGNvc3RCcmVha2Rvd24uYWRkaXRpb25hbEZlZXMgPSBwYXJzZUZsb2F0KChjb3N0QnJlYWtkb3duLmZhcmUgKiAwLjE1KS50b0ZpeGVkKDIpKTtcbiAgICAgICAgICBjb3N0QnJlYWtkb3duLnRvdGFsQ29zdCA9IHBhcnNlRmxvYXQoKGNvc3RCcmVha2Rvd24uZmFyZSArIGNvc3RCcmVha2Rvd24uYWRkaXRpb25hbEZlZXMpLnRvRml4ZWQoMikpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgcm91dGUgc2NvcmVzXG4gICAgICAgIGNvbnN0IHNjb3JlcyA9IGNhbGN1bGF0ZUJhbGFuY2VkU2NvcmUoXG4gICAgICAgICAgcm91dGUuZHVyYXRpb24sIFxuICAgICAgICAgIGNvc3RCcmVha2Rvd24udG90YWxDb3N0LCBcbiAgICAgICAgICByb3V0ZS5jb21mb3J0LCBcbiAgICAgICAgICBudW1UcmFuc2ZlcnMsXG4gICAgICAgICAgdXNlckJhZ3MgPiAwLFxuICAgICAgICAgIGhhc1RvcG9sb2d5SW1wYWN0LFxuICAgICAgICAgIHRyYWZmaWNJbXBhY3QsXG4gICAgICAgICAgaXNXaGVlbGNoYWlyQWNjZXNzaWJsZVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIEVUQVxuICAgICAgICBjb25zdCBldGEgPSBjYWxjdWxhdGVFVEEoTWF0aC5yb3VuZChyb3V0ZS5kdXJhdGlvbiAqIHRyYWZmaWNJbXBhY3QpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdlbmVyYXRlIHJvdXRlIGNvbG9yIGJhc2VkIG9uIG92ZXJhbGwgc2NvcmVcbiAgICAgICAgY29uc3Qgcm91dGVDb2xvciA9IGdldFJvdXRlQ29sb3JGcm9tU2NvcmUoc2NvcmVzLnNjb3JlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdlbmVyYXRlIHBhdGggZGF0YSBmb3IgbWFwXG4gICAgICAgIGNvbnN0IHBhdGhEYXRhID0gZ2VuZXJhdGVQYXRoRGF0YShyb3V0ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgZGV0YWlsZWQgaW5mb3JtYXRpb24gdG8gcm91dGVcbiAgICAgICAgcm91dGUubnVtVHJhbnNmZXJzID0gbnVtVHJhbnNmZXJzO1xuICAgICAgICByb3V0ZS5oYXNUb3BvbG9neUltcGFjdCA9IGhhc1RvcG9sb2d5SW1wYWN0O1xuICAgICAgICByb3V0ZS50cmFmZmljID0geyBcbiAgICAgICAgICBsZXZlbDogdHJhZmZpY0ltcGFjdCA+IDEuMyA/ICdoaWdoJyA6IHRyYWZmaWNJbXBhY3QgPiAxLjEgPyAnbWVkaXVtJyA6ICdsb3cnLFxuICAgICAgICAgIGltcGFjdDogdHJhZmZpY0ltcGFjdFxuICAgICAgICB9O1xuICAgICAgICByb3V0ZS5ldGEgPSBldGE7XG4gICAgICAgIHJvdXRlLmNvc3RCcmVha2Rvd24gPSBjb3N0QnJlYWtkb3duO1xuICAgICAgICByb3V0ZS5zY29yZXMgPSBzY29yZXM7XG4gICAgICAgIHJvdXRlLnJvdXRlQ29sb3IgPSByb3V0ZUNvbG9yO1xuICAgICAgICByb3V0ZS5wYXRoRGF0YSA9IHBhdGhEYXRhO1xuICAgICAgICByb3V0ZS5pc1doZWVsY2hhaXJBY2Nlc3NpYmxlID0gaXNXaGVlbGNoYWlyQWNjZXNzaWJsZTtcbiAgICAgICAgXG4gICAgICAgIC8vIEVuaGFuY2Ugc2VnbWVudHMgd2l0aCBzY29yZXNcbiAgICAgICAgcm91dGUuc2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudDogYW55KSA9PiB7XG4gICAgICAgICAgLy8gU2NvcmUgZWFjaCBzZWdtZW50IGJhc2VkIG9uIG1vZGUgYW5kIGNvbmRpdGlvbnNcbiAgICAgICAgICBjb25zdCBzZWdtZW50U2NvcmUgPSBzZWdtZW50Lm1vZGUgPT09ICd3YWxrJyAmJiBoYXNUb3BvbG9neUltcGFjdCA/IFxuICAgICAgICAgICAgTWF0aC5tYXgoMywgNyAtIE1hdGguZmxvb3IoYXZnVG9wb2xvZ3lEaWZmaWN1bHR5ICogMTApKSA6IC8vIFdhbGtpbmcgc2NvcmUgYWZmZWN0ZWQgYnkgaGlsbHNcbiAgICAgICAgICAgIHNlZ21lbnQubW9kZSA9PT0gJ2ViaWtlJyAmJiBoYXNUb3BvbG9neUltcGFjdCA/XG4gICAgICAgICAgICBNYXRoLm1heCgyLCA2IC0gTWF0aC5mbG9vcihhdmdUb3BvbG9neURpZmZpY3VsdHkgKiAxMCkpIDogLy8gRS1iaWtlIHNjb3JlIGFmZmVjdGVkIGJ5IGhpbGxzXG4gICAgICAgICAgICBzZWdtZW50Lm1vZGUgPT09ICdidXMnIHx8IHNlZ21lbnQubW9kZSA9PT0gJ3ViZXInIHx8IHNlZ21lbnQubW9kZSA9PT0gJ3RheGknID9cbiAgICAgICAgICAgIE1hdGgubWF4KDIsIDkgLSBNYXRoLmZsb29yKCh0cmFmZmljSW1wYWN0IC0gMSkgKiAxMCkpIDogLy8gUm9hZCB0cmFuc3BvcnQgYWZmZWN0ZWQgYnkgdHJhZmZpY1xuICAgICAgICAgICAgNzsgLy8gRGVmYXVsdCByZWFzb25hYmxlIHNjb3JlXG4gICAgICAgICAgICBcbiAgICAgICAgICBzZWdtZW50LnNjb3JlID0gc2VnbWVudFNjb3JlO1xuICAgICAgICAgIHNlZ21lbnQuYWRqdXN0ZWREdXJhdGlvbiA9IHNlZ21lbnQubW9kZSA9PT0gJ3dhbGsnICYmIGhhc1RvcG9sb2d5SW1wYWN0ID8gXG4gICAgICAgICAgICBNYXRoLnJvdW5kKHNlZ21lbnQuZHVyYXRpb24gKiAoMSArIGF2Z1RvcG9sb2d5RGlmZmljdWx0eSkpIDogLy8gV2Fsa2luZyBpcyBzbG93ZXIgaW4gaGlsbHkgYXJlYXNcbiAgICAgICAgICAgIChzZWdtZW50Lm1vZGUgPT09ICdidXMnIHx8IHNlZ21lbnQubW9kZSA9PT0gJ3ViZXInIHx8IHNlZ21lbnQubW9kZSA9PT0gJ3RheGknKSA/XG4gICAgICAgICAgICBNYXRoLnJvdW5kKHNlZ21lbnQuZHVyYXRpb24gKiB0cmFmZmljSW1wYWN0KSA6IC8vIFRyYWZmaWMgYWZmZWN0cyByb2FkIHRyYW5zcG9ydFxuICAgICAgICAgICAgc2VnbWVudC5kdXJhdGlvbjsgLy8gTm8gYWRqdXN0bWVudCBmb3Igc3Vid2F5XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJvdXRlO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gRGVjaWRlIG9uIHRoZSBiZXN0IG92ZXJhbGwgcm91dGUgYmFzZWQgb24gZGlzdGFuY2VcbiAgICAgIGlmIChkaXN0YW5jZSA8IDEpIHtcbiAgICAgICAgLy8gVmVyeSBzaG9ydCBkaXN0YW5jZSAtIHdhbGtpbmcgbWlnaHQgYmUgYmVzdFxuICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgIG1vZGU6ICd3YWxrJyxcbiAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcbiAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxuICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMjApLCAvLyAyMCBtaW4gcGVyIG1pbGUgd2Fsa2luZ1xuICAgICAgICAgIGNvc3Q6IDAsXG4gICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGRlc3RpbmF0aW9uJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJlc3RPdmVyYWxsUm91dGUuZHVyYXRpb24gPSBNYXRoLnJvdW5kKGRpc3RhbmNlICogMjApO1xuICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmNvbWZvcnQgPSAnaGlnaCc7XG4gICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlIDwgNSAmJiAoYmVzdFN1YndheUxpbmUgfHwgY29ubmVjdGluZ0J1c2VzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIC8vIE1lZGl1bSBkaXN0YW5jZSB3aXRoIHRyYW5zaXQgb3B0aW9uc1xuICAgICAgICAvLyBGaXJzdCBzZWdtZW50IC0gd2FsayB0byBzdGF0aW9uXG4gICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgbW9kZTogJ3dhbGsnLFxuICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxuICAgICAgICAgIGVuZExvY2F0aW9uOiBiZXN0U3Vid2F5TGluZSA/IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7ZnJvbX1gIDogYEJ1cyBTdG9wIG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgZHVyYXRpb246IDUsXG4gICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICBsaW5lSW5mbzogYFdhbGsgdG8gJHtiZXN0U3Vid2F5TGluZSA/ICdzdGF0aW9uJyA6ICdidXMgc3RvcCd9YCxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZWNvbmQgc2VnbWVudCAtIHRyYW5zaXRcbiAgICAgICAgaWYgKGJlc3RTdWJ3YXlMaW5lKSB7XG4gICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG1vZGU6ICdzdWJ3YXknLFxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHt0b31gLFxuICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA4KSxcbiAgICAgICAgICAgIGNvc3Q6IDIuNzUsXG4gICAgICAgICAgICBsaW5lSW5mbzogYCR7YmVzdFN1YndheUxpbmV9IFRyYWluJHtiZXN0U3Vid2F5TGluZSA9PT0gJzcnID8gJyAoRmx1c2hpbmcgTGluZSknIDogJyd9YCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgbW9kZTogJ2J1cycsXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgQnVzIFN0b3AgbmVhciAke2Zyb219YCxcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgQnVzIFN0b3AgbmVhciAke3RvfWAsXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEwKSxcbiAgICAgICAgICAgIGNvc3Q6IDIuNzUsXG4gICAgICAgICAgICBsaW5lSW5mbzogYCR7YnVzUm91dGV9IEJ1c2AsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIExhc3Qgc2VnbWVudCAtIHdhbGsgdG8gZGVzdGluYXRpb25cbiAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICBtb2RlOiAnd2FsaycsXG4gICAgICAgICAgc3RhcnRMb2NhdGlvbjogYmVzdFN1YndheUxpbmUgPyBgU3Vid2F5IFN0YXRpb24gbmVhciAke3RvfWAgOiBgQnVzIFN0b3AgbmVhciAke3RvfWAsXG4gICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcbiAgICAgICAgICBkdXJhdGlvbjogNSxcbiAgICAgICAgICBjb3N0OiAwLFxuICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBkZXN0aW5hdGlvbicsXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5kdXJhdGlvbiA9IGJlc3RTdWJ3YXlMaW5lIFxuICAgICAgICAgID8gTWF0aC5yb3VuZChkaXN0YW5jZSAqIDgpICsgMTAgLy8gU3Vid2F5IHRpbWUgKyB3YWxraW5nXG4gICAgICAgICAgOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTApICsgMTA7IC8vIEJ1cyB0aW1lICsgd2Fsa2luZ1xuICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmNvc3QgPSAyLjc1O1xuICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmNvbWZvcnQgPSBiZXN0U3Vid2F5TGluZSA/ICdtZWRpdW0nIDogJ2xvdyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMb25nZXIgZGlzdGFuY2Ugb3Igbm8gZ29vZCB0cmFuc2l0IC0gbWl4ZWQgbW9kZSBtaWdodCBiZSBiZXN0XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggdHJhbnNpdCBpZiBhdmFpbGFibGUgZm9yIG1vc3Qgb2YgdGhlIHJvdXRlXG4gICAgICAgIGlmIChiZXN0U3Vid2F5TGluZSB8fCBoYXNUcmFuc2Zlck9wdGlvbnMpIHtcbiAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICBkdXJhdGlvbjogNSxcbiAgICAgICAgICAgIGNvc3Q6IDAsXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gc3RhdGlvbicsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGJlc3RTdWJ3YXlMaW5lKSB7XG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICBtb2RlOiAnc3Vid2F5JyxcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke3RvfWAsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogNyksXG4gICAgICAgICAgICAgIGNvc3Q6IDIuNzUsXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiBgJHtiZXN0U3Vid2F5TGluZX0gVHJhaW4ke2Jlc3RTdWJ3YXlMaW5lID09PSAnNycgPyAnIChGbHVzaGluZyBMaW5lKScgOiAnJ31gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVzZSB0cmFuc2ZlciBpZiBuZWVkZWRcbiAgICAgICAgICAgIGNvbnN0IGZyb21MaW5lID0gZnJvbVN1YndheUxpbmVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdG9MaW5lID0gdG9TdWJ3YXlMaW5lc1swXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgbW9kZTogJ3N1YndheScsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7ZnJvbX1gLFxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogJ1RyYW5zZmVyIFN0YXRpb24nLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDQpLFxuICAgICAgICAgICAgICBjb3N0OiAyLjc1LFxuICAgICAgICAgICAgICBsaW5lSW5mbzogYCR7ZnJvbUxpbmV9IFRyYWluYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICBtb2RlOiAnc3Vid2F5JyxcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogJ1RyYW5zZmVyIFN0YXRpb24nLFxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHt0b31gLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDQpLFxuICAgICAgICAgICAgICBjb3N0OiAwLFxuICAgICAgICAgICAgICBsaW5lSW5mbzogYCR7dG9MaW5lfSBUcmFpbmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIGxvbmdlciBkaXN0YW5jZXMsIHVzZSBVYmVyIGZvciB0aGUgbGFzdCBtaWxlXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID4gOCkge1xuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgbW9kZTogJ3ViZXInLFxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke3RvfWAsXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA4LFxuICAgICAgICAgICAgICBjb3N0OiA3LjUwLFxuICAgICAgICAgICAgICBsaW5lSW5mbzogJ1ViZXJYIChsYXN0IG1pbGUpJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmR1cmF0aW9uID0gTWF0aC5yb3VuZChkaXN0YW5jZSAqIDYpICsgMTM7IC8vIFRyYW5zaXQgKyB1YmVyICsgaW5pdGlhbCB3YWxrXG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmNvc3QgPSAxMC4yNTsgLy8gU3Vid2F5ICsgdWJlclxuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5jb21mb3J0ID0gJ2hpZ2gnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICBtb2RlOiAnd2FsaycsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7dG99YCxcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDUsXG4gICAgICAgICAgICAgIGNvc3Q6IDAsXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBkZXN0aW5hdGlvbicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5kdXJhdGlvbiA9IGJlc3RTdWJ3YXlMaW5lIFxuICAgICAgICAgICAgICA/IE1hdGgucm91bmQoZGlzdGFuY2UgKiA3KSArIDEwIC8vIFN1YndheSB0aW1lICsgd2Fsa2luZ1xuICAgICAgICAgICAgICA6IE1hdGgucm91bmQoZGlzdGFuY2UgKiA4KSArIDEwOyAvLyBUcmFuc2ZlciBzdWJ3YXkgdGltZSArIHdhbGtpbmdcbiAgICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuY29zdCA9IDIuNzU7XG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmNvbWZvcnQgPSAnbWVkaXVtJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gZ29vZCB0cmFuc2l0IG9wdGlvbiAtIHVzZSBVYmVyIGZvciBlZmZpY2llbmN5XG4gICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxuICAgICAgICAgICAgZW5kTG9jYXRpb246IGBQaWNrdXAgUG9pbnQgbmVhciAke2Zyb219YCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzLFxuICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBwaWNrdXAgcG9pbnQnLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICBtb2RlOiAndWJlcicsXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgUGlja3VwIFBvaW50IG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxuICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA4KSxcbiAgICAgICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi4yNSkudG9GaXhlZCgyKSksXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1ViZXJYJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmR1cmF0aW9uID0gTWF0aC5yb3VuZChkaXN0YW5jZSAqIDgpICsgMztcbiAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmNvc3QgPSBwYXJzZUZsb2F0KChkaXN0YW5jZSAqIDIuMjUpLnRvRml4ZWQoMikpO1xuICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuY29tZm9ydCA9ICdoaWdoJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByb3V0ZXMucHVzaChiZXN0T3ZlcmFsbFJvdXRlKTtcbiAgICAgIFxuICAgICAgLy8gMS4gSWYgc3Vid2F5IGlzIGF2YWlsYWJsZSwgY3JlYXRlIGEgc3Vid2F5IHJvdXRlXG4gICAgICBpZiAoYmVzdFN1YndheUxpbmUgfHwgaGFzVHJhbnNmZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN1YndheVJvdXRlOiBSb3V0ZUl0ZW0gPSB7XG4gICAgICAgICAgaWQ6IHJvdXRlcy5sZW5ndGggKyAnJyxcbiAgICAgICAgICBuYW1lOiAnRmFzdGVzdCBSb3V0ZScsXG4gICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxMCksXG4gICAgICAgICAgY29zdDogcGFyc2VGbG9hdCgoMi43NSArIChkaXN0YW5jZSA+IDUgPyAzIDogMCkpLnRvRml4ZWQoMikpLFxuICAgICAgICAgIGNvbWZvcnQ6IGRpc3RhbmNlIDwgOCA/ICdtZWRpdW0nIDogJ2xvdycsXG4gICAgICAgICAgdmVjdG9yU2NvcmU6IDAuODksXG4gICAgICAgICAgc2VnbWVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7ZnJvbX1gLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcbiAgICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgICAgbGluZUluZm86IGBXYWxrIHRvIHN0YXRpb25gLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgdGhlIHN1YndheSBzZWdtZW50KHMpXG4gICAgICAgIGlmIChiZXN0U3Vid2F5TGluZSkge1xuICAgICAgICAgIC8vIERpcmVjdCBzdWJ3YXkgbGluZVxuICAgICAgICAgIHN1YndheVJvdXRlLnNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgbW9kZTogJ3N1YndheScsXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke2Zyb219YCxcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke3RvfWAsXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDgpLFxuICAgICAgICAgICAgY29zdDogMi43NSxcbiAgICAgICAgICAgIGxpbmVJbmZvOiBgJHtiZXN0U3Vid2F5TGluZX0gVHJhaW4ke2Jlc3RTdWJ3YXlMaW5lID09PSAnNycgPyAnIChGbHVzaGluZyBMaW5lKScgOiAnJ31gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGhhc1RyYW5zZmVyT3B0aW9ucykge1xuICAgICAgICAgIC8vIE5lZWQgYSB0cmFuc2ZlclxuICAgICAgICAgIGNvbnN0IGZyb21MaW5lID0gZnJvbVN1YndheUxpbmVzWzBdO1xuICAgICAgICAgIGNvbnN0IHRvTGluZSA9IHRvU3Vid2F5TGluZXNbMF07XG4gICAgICAgICAgXG4gICAgICAgICAgc3Vid2F5Um91dGUuc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICBtb2RlOiAnc3Vid2F5JyxcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7ZnJvbX1gLFxuICAgICAgICAgICAgZW5kTG9jYXRpb246IGBUcmFuc2ZlciBTdGF0aW9uYCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogNCksXG4gICAgICAgICAgICBjb3N0OiAyLjc1LFxuICAgICAgICAgICAgbGluZUluZm86IGAke2Zyb21MaW5lfSBUcmFpbmAsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgc3Vid2F5Um91dGUuc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICBtb2RlOiAnc3Vid2F5JyxcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBUcmFuc2ZlciBTdGF0aW9uYCxcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke3RvfWAsXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDQpLFxuICAgICAgICAgICAgY29zdDogMCwgLy8gRnJlZSB0cmFuc2ZlclxuICAgICAgICAgICAgbGluZUluZm86IGAke3RvTGluZX0gVHJhaW5gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgdGhlIGZpbmFsIHdhbGtpbmcgc2VnbWVudFxuICAgICAgICBzdWJ3YXlSb3V0ZS5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICBtb2RlOiAnd2FsaycsXG4gICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHt0b31gLFxuICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXG4gICAgICAgICAgZHVyYXRpb246IDcsXG4gICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICBsaW5lSW5mbzogYFdhbGsgdG8gZGVzdGluYXRpb25gLFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJvdXRlcy5wdXNoKHN1YndheVJvdXRlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gMi4gQWx3YXlzIGNyZWF0ZSBhIHJpZGUtc2hhcmluZyByb3V0ZSBhcyBhbiBvcHRpb25cbiAgICAgIGNvbnN0IHViZXJSb3V0ZTogUm91dGVJdGVtID0ge1xuICAgICAgICBpZDogcm91dGVzLmxlbmd0aCArICcnLFxuICAgICAgICBuYW1lOiAnTW9zdCBDb21mb3J0YWJsZSBSb3V0ZScsXG4gICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTIpLFxuICAgICAgICBjb3N0OiBwYXJzZUZsb2F0KChkaXN0YW5jZSAqIDIuNSkudG9GaXhlZCgyKSksXG4gICAgICAgIGNvbWZvcnQ6ICdoaWdoJyxcbiAgICAgICAgdmVjdG9yU2NvcmU6IDAuNzgsXG4gICAgICAgIHNlZ21lbnRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYFBpY2t1cCBQb2ludCBuZWFyICR7ZnJvbX1gLFxuICAgICAgICAgICAgZHVyYXRpb246IDMsXG4gICAgICAgICAgICBjb3N0OiAwLFxuICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIHBpY2t1cCBwb2ludCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb2RlOiAndWJlcicsXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgUGlja3VwIFBvaW50IG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYERyb3Atb2ZmIG5lYXIgJHt0b31gLFxuICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxMCksXG4gICAgICAgICAgICBjb3N0OiBwYXJzZUZsb2F0KChkaXN0YW5jZSAqIDIuNSkudG9GaXhlZCgyKSksXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1ViZXJYJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBEcm9wLW9mZiBuZWFyICR7dG99YCxcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogNCxcbiAgICAgICAgICAgIGNvc3Q6IDAsXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gZGVzdGluYXRpb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9O1xuICAgICAgcm91dGVzLnB1c2godWJlclJvdXRlKTtcblxuICAgICAgLy8gQWRkIGEgdGF4aSByb3V0ZSBvcHRpb25cbiAgICAgIGNvbnN0IHRheGlSb3V0ZTogUm91dGVJdGVtID0ge1xuICAgICAgICBpZDogcm91dGVzLmxlbmd0aCArICcnLFxuICAgICAgICBuYW1lOiAnVGF4aSBSb3V0ZScsXG4gICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTEpLFxuICAgICAgICBjb3N0OiBwYXJzZUZsb2F0KChkaXN0YW5jZSAqIDIuOCkudG9GaXhlZCgyKSksXG4gICAgICAgIGNvbWZvcnQ6ICdoaWdoJyxcbiAgICAgICAgdmVjdG9yU2NvcmU6IDAuNzcsXG4gICAgICAgIHNlZ21lbnRzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYFRheGkgU3RhbmQgbmVhciAke2Zyb219YCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiA0LFxuICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byB0YXhpIHN0YW5kJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZGU6ICd0YXhpJyxcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBUYXhpIFN0YW5kIG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxuICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA5KSxcbiAgICAgICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi44KS50b0ZpeGVkKDIpKSxcbiAgICAgICAgICAgIGxpbmVJbmZvOiAnTllDIFRheGknLFxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgIH07XG4gICAgICByb3V0ZXMucHVzaCh0YXhpUm91dGUpO1xuXG4gICAgICAvLyBBZGQgYW4gRS1iaWtlIHJvdXRlIG9wdGlvbiBpZiB0aGUgZGlzdGFuY2UgaXMgdW5kZXIgMTAgbWlsZXNcbiAgICAgIGlmIChkaXN0YW5jZSA8IDEwKSB7XG4gICAgICAgIGNvbnN0IGViaWtlUm91dGU6IFJvdXRlSXRlbSA9IHtcbiAgICAgICAgICBpZDogcm91dGVzLmxlbmd0aCArICcnLFxuICAgICAgICAgIG5hbWU6ICdFLUJpa2UgUm91dGUnLFxuICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTUpLFxuICAgICAgICAgIGNvc3Q6IDUuMDAsXG4gICAgICAgICAgY29tZm9ydDogJ21lZGl1bScsXG4gICAgICAgICAgdmVjdG9yU2NvcmU6IDAuNzIsXG4gICAgICAgICAgc2VnbWVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBFLUJpa2UgU3RhdGlvbiBuZWFyICR7ZnJvbX1gLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcbiAgICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGUtYmlrZSBzdGF0aW9uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1vZGU6ICdlYmlrZScsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBFLUJpa2UgU3RhdGlvbiBuZWFyICR7ZnJvbX1gLFxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYEUtQmlrZSBTdGF0aW9uIG5lYXIgJHt0b31gLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEyKSxcbiAgICAgICAgICAgICAgY29zdDogNS4wMCxcbiAgICAgICAgICAgICAgbGluZUluZm86ICdDaXRpIEJpa2UgRS1CaWtlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYEUtQmlrZSBTdGF0aW9uIG5lYXIgJHt0b31gLFxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcbiAgICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGRlc3RpbmF0aW9uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgICAgcm91dGVzLnB1c2goZWJpa2VSb3V0ZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIDMuIFRyeSB0byBjcmVhdGUgYSBidXMgcm91dGUgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAoYnVzUm91dGVzRnJvbS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgY29ubmVjdGluZyBidXMgb3IgYW4gYXJlYS1zcGVjaWZpYyBidXMgcm91dGVcbiAgICAgICAgY29uc3QgYnVzT3B0aW9uOiBSb3V0ZUl0ZW0gPSB7XG4gICAgICAgICAgaWQ6IHJvdXRlcy5sZW5ndGggKyAnJyxcbiAgICAgICAgICBuYW1lOiAnQ2hlYXBlc3QgUm91dGUnLFxuICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTUpLFxuICAgICAgICAgIGNvc3Q6IDIuNzUsXG4gICAgICAgICAgY29tZm9ydDogJ2xvdycsXG4gICAgICAgICAgdmVjdG9yU2NvcmU6IDAuNzEsXG4gICAgICAgICAgc2VnbWVudHM6IFtdIGFzIGFueVtdLFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gRmlyc3Qgd2FsayBzZWdtZW50XG4gICAgICAgIGJ1c09wdGlvbi5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICBtb2RlOiAnd2FsaycsXG4gICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXG4gICAgICAgICAgZW5kTG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7ZnJvbX1gLFxuICAgICAgICAgIGR1cmF0aW9uOiA3LFxuICAgICAgICAgIGNvc3Q6IDAsXG4gICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGJ1cyBzdG9wJyxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcm9zcy1ib3JvdWdoIHRyaXBzIGdlbmVyYWxseSBuZWVkIHN1YndheSBvciBleHByZXNzIGJ1c1xuICAgICAgICBpZiAoaXNDcm9zc0Jvcm91Z2hUcmlwKSB7XG4gICAgICAgICAgaWYgKGV4cHJlc3NCdXNSb3V0ZSkge1xuICAgICAgICAgICAgLy8gRXhwcmVzcyBidXMgb3B0aW9uIGZvciBjcm9zcy1ib3JvdWdoXG4gICAgICAgICAgICBidXNPcHRpb24uc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgIG1vZGU6ICdidXMnLFxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgQnVzIFN0b3AgbmVhciAke2Zyb219YCxcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7dG99YCxcbiAgICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxMCksIC8vIEV4cHJlc3MgYnVzZXMgYXJlIGZhc3RlciB0aGFuIGxvY2FsXG4gICAgICAgICAgICAgIGNvc3Q6IDYuNzUsIC8vIEV4cHJlc3MgYnVzZXMgY29zdCBtb3JlXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiBgJHtleHByZXNzQnVzUm91dGV9IEV4cHJlc3MgQnVzYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBidXNPcHRpb24uY29zdCA9IDYuNzU7XG4gICAgICAgICAgICBidXNPcHRpb24ubmFtZSA9ICdFeHByZXNzIEJ1cyBSb3V0ZSc7XG4gICAgICAgICAgICBidXNPcHRpb24uY29tZm9ydCA9ICdtZWRpdW0nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbVN1YndheUxpbmVzLmxlbmd0aCA+IDAgJiYgdG9TdWJ3YXlMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBVc2UgYSBjb21iaW5hdGlvbiBvZiBsb2NhbCBidXMgYW5kIHN1YndheSBmb3IgY3Jvc3MtYm9yb3VnaFxuICAgICAgICAgICAgYnVzT3B0aW9uLnNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICBtb2RlOiAnYnVzJyxcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgJHtvcmlnaW5Cb3JvdWdofSBTdWJ3YXkgU3RhdGlvbmAsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAxMCxcbiAgICAgICAgICAgICAgY29zdDogMi43NSxcbiAgICAgICAgICAgICAgbGluZUluZm86IGAke3NwZWNpZmljRnJvbUJ1c2VzWzBdfSBCdXMgdG8gc3Vid2F5YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgc3Vid2F5IHRyYW5zZmVyXG4gICAgICAgICAgICBidXNPcHRpb24uc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgIG1vZGU6ICdzdWJ3YXknLFxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgJHtvcmlnaW5Cb3JvdWdofSBTdWJ3YXkgU3RhdGlvbmAsXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgJHtkZXN0aW5hdGlvbkJvcm91Z2h9IFN1YndheSBTdGF0aW9uYCxcbiAgICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA3KSxcbiAgICAgICAgICAgICAgY29zdDogMCwgLy8gRnJlZSB0cmFuc2ZlclxuICAgICAgICAgICAgICBsaW5lSW5mbzogYCR7ZnJvbVN1YndheUxpbmVzWzBdfSBUcmFpbmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYnVzT3B0aW9uLm5hbWUgPSAnQnVzICsgU3Vid2F5IFJvdXRlJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8ganVzdCBzaG93aW5nIHN1YndheSBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExvY2FsIGJ1cyBmb3Igc2FtZS1ib3JvdWdoIHRyaXBzXG4gICAgICAgICAgYnVzT3B0aW9uLnNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgbW9kZTogJ2J1cycsXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgQnVzIFN0b3AgbmVhciAke2Zyb219YCxcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgQnVzIFN0b3AgbmVhciAke3RvfWAsXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEyKSxcbiAgICAgICAgICAgIGNvc3Q6IDIuNzUsXG4gICAgICAgICAgICBsaW5lSW5mbzogYCR7YnVzUm91dGV9IEJ1c2AsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZpbmFsIHdhbGsgc2VnbWVudFxuICAgICAgICBidXNPcHRpb24uc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgbW9kZTogJ3dhbGsnLFxuICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7dG99YCxcbiAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxuICAgICAgICAgIGR1cmF0aW9uOiA4LFxuICAgICAgICAgIGNvc3Q6IDAsXG4gICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGRlc3RpbmF0aW9uJyxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgZHVyYXRpb24gYmFzZWQgb24gc2VnbWVudHNcbiAgICAgICAgYnVzT3B0aW9uLmR1cmF0aW9uID0gYnVzT3B0aW9uLnNlZ21lbnRzLnJlZHVjZSgodG90YWwsIHNlZ21lbnQpID0+IHRvdGFsICsgc2VnbWVudC5kdXJhdGlvbiwgMCk7XG4gICAgICAgIFxuICAgICAgICByb3V0ZXMucHVzaChidXNPcHRpb24pO1xuICAgICAgfSBlbHNlIGlmICghYmVzdFN1YndheUxpbmUgJiYgIWhhc1RyYW5zZmVyT3B0aW9ucykge1xuICAgICAgICAvLyA0LiBJZiBubyBzdWJ3YXkgb3IgYnVzIGlzIGF2YWlsYWJsZSwgYWRkIGEgYmlrZSBvcHRpb25cbiAgICAgICAgY29uc3QgYmlrZU9wdGlvbjogUm91dGVJdGVtID0ge1xuICAgICAgICAgIGlkOiByb3V0ZXMubGVuZ3RoICsgJycsXG4gICAgICAgICAgbmFtZTogJ0Vjby1GcmllbmRseSBSb3V0ZScsXG4gICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxOCksXG4gICAgICAgICAgY29zdDogMy41MCxcbiAgICAgICAgICBjb21mb3J0OiAnbWVkaXVtJyxcbiAgICAgICAgICB2ZWN0b3JTY29yZTogMC42NSxcbiAgICAgICAgICBzZWdtZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtb2RlOiAnd2FsaycsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYENpdGkgQmlrZSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA1LFxuICAgICAgICAgICAgICBjb3N0OiAwLFxuICAgICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gYmlrZSBzdGF0aW9uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1vZGU6ICdlYmlrZScsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBDaXRpIEJpa2UgU3RhdGlvbiBuZWFyICR7ZnJvbX1gLFxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYENpdGkgQmlrZSBTdGF0aW9uIG5lYXIgJHt0b31gLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDE1KSxcbiAgICAgICAgICAgICAgY29zdDogMy41MCxcbiAgICAgICAgICAgICAgbGluZUluZm86ICdDaXRpIEJpa2UnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgQ2l0aSBCaWtlIFN0YXRpb24gbmVhciAke3RvfWAsXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA1LFxuICAgICAgICAgICAgICBjb3N0OiAwLFxuICAgICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gZGVzdGluYXRpb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgICByb3V0ZXMucHVzaChiaWtlT3B0aW9uKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU29ydCByb3V0ZXMgYnkgYmFsYW5jZWQgc2NvcmVcbiAgICAgIHJvdXRlcy5mb3JFYWNoKHJvdXRlID0+IHtcbiAgICAgICAgcm91dGUuYmFsYW5jZWRTY29yZSA9IGNhbGN1bGF0ZUJhbGFuY2VkU2NvcmUocm91dGUuZHVyYXRpb24sIHJvdXRlLmNvc3QsIHJvdXRlLmNvbWZvcnQsIDAsIGZhbHNlLCBmYWxzZSwgMSwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgbW9ja1JvdXRlcyA9IHJvdXRlcy5tYXAoZmluYWxpemVSb3V0ZSk7XG4gICAgICBcbiAgICAgIC8vIEFsd2F5cyBlbnN1cmUgd2UgaGF2ZSBhdCBsZWFzdCAzIHJvdXRlc1xuICAgICAgaWYgKG1vY2tSb3V0ZXMubGVuZ3RoIDwgMykge1xuICAgICAgICAvLyBHZW5lcmF0ZSBtb3JlIGRpdmVyc2Ugcm91dGUgb3B0aW9ucyBpZiBuZWVkZWRcbiAgICAgICAgaWYgKG1vY2tSb3V0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gQWRkIGEgc2xvd2VyIGJ1dCBjaGVhcGVyIG9wdGlvblxuICAgICAgICAgIGNvbnN0IGNoZWFwZXN0Um91dGU6IFJvdXRlSXRlbSA9IHtcbiAgICAgICAgICAgIGlkOiAnOTgnLFxuICAgICAgICAgICAgbmFtZTogJ0Vjb25vbXkgT3B0aW9uJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTgpLFxuICAgICAgICAgICAgY29zdDogMi43NSxcbiAgICAgICAgICAgIGNvbWZvcnQ6ICdsb3cnLFxuICAgICAgICAgICAgdmVjdG9yU2NvcmU6IDAuNjUsXG4gICAgICAgICAgICBzZWdtZW50czogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxuICAgICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxuICAgICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgQnVzIFN0b3AgbmVhciAke2Zyb219YCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAsXG4gICAgICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gYnVzIHN0b3AnLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbW9kZTogJ2J1cycsXG4gICAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7dG99YCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDE0KSxcbiAgICAgICAgICAgICAgICBjb3N0OiAyLjc1LFxuICAgICAgICAgICAgICAgIGxpbmVJbmZvOiBgTG9jYWwgQnVzIFJvdXRlYCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcbiAgICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgQnVzIFN0b3AgbmVhciAke3RvfWAsXG4gICAgICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAsXG4gICAgICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gZGVzdGluYXRpb24nLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1vY2tSb3V0ZXMucHVzaChmaW5hbGl6ZVJvdXRlKGNoZWFwZXN0Um91dGUpKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgYSBmYXN0ZXIgYnV0IGV4cGVuc2l2ZSBvcHRpb25cbiAgICAgICAgICBjb25zdCBmYXN0ZXN0Um91dGU6IFJvdXRlSXRlbSA9IHtcbiAgICAgICAgICAgIGlkOiAnOTknLFxuICAgICAgICAgICAgbmFtZTogJ1ByZW1pdW0gRXhwcmVzcycsXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDgpLFxuICAgICAgICAgICAgY29zdDogcGFyc2VGbG9hdCgoZGlzdGFuY2UgKiAyLjUpLnRvRml4ZWQoMikpLFxuICAgICAgICAgICAgY29tZm9ydDogJ2hpZ2gnLFxuICAgICAgICAgICAgdmVjdG9yU2NvcmU6IDAuNzUsXG4gICAgICAgICAgICBzZWdtZW50czogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxuICAgICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxuICAgICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgUGlja3VwIG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDMsXG4gICAgICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gcGlja3VwIHBvaW50JyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1vZGU6ICd1YmVyJyxcbiAgICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgUGlja3VwIG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDcpLFxuICAgICAgICAgICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi41KS50b0ZpeGVkKDIpKSxcbiAgICAgICAgICAgICAgICBsaW5lSW5mbzogJ1ViZXJYIERpcmVjdCcsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH07XG4gICAgICAgICAgbW9ja1JvdXRlcy5wdXNoKGZpbmFsaXplUm91dGUoZmFzdGVzdFJvdXRlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmlsdGVyIHJvdXRlcyBiYXNlZCBvbiB3aGVlbGNoYWlyIGFjY2Vzc2liaWxpdHkgaWYgcmVxdWlyZWRcbiAgICAgIGxldCBmaWx0ZXJlZFJvdXRlcyA9IG1vY2tSb3V0ZXM7XG4gICAgICBpZiAocmVxdWlyZVdoZWVsY2hhaXIpIHtcbiAgICAgICAgZmlsdGVyZWRSb3V0ZXMgPSBtb2NrUm91dGVzLmZpbHRlcihyb3V0ZSA9PiByb3V0ZS5pc1doZWVsY2hhaXJBY2Nlc3NpYmxlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIG5vIGFjY2Vzc2libGUgcm91dGVzIGFyZSBmb3VuZCwgZ2VuZXJhdGUgYXQgbGVhc3Qgb25lXG4gICAgICAgIGlmIChmaWx0ZXJlZFJvdXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zdCBhY2Nlc3NpYmxlUm91dGU6IFJvdXRlSXRlbSA9IHtcbiAgICAgICAgICAgIGlkOiAnOTknLFxuICAgICAgICAgICAgbmFtZTogJ1doZWVsY2hhaXIgQWNjZXNzaWJsZSBSb3V0ZScsXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEwKSxcbiAgICAgICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi44KS50b0ZpeGVkKDIpKSwgLy8gU2xpZ2h0bHkgbW9yZSBleHBlbnNpdmUgZm9yIGFjY2Vzc2libGUgdmVoaWNsZXNcbiAgICAgICAgICAgIGNvbWZvcnQ6ICdoaWdoJyxcbiAgICAgICAgICAgIHZlY3RvclNjb3JlOiAwLjcsXG4gICAgICAgICAgICBzZWdtZW50czogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxuICAgICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxuICAgICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgQWNjZXNzaWJsZSBQaWNrdXAgbmVhciAke2Zyb219YCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcbiAgICAgICAgICAgICAgICBjb3N0OiAwLFxuICAgICAgICAgICAgICAgIGxpbmVJbmZvOiAnU2hvcnQgYWNjZXNzaWJsZSB3YWxrIHRvIHBpY2t1cCcsXG4gICAgICAgICAgICAgICAgd2hlZWxjaGFpckFjY2Vzc2libGU6IHRydWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1vZGU6ICd0YXhpJyxcbiAgICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgUGlja3VwIG5lYXIgJHtmcm9tfWAsXG4gICAgICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDkpLFxuICAgICAgICAgICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi44KS50b0ZpeGVkKDIpKSxcbiAgICAgICAgICAgICAgICBsaW5lSW5mbzogJ1doZWVsY2hhaXIgYWNjZXNzaWJsZSB0YXhpJyxcbiAgICAgICAgICAgICAgICB3aGVlbGNoYWlyQWNjZXNzaWJsZTogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaXNXaGVlbGNoYWlyQWNjZXNzaWJsZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgZmlsdGVyZWRSb3V0ZXMucHVzaChmaW5hbGl6ZVJvdXRlKGFjY2Vzc2libGVSb3V0ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmaWx0ZXJlZFJvdXRlcztcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHJvdXRlcyA9IGdlbmVyYXRlUm91dGVzKCk7XG5cbiAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIHByb3ZpZGUgYXQgbGVhc3QgNiByb3V0ZXNcbiAgICBpZiAocm91dGVzLmxlbmd0aCA8IDYpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgZmV3ZXIgdGhhbiA2IHJvdXRlcywgY3JlYXRlIGFsdGVybmF0aXZlIHZlcnNpb25zIHdpdGggbWlub3IgdmFyaWF0aW9uc1xuICAgICAgY29uc3QgZXhpc3RpbmdSb3V0ZXNDb3VudCA9IHJvdXRlcy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gZXhpc3RpbmdSb3V0ZXNDb3VudDsgaSA8IDY7IGkrKykge1xuICAgICAgICAvLyBDbG9uZSBhIHJvdXRlIHdpdGggc2xpZ2h0IG1vZGlmaWNhdGlvbnNcbiAgICAgICAgY29uc3QgYmFzZVJvdXRlID0gcm91dGVzW2kgJSBleGlzdGluZ1JvdXRlc0NvdW50XTtcbiAgICAgICAgY29uc3QgdmFyaWF0aW9uRmFjdG9yID0gMC4wNSArIChNYXRoLnJhbmRvbSgpICogMC4xNSk7IC8vIDUlIHRvIDIwJSB2YXJpYXRpb25cbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIHZhcmlhdGlvbiBvZiB0aGUgcm91dGVcbiAgICAgICAgY29uc3QgdmFyaWF0aW9uOiBSb3V0ZUl0ZW0gPSB7XG4gICAgICAgICAgLi4uSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShiYXNlUm91dGUpKSxcbiAgICAgICAgICBpZDogYCR7YmFzZVJvdXRlLmlkfS12YXIke2l9YCxcbiAgICAgICAgICBuYW1lOiBgQWx0ZXJuYXRpdmUgUm91dGUgJHtpKzF9YCxcbiAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChiYXNlUm91dGUuZHVyYXRpb24gKiAoMSArIChNYXRoLnJhbmRvbSgpID4gMC41ID8gdmFyaWF0aW9uRmFjdG9yIDogLXZhcmlhdGlvbkZhY3RvcikpKSxcbiAgICAgICAgICBjb3N0OiBNYXRoLnJvdW5kKGJhc2VSb3V0ZS5jb3N0ICogKDEgKyAoTWF0aC5yYW5kb20oKSA+IDAuNSA/IHZhcmlhdGlvbkZhY3RvciA6IC12YXJpYXRpb25GYWN0b3IpKSAqIDEwMCkgLyAxMDAsXG4gICAgICAgICAgdmVjdG9yU2NvcmU6IGJhc2VSb3V0ZS52ZWN0b3JTY29yZSAqICgxIC0gKHZhcmlhdGlvbkZhY3RvciAqIDAuNSkpXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBBZGp1c3Qgc2VnbWVudHMgc2xpZ2h0bHlcbiAgICAgICAgaWYgKHZhcmlhdGlvbi5zZWdtZW50cyAmJiB2YXJpYXRpb24uc2VnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhcmlhdGlvbi5zZWdtZW50cyA9IHZhcmlhdGlvbi5zZWdtZW50cy5tYXAoc2VnbWVudCA9PiB7XG4gICAgICAgICAgICAvLyBTbWFsbCB2YXJpYXRpb25zIGluIGR1cmF0aW9ucyBhbmQgY29zdHNcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnNlZ21lbnQsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKHNlZ21lbnQuZHVyYXRpb24gKiAoMSArIChNYXRoLnJhbmRvbSgpICogMC4xIC0gMC4wNSkpKSksXG4gICAgICAgICAgICAgIGNvc3Q6IE1hdGgubWF4KDAsIE1hdGgucm91bmQoc2VnbWVudC5jb3N0ICogKDEgKyAoTWF0aC5yYW5kb20oKSAqIDAuMSAtIDAuMDUpKSAqIDEwMCkgLyAxMDApXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE9jY2FzaW9uYWxseSBzd2FwIGEgc2VnbWVudCBmb3IgYSBkaWZmZXJlbnQgbW9kZSBpZiBwb3NzaWJsZVxuICAgICAgICAgIGlmICh2YXJpYXRpb24uc2VnbWVudHMubGVuZ3RoID4gMSAmJiBNYXRoLnJhbmRvbSgpID4gMC43KSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50VG9DaGFuZ2UgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB2YXJpYXRpb24uc2VnbWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNb2RlID0gdmFyaWF0aW9uLnNlZ21lbnRzW3NlZ21lbnRUb0NoYW5nZV0ubW9kZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hvb3NlIGEgZGlmZmVyZW50IG1vZGVcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZU1vZGVzID0gWydzdWJ3YXknLCAnYnVzJywgJ3dhbGsnLCAnYmlrZScsICdlYmlrZScsICd0YXhpJ107XG4gICAgICAgICAgICBjb25zdCBhbHRlcm5hdGl2ZU1vZGVzID0gYXZhaWxhYmxlTW9kZXMuZmlsdGVyKG1vZGUgPT4gbW9kZSAhPT0gY3VycmVudE1vZGUpO1xuICAgICAgICAgICAgY29uc3QgbmV3TW9kZSA9IGFsdGVybmF0aXZlTW9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYWx0ZXJuYXRpdmVNb2Rlcy5sZW5ndGgpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyaWF0aW9uLnNlZ21lbnRzW3NlZ21lbnRUb0NoYW5nZV0ubW9kZSA9IG5ld01vZGU7XG4gICAgICAgICAgICB2YXJpYXRpb24uc2VnbWVudHNbc2VnbWVudFRvQ2hhbmdlXS5jb2xvciA9IGdldFJvdXRlQ29sb3IobmV3TW9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgdGhlIHZhcmlhdGlvbiB0byB0aGUgcm91dGVzIGFycmF5XG4gICAgICAgIHJvdXRlcy5wdXNoKHZhcmlhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgXG4gICAgICByb3V0ZXM6IHJvdXRlcy5zbGljZSgwLCA2KSxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgZnJvbUNvb3JkcyxcbiAgICAgIHRvQ29vcmRzLFxuICAgICAgc3Vid2F5QXZhaWxhYmxlOiBiZXN0U3Vid2F5TGluZSAhPT0gbnVsbCB8fCBoYXNUcmFuc2Zlck9wdGlvbnMsXG4gICAgICB0cmFuc2ZlclJlcXVpcmVkOiAhYmVzdFN1YndheUxpbmUgJiYgaGFzVHJhbnNmZXJPcHRpb25zLFxuICAgICAgdHJhZmZpYzoge1xuICAgICAgICBvcmlnaW46IG9yaWdpblRyYWZmaWMsXG4gICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvblRyYWZmaWMsXG4gICAgICAgIGF2ZXJhZ2U6IGF2Z1RyYWZmaWNGYWN0b3JcbiAgICAgIH0sXG4gICAgICB0b3BvbG9neToge1xuICAgICAgICBvcmlnaW46IG9yaWdpblRvcG9sb2d5LFxuICAgICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb25Ub3BvbG9neSxcbiAgICAgICAgYXZlcmFnZTogYXZnVG9wb2xvZ3lEaWZmaWN1bHR5XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsY3VsYXRpbmcgcm91dGVzOicsIGVycm9yKTtcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBtZXNzYWdlOiAnRXJyb3IgY2FsY3VsYXRpbmcgcm91dGVzJyB9KTtcbiAgfVxufSAiXSwibmFtZXMiOlsidHJhbnNpdEFQSSIsImxvY2F0aW9uQ29vcmRpbmF0ZXMiLCJ0cmFmZmljQ29uZGl0aW9ucyIsImxldmVsIiwiZmFjdG9yIiwidG9wb2xvZ3lEaWZmaWN1bHR5IiwiZ2V0Q29vcmRpbmF0ZXMiLCJsb2NhdGlvbiIsIm5vcm1hbGl6ZWRMb2NhdGlvbiIsInRvTG93ZXJDYXNlIiwibmFtZSIsImNvb3JkcyIsIk9iamVjdCIsImVudHJpZXMiLCJpbmNsdWRlcyIsImNhbGN1bGF0ZURpc3RhbmNlIiwibGF0MSIsImxuZzEiLCJsYXQyIiwibG5nMiIsIlIiLCJkTGF0IiwiTWF0aCIsIlBJIiwiZExuZyIsImEiLCJzaW4iLCJjb3MiLCJjIiwiYXRhbjIiLCJzcXJ0IiwiZGlzdGFuY2UiLCJnZXRSb3V0ZUNvbG9yIiwibW9kZSIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwibWVzc2FnZSIsImZyb20iLCJ0byIsInByaW9yaXR5Iiwibm9pc2UiLCJzYWZldHkiLCJiYWdzIiwid2hlZWxjaGFpciIsInF1ZXJ5IiwiZnJvbUNvb3JkcyIsInRvQ29vcmRzIiwiY29uc29sZSIsImxvZyIsInVzZXJQcmlvcml0eSIsInVzZXJOb2lzZSIsInVzZXJTYWZldHkiLCJ1c2VyQmFncyIsInBhcnNlSW50IiwicmVxdWlyZVdoZWVsY2hhaXIiLCJzdWJ3YXlTdGF0dXMiLCJnZXRTdWJ3YXlTdGF0dXMiLCJzdWJ3YXlMaW5lc0J5TG9jYXRpb24iLCJmcm9tQXJlYSIsImtleXMiLCJmaW5kIiwiYXJlYSIsInRvQXJlYSIsImZyb21TdWJ3YXlMaW5lcyIsInRvU3Vid2F5TGluZXMiLCJhdmFpbGFibGVTdWJ3YXlMaW5lcyIsImZpbHRlciIsImxpbmUiLCJoYXNUcmFuc2Zlck9wdGlvbnMiLCJsZW5ndGgiLCJvcGVyYXRpbmdTdWJ3YXlMaW5lcyIsImxpbmVTdGF0dXMiLCJzIiwiYmVzdFN1YndheUxpbmUiLCJmcm9tQm9yb3VnaFByZWZpeCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwidG9Cb3JvdWdoUHJlZml4IiwiYnVzUm91dGVzRnJvbSIsImdldEJ1c1JvdXRlcyIsImJ1c1JvdXRlc0J5QXJlYSIsInNwZWNpZmljRnJvbUJ1c2VzIiwic3BlY2lmaWNUb0J1c2VzIiwiY29ubmVjdGluZ0J1c2VzIiwiYnVzIiwib3JpZ2luQm9yb3VnaCIsImRlc3RpbmF0aW9uQm9yb3VnaCIsImlzQ3Jvc3NCb3JvdWdoVHJpcCIsImV4cHJlc3NCdXNSb3V0ZXMiLCJleHByZXNzQnVzUm91dGUiLCJyb3V0ZUtleSIsInJldmVyc2VSb3V0ZUtleSIsImJ1c1JvdXRlIiwiZmxvb3IiLCJyYW5kb20iLCJvcmlnaW5UcmFmZmljIiwiZGVzdGluYXRpb25UcmFmZmljIiwib3JpZ2luVG9wb2xvZ3kiLCJkZXN0aW5hdGlvblRvcG9sb2d5IiwiYXZnVHJhZmZpY0ZhY3RvciIsImF2Z1RvcG9sb2d5RGlmZmljdWx0eSIsImdlbmVyYXRlUm91dGVzIiwicm91dGVzIiwiY2FsY3VsYXRlQmFsYW5jZWRTY29yZSIsImR1cmF0aW9uIiwiY29zdCIsImNvbWZvcnQiLCJudW1UcmFuc2ZlcnMiLCJoYXNCYWdzIiwiaXNIaWxseSIsInRyYWZmaWNJbXBhY3QiLCJpc1doZWVsY2hhaXJBY2Nlc3NpYmxlIiwiY29tZm9ydFNjb3JlIiwibWF4IiwiYWRqdXN0ZWREdXJhdGlvbiIsInRpbWVTY29yZSIsImNvc3RTY29yZSIsInRyYW5zZmVyU2NvcmUiLCJ0aW1lV2VpZ2h0IiwiY29zdFdlaWdodCIsImNvbWZvcnRXZWlnaHQiLCJ0cmFuc2ZlcldlaWdodCIsImFjY2Vzc2liaWxpdHlQZW5hbHR5IiwicmF3U2NvcmUiLCJyYXciLCJzY29yZSIsInJvdW5kIiwiZ2V0Um91dGVDb2xvckZyb21TY29yZSIsImdldFJvdXRlQ29sb3JGb3JNb2RlIiwiYmVzdE92ZXJhbGxSb3V0ZSIsImlkIiwidmVjdG9yU2NvcmUiLCJzZWdtZW50cyIsImhhc1RvcG9sb2d5SW1wYWN0IiwidHJhZmZpYyIsImltcGFjdCIsImV0YSIsImNvc3RCcmVha2Rvd24iLCJmYXJlIiwiYWRkaXRpb25hbEZlZXMiLCJ0b3RhbENvc3QiLCJzY29yZXMiLCJvdmVyYWxsIiwidGltZSIsInRyYW5zZmVycyIsInJvdXRlQ29sb3IiLCJwYXRoRGF0YSIsImNhbGN1bGF0ZUVUQSIsImR1cmF0aW9uTWludXRlcyIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiaG91ciIsIm1pbnV0ZSIsImdlbmVyYXRlUGF0aERhdGEiLCJyb3V0ZSIsImxhc3RDb29yZHMiLCJmb3JFYWNoIiwic2VnbWVudCIsImluZGV4IiwiaXNMYXN0U2VnbWVudCIsImVuZENvb3JkcyIsImVuZExvY2F0aW9uIiwicHVzaCIsInR5cGUiLCJjb2xvciIsInBvaW50cyIsIm51bVBvaW50cyIsImNlaWwiLCJjdXJyZW50UG9pbnQiLCJpIiwiZGFzaEFycmF5IiwiZmluYWxpemVSb3V0ZSIsInNvbWUiLCJyb2FkQmFzZWRTZWdtZW50cyIsImV2ZXJ5IiwiaGFzT3duUHJvcGVydHkiLCJ3aGVlbGNoYWlyQWNjZXNzaWJsZSIsInJlZHVjZSIsInRvdGFsIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJzZWdtZW50U2NvcmUiLCJzdGFydExvY2F0aW9uIiwibGluZUluZm8iLCJmcm9tTGluZSIsInRvTGluZSIsInN1YndheVJvdXRlIiwidWJlclJvdXRlIiwidGF4aVJvdXRlIiwiZWJpa2VSb3V0ZSIsImJ1c09wdGlvbiIsImJpa2VPcHRpb24iLCJiYWxhbmNlZFNjb3JlIiwibW9ja1JvdXRlcyIsIm1hcCIsImNoZWFwZXN0Um91dGUiLCJmYXN0ZXN0Um91dGUiLCJmaWx0ZXJlZFJvdXRlcyIsImFjY2Vzc2libGVSb3V0ZSIsImV4aXN0aW5nUm91dGVzQ291bnQiLCJiYXNlUm91dGUiLCJ2YXJpYXRpb25GYWN0b3IiLCJ2YXJpYXRpb24iLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJzZWdtZW50VG9DaGFuZ2UiLCJjdXJyZW50TW9kZSIsImF2YWlsYWJsZU1vZGVzIiwiYWx0ZXJuYXRpdmVNb2RlcyIsIm5ld01vZGUiLCJzbGljZSIsInN1YndheUF2YWlsYWJsZSIsInRyYW5zZmVyUmVxdWlyZWQiLCJvcmlnaW4iLCJkZXN0aW5hdGlvbiIsImF2ZXJhZ2UiLCJ0b3BvbG9neSIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/routes.ts\n");
=======
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/api */ \"(api)/./src/lib/api.ts\");\n\n// Mock coordinates for some NYC locations\nconst locationCoordinates = {\n    \"Manhattan\": [\n        40.7831,\n        -73.9712\n    ],\n    \"Brooklyn\": [\n        40.6782,\n        -73.9442\n    ],\n    \"Queens\": [\n        40.7282,\n        -73.7949\n    ],\n    \"Bronx\": [\n        40.8448,\n        -73.8648\n    ],\n    \"Staten Island\": [\n        40.5795,\n        -74.1502\n    ],\n    \"Times Square\": [\n        40.7580,\n        -73.9855\n    ],\n    \"Central Park\": [\n        40.7829,\n        -73.9654\n    ],\n    \"Prospect Park\": [\n        40.6602,\n        -73.9690\n    ],\n    \"Flushing Meadows\": [\n        40.7466,\n        -73.8422\n    ],\n    \"Flushing\": [\n        40.7654,\n        -73.8318\n    ],\n    \"Bayside\": [\n        40.7612,\n        -73.7716\n    ],\n    \"Main St\": [\n        40.7590,\n        -73.8300\n    ],\n    \"Yankee Stadium\": [\n        40.8296,\n        -73.9262\n    ]\n};\n// Traffic data mock (in a real app this would be real-time data)\nconst trafficConditions = {\n    \"Manhattan\": {\n        level: \"high\",\n        factor: 1.5\n    },\n    \"Brooklyn\": {\n        level: \"medium\",\n        factor: 1.3\n    },\n    \"Queens\": {\n        level: \"medium\",\n        factor: 1.2\n    },\n    \"Bronx\": {\n        level: \"medium\",\n        factor: 1.25\n    },\n    \"Staten Island\": {\n        level: \"low\",\n        factor: 1.1\n    },\n    \"Flushing\": {\n        level: \"medium\",\n        factor: 1.2\n    },\n    \"Bayside\": {\n        level: \"low\",\n        factor: 1.1\n    },\n    \"Times Square\": {\n        level: \"high\",\n        factor: 1.6\n    },\n    \"Central Park\": {\n        level: \"medium\",\n        factor: 1.3\n    }\n};\n// Topology data - elevation changes that affect walking/biking comfort\nconst topologyDifficulty = {\n    \"Manhattan\": 0.2,\n    \"Brooklyn\": 0.1,\n    \"Queens\": 0.1,\n    \"Bronx\": 0.4,\n    \"Staten Island\": 0.5,\n    \"Flushing\": 0.1,\n    \"Bayside\": 0.2,\n    \"Times Square\": 0.1,\n    \"Central Park\": 0.3\n};\n// Helper function to get coordinates from a location string\nconst getCoordinates = (location)=>{\n    // Normalize the location string for better matching\n    const normalizedLocation = location.toLowerCase();\n    // First try exact matches for specific neighborhoods/locations\n    for (const [name, coords] of Object.entries(locationCoordinates)){\n        if (normalizedLocation.includes(name.toLowerCase())) {\n            return coords;\n        }\n    }\n    // If no specific match, try to determine which borough it's in\n    if (normalizedLocation.includes(\"queens\") || normalizedLocation.includes(\"flushing\") || normalizedLocation.includes(\"bayside\") || normalizedLocation.includes(\"jamaica\") || normalizedLocation.includes(\"astoria\")) {\n        return locationCoordinates[\"Queens\"];\n    }\n    if (normalizedLocation.includes(\"brooklyn\") || normalizedLocation.includes(\"williamsburg\") || normalizedLocation.includes(\"park slope\")) {\n        return locationCoordinates[\"Brooklyn\"];\n    }\n    if (normalizedLocation.includes(\"bronx\")) {\n        return locationCoordinates[\"Bronx\"];\n    }\n    if (normalizedLocation.includes(\"staten\")) {\n        return locationCoordinates[\"Staten Island\"];\n    }\n    // Default to Manhattan if not found\n    return locationCoordinates[\"Manhattan\"];\n};\n// Helper function to calculate distance between two coordinates\nconst calculateDistance = (lat1, lng1, lat2, lng2)=>{\n    const R = 3958.8; // Earth radius in miles\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c;\n    return distance;\n};\n// Define the route colors for different modes\nconst getRouteColor = (mode)=>{\n    switch(mode){\n        case \"subway\":\n            return \"#3b82f6\"; // blue-500\n        case \"bus\":\n            return \"#22c55e\"; // green-500\n        case \"walk\":\n            return \"#6b7280\"; // gray-500\n        case \"bike\":\n        case \"ebike\":\n            return \"#8b5cf6\"; // purple-500\n        case \"ferry\":\n            return \"#06b6d4\"; // cyan-500\n        case \"taxi\":\n        case \"uber\":\n            return \"#f59e0b\"; // amber-500\n        default:\n            return \"#ef4444\"; // red-500\n    }\n};\n// Add this after getRouteColor function and before interface RouteItem\nconst calculateCO2Emissions = (mode, distanceKm)=>{\n    // CO2 emissions in grams per kilometer\n    const emissionsFactors = {\n        \"subway\": 30,\n        \"bus\": 70,\n        \"walk\": 0,\n        \"bike\": 0,\n        \"ebike\": 5,\n        \"ferry\": 120,\n        \"taxi\": 150,\n        \"uber\": 150,\n        \"shared\": 90,\n        \"default\": 100 // Default value\n    };\n    const emissionFactor = emissionsFactors[mode] || emissionsFactors.default;\n    return Math.round(emissionFactor * distanceKm);\n};\nasync function handler(req, res) {\n    if (req.method !== \"GET\") {\n        return res.status(405).json({\n            message: \"Method Not Allowed\"\n        });\n    }\n    const { from, to, priority, noise, safety, bags, wheelchair } = req.query;\n    if (!from || !to) {\n        return res.status(400).json({\n            message: \"Origin and destination are required\"\n        });\n    }\n    try {\n        // In a real app, we would use geocoding to get coordinates\n        const fromCoords = getCoordinates(from);\n        const toCoords = getCoordinates(to);\n        // Log the coordinates for debugging\n        console.log(`From location: \"${from}\" → coordinates: [${fromCoords[0]}, ${fromCoords[1]}]`);\n        console.log(`To location: \"${to}\" → coordinates: [${toCoords[0]}, ${toCoords[1]}]`);\n        // Get user preferences\n        const userPriority = priority || \"balanced\";\n        const userNoise = noise || \"moderate\";\n        const userSafety = safety || \"moderate\";\n        const userBags = parseInt(bags || \"0\", 10);\n        const requireWheelchair = wheelchair === \"true\";\n        // Calculate distance\n        const distance = calculateDistance(fromCoords[0], fromCoords[1], toCoords[0], toCoords[1]);\n        // Get real-time transit data\n        const subwayStatus = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.transitAPI.getSubwayStatus();\n        // Determine available subway lines based on location\n        const subwayLinesByLocation = {\n            \"Manhattan\": [\n                \"1\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"A\",\n                \"C\",\n                \"E\",\n                \"B\",\n                \"D\",\n                \"F\",\n                \"M\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"W\",\n                \"L\"\n            ],\n            \"Brooklyn\": [\n                \"A\",\n                \"C\",\n                \"G\",\n                \"J\",\n                \"Z\",\n                \"L\",\n                \"M\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\"\n            ],\n            \"Queens\": [\n                \"E\",\n                \"F\",\n                \"M\",\n                \"R\",\n                \"N\",\n                \"W\",\n                \"G\",\n                \"7\"\n            ],\n            \"Bronx\": [\n                \"1\",\n                \"2\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"B\",\n                \"D\"\n            ],\n            \"Staten Island\": [\n                \"SIR\"\n            ],\n            \"Flushing\": [\n                \"7\"\n            ],\n            \"Main St\": [\n                \"7\"\n            ],\n            \"Times Square\": [\n                \"1\",\n                \"2\",\n                \"3\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"W\",\n                \"7\",\n                \"S\"\n            ],\n            \"Central Park\": [\n                \"A\",\n                \"B\",\n                \"C\",\n                \"D\",\n                \"1\"\n            ],\n            \"Yankee Stadium\": [\n                \"4\",\n                \"B\",\n                \"D\"\n            ],\n            \"JFK Airport\": [\n                \"A\",\n                \"E\"\n            ],\n            \"LaGuardia Airport\": [],\n            \"Prospect Park\": [\n                \"B\",\n                \"Q\",\n                \"S\"\n            ]\n        };\n        // Determine from and to areas to check subway availability\n        const fromArea = Object.keys(locationCoordinates).find((area)=>from.toLowerCase().includes(area.toLowerCase())) || \"Manhattan\";\n        const toArea = Object.keys(locationCoordinates).find((area)=>to.toLowerCase().includes(area.toLowerCase())) || \"Manhattan\";\n        // Check available subway lines for the route\n        const fromSubwayLines = subwayLinesByLocation[fromArea] || [];\n        const toSubwayLines = subwayLinesByLocation[toArea] || [];\n        // Find common subway lines or lines that can get you there with a transfer\n        let availableSubwayLines = fromSubwayLines.filter((line)=>toSubwayLines.includes(line));\n        // If no direct lines, consider options with transfers\n        const hasTransferOptions = fromSubwayLines.length > 0 && toSubwayLines.length > 0;\n        // Check subway status to see if the lines are operating normally\n        const operatingSubwayLines = availableSubwayLines.filter((line)=>{\n            const lineStatus = subwayStatus.find((s)=>s.line === line);\n            return lineStatus && lineStatus.status === \"normal\";\n        });\n        // Filter to just get one operating line if available\n        const bestSubwayLine = operatingSubwayLines.length > 0 ? operatingSubwayLines[0] : null;\n        // Get all the bus routes for both areas\n        const fromBoroughPrefix = fromArea.charAt(0).toUpperCase();\n        const toBoroughPrefix = toArea.charAt(0).toUpperCase();\n        const busRoutesFrom = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.transitAPI.getBusRoutes(fromArea);\n        // Map specific neighborhoods to appropriate bus routes\n        const busRoutesByArea = {\n            \"Manhattan\": [\n                \"M1\",\n                \"M2\",\n                \"M3\",\n                \"M4\",\n                \"M5\",\n                \"M15\",\n                \"M31\",\n                \"M42\",\n                \"M60\"\n            ],\n            \"Brooklyn\": [\n                \"B41\",\n                \"B42\",\n                \"B44\",\n                \"B46\",\n                \"B67\",\n                \"B68\",\n                \"B69\"\n            ],\n            \"Queens\": [\n                \"Q58\",\n                \"Q59\",\n                \"Q60\",\n                \"Q65\",\n                \"Q66\",\n                \"Q44\",\n                \"Q46\"\n            ],\n            \"Bronx\": [\n                \"BX1\",\n                \"BX2\",\n                \"BX9\",\n                \"BX10\",\n                \"BX12\",\n                \"BX22\"\n            ],\n            \"Staten Island\": [\n                \"S40\",\n                \"S44\",\n                \"S46\",\n                \"S48\",\n                \"S51\",\n                \"S53\"\n            ],\n            \"Flushing\": [\n                \"Q65\",\n                \"Q66\",\n                \"Q17\",\n                \"Q27\",\n                \"Q44\"\n            ],\n            \"Bayside\": [\n                \"Q27\",\n                \"Q31\",\n                \"Q76\",\n                \"Q13\"\n            ],\n            \"Times Square\": [\n                \"M42\",\n                \"M104\",\n                \"Q104\"\n            ],\n            \"JFK Airport\": [\n                \"Q3\",\n                \"Q10\",\n                \"B15\"\n            ],\n            \"LaGuardia Airport\": [\n                \"Q70\",\n                \"M60\"\n            ]\n        };\n        // Get specific bus routes for origin and destination\n        const specificFromBuses = busRoutesByArea[fromArea] || [];\n        const specificToBuses = busRoutesByArea[toArea] || [];\n        // Find bus routes that might connect the two areas\n        let connectingBuses = specificFromBuses.filter((bus)=>specificToBuses.includes(bus));\n        // Check if origin and destination are in different boroughs\n        const originBorough = fromArea === \"Manhattan\" || fromArea === \"Times Square\" || fromArea === \"Central Park\" ? \"Manhattan\" : fromArea === \"Brooklyn\" || fromArea === \"Prospect Park\" ? \"Brooklyn\" : fromArea === \"Queens\" || fromArea === \"Flushing\" || fromArea === \"Bayside\" || fromArea === \"JFK Airport\" ? \"Queens\" : fromArea === \"Bronx\" || fromArea === \"Yankee Stadium\" ? \"Bronx\" : fromArea === \"Staten Island\" ? \"Staten Island\" : \"Manhattan\";\n        const destinationBorough = toArea === \"Manhattan\" || toArea === \"Times Square\" || toArea === \"Central Park\" ? \"Manhattan\" : toArea === \"Brooklyn\" || toArea === \"Prospect Park\" ? \"Brooklyn\" : toArea === \"Queens\" || toArea === \"Flushing\" || toArea === \"Bayside\" || toArea === \"JFK Airport\" ? \"Queens\" : toArea === \"Bronx\" || toArea === \"Yankee Stadium\" ? \"Bronx\" : toArea === \"Staten Island\" ? \"Staten Island\" : \"Manhattan\";\n        // Check if this is a cross-borough trip requiring transfers\n        const isCrossBoroughTrip = originBorough !== destinationBorough;\n        // Express Bus routes for cross-borough travel\n        const expressBusRoutes = {\n            \"Queens-Manhattan\": [\n                \"QM1\",\n                \"QM5\",\n                \"QM7\",\n                \"QM8\"\n            ],\n            \"Brooklyn-Manhattan\": [\n                \"BM1\",\n                \"BM2\",\n                \"BM3\",\n                \"BM4\"\n            ],\n            \"Bronx-Manhattan\": [\n                \"BxM1\",\n                \"BxM2\",\n                \"BxM3\",\n                \"BxM4\"\n            ],\n            \"Staten Island-Manhattan\": [\n                \"SIM1\",\n                \"SIM3\",\n                \"SIM4\",\n                \"SIM5\"\n            ]\n        };\n        // Get appropriate express bus if this is cross-borough\n        let expressBusRoute = \"\";\n        if (isCrossBoroughTrip) {\n            const routeKey = `${originBorough}-${destinationBorough}`;\n            const reverseRouteKey = `${destinationBorough}-${originBorough}`;\n            if (expressBusRoutes[routeKey]) {\n                expressBusRoute = expressBusRoutes[routeKey][0];\n            } else if (expressBusRoutes[reverseRouteKey]) {\n                expressBusRoute = expressBusRoutes[reverseRouteKey][0];\n            }\n        }\n        // If no direct connection, pick a bus from origin for local trips only\n        // For cross-borough trips without express buses, we'll rely on subway instead\n        if (connectingBuses.length === 0 && specificFromBuses.length > 0 && !isCrossBoroughTrip) {\n            connectingBuses = [\n                specificFromBuses[0]\n            ];\n        }\n        // Default to a borough-specific bus if nothing else is available\n        const busRoute = connectingBuses.length > 0 ? connectingBuses[0] : expressBusRoute || `${fromBoroughPrefix}${Math.floor(Math.random() * 50) + 1}`;\n        // Get traffic conditions for origin and destination areas\n        const originTraffic = trafficConditions[originBorough] || {\n            level: \"medium\",\n            factor: 1.25\n        };\n        const destinationTraffic = trafficConditions[destinationBorough] || {\n            level: \"medium\",\n            factor: 1.25\n        };\n        // Get topology difficulty for each area\n        const originTopology = topologyDifficulty[originBorough] || 0.2;\n        const destinationTopology = topologyDifficulty[destinationBorough] || 0.2;\n        // Calculate average traffic and topology difficulty\n        const avgTrafficFactor = (originTraffic.factor + destinationTraffic.factor) / 2;\n        const avgTopologyDifficulty = (originTopology + destinationTopology) / 2;\n        // Routes generation logic\n        const generateRoutes = ()=>{\n            const routes = [];\n            // Calculate a balanced score to determine which route should be \"Best Overall\"\n            const calculateBalancedScore = (duration, cost, comfort, numTransfers, hasBags, isHilly, trafficImpact, isWheelchairAccessible)=>{\n                // Base comfort score from comfort level\n                let comfortScore = comfort === \"high\" ? 0.9 : comfort === \"medium\" ? 0.6 : 0.3;\n                // Adjust comfort for number of bags\n                if (userBags > 0) {\n                    // Each bag reduces comfort, especially for walking/biking\n                    comfortScore = Math.max(0.1, comfortScore - userBags * 0.1);\n                }\n                // Adjust comfort for topology if route involves walking or biking\n                if (isHilly) {\n                    comfortScore = Math.max(0.1, comfortScore - avgTopologyDifficulty);\n                }\n                // Normalize time and cost on a scale where lower is better\n                // Traffic factor increases duration for road-based transport\n                const adjustedDuration = duration * trafficImpact;\n                const timeScore = Math.max(0, 1 - adjustedDuration / 120); // Assume 120 mins is worst case\n                const costScore = Math.max(0, 1 - cost / 30); // Assume $30 is worst case\n                // Transfer penalty\n                const transferScore = Math.max(0, 1 - numTransfers * 0.15);\n                // Adjust weights based on user priority\n                let timeWeight = 0.40;\n                let costWeight = 0.35;\n                let comfortWeight = 0.15;\n                let transferWeight = 0.10;\n                switch(userPriority){\n                    case \"speed\":\n                        timeWeight = 0.60;\n                        costWeight = 0.20;\n                        comfortWeight = 0.10;\n                        transferWeight = 0.10;\n                        break;\n                    case \"cost\":\n                        timeWeight = 0.20;\n                        costWeight = 0.60;\n                        comfortWeight = 0.10;\n                        transferWeight = 0.10;\n                        break;\n                    case \"comfort\":\n                        timeWeight = 0.20;\n                        costWeight = 0.20;\n                        comfortWeight = 0.45;\n                        transferWeight = 0.15;\n                        break;\n                    default:\n                        break;\n                }\n                // Further adjust comfort weight based on noise sensitivity\n                if (userNoise === \"high\") {\n                    // If user is highly sensitive to noise, increase comfort weight slightly\n                    comfortWeight += 0.1;\n                    // And reduce other weights proportionally\n                    timeWeight -= 0.04;\n                    costWeight -= 0.03;\n                    transferWeight -= 0.03;\n                }\n                // Adjust for safety preference\n                if (userSafety === \"high\") {\n                    // For high safety preference, fewer transfers and higher comfort are preferred\n                    transferWeight += 0.05;\n                    comfortWeight += 0.05;\n                    timeWeight -= 0.05;\n                    costWeight -= 0.05;\n                }\n                // Add wheelchair accessibility factor if needed\n                let accessibilityPenalty = 0;\n                if (requireWheelchair && !isWheelchairAccessible) {\n                    // Significantly penalize non-accessible routes when wheelchair is required\n                    accessibilityPenalty = 0.5;\n                }\n                const rawScore = (timeScore * timeWeight + costScore * costWeight + comfortScore * comfortWeight + transferScore * transferWeight) * (1 - accessibilityPenalty);\n                // Convert to 1-10 scale\n                return {\n                    raw: rawScore,\n                    score: Math.round(rawScore * 10),\n                    timeScore: Math.round(timeScore * 10),\n                    costScore: Math.round(costScore * 10),\n                    comfortScore: Math.round(comfortScore * 10),\n                    transferScore: Math.round(transferScore * 10)\n                };\n            };\n            // Function to generate route color based on score\n            const getRouteColorFromScore = (score)=>{\n                // Color gradient from red (1) to yellow (5) to green (10)\n                if (score <= 3) return \"#ef4444\"; // red-500\n                if (score <= 5) return \"#f59e0b\"; // amber-500\n                if (score <= 7) return \"#facc15\"; // yellow-400\n                if (score <= 9) return \"#65a30d\"; // lime-600\n                return \"#16a34a\"; // green-600\n            };\n            // Reference the outer getRouteColor function or redefine it here\n            const getRouteColorForMode = (mode)=>{\n                return getRouteColor(mode);\n            };\n            // 0. Best Overall route\n            const bestOverallRoute = {\n                id: \"0\",\n                name: \"Best Overall Route\",\n                duration: 0,\n                cost: 0,\n                comfort: \"medium\",\n                vectorScore: 0.95,\n                segments: [],\n                // Additional detailed information\n                hasTopologyImpact: false,\n                numTransfers: 0,\n                traffic: {\n                    level: \"medium\",\n                    impact: 1.0\n                },\n                eta: \"\",\n                costBreakdown: {\n                    fare: 0,\n                    additionalFees: 0,\n                    totalCost: 0\n                },\n                scores: {\n                    overall: 0,\n                    time: 0,\n                    cost: 0,\n                    comfort: 0,\n                    transfers: 0\n                },\n                routeColor: \"\",\n                pathData: []\n            };\n            // Helper to calculate ETA\n            const calculateETA = (durationMinutes)=>{\n                const now = new Date();\n                const eta = new Date(now.getTime() + durationMinutes * 60000);\n                return eta.toLocaleTimeString([], {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\"\n                });\n            };\n            // Generate path data for map visualization\n            const generatePathData = (route)=>{\n                const pathData = [];\n                let lastCoords = fromCoords;\n                route.segments.forEach((segment, index)=>{\n                    const isLastSegment = index === route.segments.length - 1;\n                    const endCoords = isLastSegment ? toCoords : getCoordinates(segment.endLocation);\n                    // For different transport modes, generate different path types\n                    switch(segment.mode){\n                        case \"subway\":\n                            // Subway routes should follow mostly straight lines with slight curves\n                            pathData.push({\n                                type: \"subway\",\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    // Add a midpoint with slight offset for a natural curve\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.5 + (Math.random() - 0.5) * 0.01,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.5 + (Math.random() - 0.5) * 0.01\n                                    ],\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        case \"bus\":\n                            // Bus routes should follow a more zigzag street-like pattern\n                            const numPoints = Math.ceil(calculateDistance(lastCoords[0], lastCoords[1], endCoords[0], endCoords[1]) * 2);\n                            const points = [\n                                lastCoords\n                            ];\n                            // Generate points that zigzag like city streets\n                            let currentPoint = [\n                                ...lastCoords\n                            ];\n                            for(let i = 0; i < numPoints; i++){\n                                // Alternate between horizontal and vertical movement\n                                if (i % 2 === 0) {\n                                    currentPoint = [\n                                        currentPoint[0],\n                                        currentPoint[1] + (endCoords[1] - currentPoint[1]) * 0.3\n                                    ];\n                                } else {\n                                    currentPoint = [\n                                        currentPoint[0] + (endCoords[0] - currentPoint[0]) * 0.3,\n                                        currentPoint[1]\n                                    ];\n                                }\n                                points.push(currentPoint);\n                            }\n                            points.push(endCoords);\n                            pathData.push({\n                                type: \"bus\",\n                                color: getRouteColorForMode(segment.mode),\n                                points\n                            });\n                            break;\n                        case \"walk\":\n                            // Walking should be a relatively direct path\n                            pathData.push({\n                                type: \"walk\",\n                                color: getRouteColorForMode(segment.mode),\n                                dashArray: \"4,4\",\n                                points: [\n                                    lastCoords,\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        case \"uber\":\n                        case \"taxi\":\n                            // Car routes follow streets but more direct than buses\n                            pathData.push({\n                                type: segment.mode,\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.33,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.66\n                                    ],\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.66,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.33\n                                    ],\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        case \"ebike\":\n                            // Bike routes should follow streets but might take shortcuts\n                            pathData.push({\n                                type: \"ebike\",\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    [\n                                        lastCoords[0] + (endCoords[0] - lastCoords[0]) * 0.5 + (Math.random() - 0.5) * 0.005,\n                                        lastCoords[1] + (endCoords[1] - lastCoords[1]) * 0.5 + (Math.random() - 0.5) * 0.005\n                                    ],\n                                    endCoords\n                                ]\n                            });\n                            break;\n                        default:\n                            // Default direct line\n                            pathData.push({\n                                type: segment.mode,\n                                color: getRouteColorForMode(segment.mode),\n                                points: [\n                                    lastCoords,\n                                    endCoords\n                                ]\n                            });\n                    }\n                    lastCoords = endCoords;\n                });\n                return pathData;\n            };\n            // Process a completed route with all detailed information\n            const finalizeRoute = (route)=>{\n                // Count transfers (segments that change mode of transportation)\n                const numTransfers = route.segments.length > 0 ? route.segments.length - 1 : 0;\n                // Check if route has walking/biking components to consider topology\n                const hasTopologyImpact = route.segments.some((segment)=>segment.mode === \"walk\" || segment.mode === \"ebike\");\n                // Calculate traffic impact for road-based segments\n                const roadBasedSegments = route.segments.filter((segment)=>segment.mode === \"bus\" || segment.mode === \"uber\" || segment.mode === \"taxi\");\n                const trafficImpact = roadBasedSegments.length > 0 ? avgTrafficFactor : 1.0;\n                // Determine wheelchair accessibility\n                const isWheelchairAccessible = route.segments.every((segment)=>{\n                    if (segment.mode === \"walk\") return true; // Walking is always accessible\n                    if (segment.mode === \"subway\") {\n                        // Check if the specific station is accessible - in a real app this would check actual station data\n                        // For now we'll estimate that 40% of subway segments are wheelchair accessible\n                        return segment.hasOwnProperty(\"wheelchairAccessible\") ? segment.wheelchairAccessible : Math.random() > 0.6;\n                    }\n                    if (segment.mode === \"bus\") {\n                        // Most buses are accessible\n                        return segment.hasOwnProperty(\"wheelchairAccessible\") ? segment.wheelchairAccessible : Math.random() > 0.2;\n                    }\n                    if (segment.mode === \"uber\" || segment.mode === \"taxi\") {\n                        // Some taxis/ubers are wheelchair accessible\n                        return segment.hasOwnProperty(\"wheelchairAccessible\") ? segment.wheelchairAccessible : Math.random() > 0.7;\n                    }\n                    return false;\n                });\n                // Calculate cost breakdown\n                const costBreakdown = {\n                    fare: route.segments.reduce((total, segment)=>{\n                        // Only count positive costs (e.g., exclude free transfers)\n                        return total + (segment.cost > 0 ? segment.cost : 0);\n                    }, 0),\n                    additionalFees: 0,\n                    totalCost: route.cost\n                };\n                // Add fees for Uber/Taxi during high traffic\n                if (roadBasedSegments.length > 0 && trafficImpact > 1.2) {\n                    costBreakdown.additionalFees = parseFloat((costBreakdown.fare * 0.15).toFixed(2));\n                    costBreakdown.totalCost = parseFloat((costBreakdown.fare + costBreakdown.additionalFees).toFixed(2));\n                }\n                // Calculate route scores\n                const scores = calculateBalancedScore(route.duration, costBreakdown.totalCost, route.comfort, numTransfers, userBags > 0, hasTopologyImpact, trafficImpact, isWheelchairAccessible);\n                // Calculate ETA\n                const eta = calculateETA(Math.round(route.duration * trafficImpact));\n                // Generate route color based on overall score\n                const routeColor = getRouteColorFromScore(scores.score);\n                // Calculate CO2 emissions for the entire route\n                let totalCO2 = 0;\n                route.segments.forEach((segment)=>{\n                    // Calculate segment distance in km\n                    const segmentDistance = segment.distance || calculateDistance(fromCoords[0], fromCoords[1], toCoords[0], toCoords[1]) * 1.5; // Use a multiplier to account for non-direct routes\n                    // Calculate CO2 for this segment\n                    const segmentCO2 = calculateCO2Emissions(segment.mode, segmentDistance);\n                    segment.co2 = segmentCO2;\n                    totalCO2 += segmentCO2;\n                });\n                // Set total CO2 for the route\n                route.co2 = totalCO2;\n                // Generate path data for map\n                const pathData = generatePathData(route);\n                // Add detailed information to route\n                route.numTransfers = numTransfers;\n                route.hasTopologyImpact = hasTopologyImpact;\n                route.traffic = {\n                    level: trafficImpact > 1.3 ? \"high\" : trafficImpact > 1.1 ? \"medium\" : \"low\",\n                    impact: trafficImpact\n                };\n                route.eta = eta;\n                route.costBreakdown = costBreakdown;\n                route.scores = scores;\n                route.routeColor = routeColor;\n                route.pathData = pathData;\n                route.isWheelchairAccessible = isWheelchairAccessible;\n                // Enhance segments with scores\n                route.segments.forEach((segment)=>{\n                    // Score each segment based on mode and conditions\n                    const segmentScore = segment.mode === \"walk\" && hasTopologyImpact ? Math.max(3, 7 - Math.floor(avgTopologyDifficulty * 10)) : segment.mode === \"ebike\" && hasTopologyImpact ? Math.max(2, 6 - Math.floor(avgTopologyDifficulty * 10)) : segment.mode === \"bus\" || segment.mode === \"uber\" || segment.mode === \"taxi\" ? Math.max(2, 9 - Math.floor((trafficImpact - 1) * 10)) : 7; // Default reasonable score\n                    segment.score = segmentScore;\n                    segment.adjustedDuration = segment.mode === \"walk\" && hasTopologyImpact ? Math.round(segment.duration * (1 + avgTopologyDifficulty)) : segment.mode === \"bus\" || segment.mode === \"uber\" || segment.mode === \"taxi\" ? Math.round(segment.duration * trafficImpact) : segment.duration; // No adjustment for subway\n                });\n                return route;\n            };\n            // Decide on the best overall route based on distance\n            if (distance < 1) {\n                // Very short distance - walking might be best\n                bestOverallRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: from,\n                    endLocation: to,\n                    duration: Math.round(distance * 20),\n                    cost: 0,\n                    lineInfo: \"Walk to destination\"\n                });\n                bestOverallRoute.duration = Math.round(distance * 20);\n                bestOverallRoute.comfort = \"high\";\n            } else if (distance < 5 && (bestSubwayLine || connectingBuses.length > 0)) {\n                // Medium distance with transit options\n                // First segment - walk to station\n                bestOverallRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: from,\n                    endLocation: bestSubwayLine ? `Subway Station near ${from}` : `Bus Stop near ${from}`,\n                    duration: 5,\n                    cost: 0,\n                    lineInfo: `Walk to ${bestSubwayLine ? \"station\" : \"bus stop\"}`\n                });\n                // Second segment - transit\n                if (bestSubwayLine) {\n                    bestOverallRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Subway Station near ${from}`,\n                        endLocation: `Subway Station near ${to}`,\n                        duration: Math.round(distance * 8),\n                        cost: 2.75,\n                        lineInfo: `${bestSubwayLine} Train${bestSubwayLine === \"7\" ? \" (Flushing Line)\" : \"\"}`\n                    });\n                } else {\n                    bestOverallRoute.segments.push({\n                        mode: \"bus\",\n                        startLocation: `Bus Stop near ${from}`,\n                        endLocation: `Bus Stop near ${to}`,\n                        duration: Math.round(distance * 10),\n                        cost: 2.75,\n                        lineInfo: `${busRoute} Bus`\n                    });\n                }\n                // Last segment - walk to destination\n                bestOverallRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: bestSubwayLine ? `Subway Station near ${to}` : `Bus Stop near ${to}`,\n                    endLocation: to,\n                    duration: 5,\n                    cost: 0,\n                    lineInfo: \"Walk to destination\"\n                });\n                bestOverallRoute.duration = bestSubwayLine ? Math.round(distance * 8) + 10 // Subway time + walking\n                 : Math.round(distance * 10) + 10; // Bus time + walking\n                bestOverallRoute.cost = 2.75;\n                bestOverallRoute.comfort = bestSubwayLine ? \"medium\" : \"low\";\n            } else {\n                // Longer distance or no good transit - mixed mode might be best\n                // Start with transit if available for most of the route\n                if (bestSubwayLine || hasTransferOptions) {\n                    bestOverallRoute.segments.push({\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Subway Station near ${from}`,\n                        duration: 5,\n                        cost: 0,\n                        lineInfo: \"Walk to station\"\n                    });\n                    if (bestSubwayLine) {\n                        bestOverallRoute.segments.push({\n                            mode: \"subway\",\n                            startLocation: `Subway Station near ${from}`,\n                            endLocation: `Subway Station near ${to}`,\n                            duration: Math.round(distance * 7),\n                            cost: 2.75,\n                            lineInfo: `${bestSubwayLine} Train${bestSubwayLine === \"7\" ? \" (Flushing Line)\" : \"\"}`\n                        });\n                    } else {\n                        // Use transfer if needed\n                        const fromLine = fromSubwayLines[0];\n                        const toLine = toSubwayLines[0];\n                        bestOverallRoute.segments.push({\n                            mode: \"subway\",\n                            startLocation: `Subway Station near ${from}`,\n                            endLocation: \"Transfer Station\",\n                            duration: Math.round(distance * 4),\n                            cost: 2.75,\n                            lineInfo: `${fromLine} Train`\n                        });\n                        bestOverallRoute.segments.push({\n                            mode: \"subway\",\n                            startLocation: \"Transfer Station\",\n                            endLocation: `Subway Station near ${to}`,\n                            duration: Math.round(distance * 4),\n                            cost: 0,\n                            lineInfo: `${toLine} Train`\n                        });\n                    }\n                    // For longer distances, use Uber for the last mile\n                    if (distance > 8) {\n                        bestOverallRoute.segments.push({\n                            mode: \"uber\",\n                            startLocation: `Subway Station near ${to}`,\n                            endLocation: to,\n                            duration: 8,\n                            cost: 7.50,\n                            lineInfo: \"UberX (last mile)\"\n                        });\n                        bestOverallRoute.duration = Math.round(distance * 6) + 13; // Transit + uber + initial walk\n                        bestOverallRoute.cost = 10.25; // Subway + uber\n                        bestOverallRoute.comfort = \"high\";\n                    } else {\n                        bestOverallRoute.segments.push({\n                            mode: \"walk\",\n                            startLocation: `Subway Station near ${to}`,\n                            endLocation: to,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to destination\"\n                        });\n                        bestOverallRoute.duration = bestSubwayLine ? Math.round(distance * 7) + 10 // Subway time + walking\n                         : Math.round(distance * 8) + 10; // Transfer subway time + walking\n                        bestOverallRoute.cost = 2.75;\n                        bestOverallRoute.comfort = \"medium\";\n                    }\n                } else {\n                    // No good transit option - use Uber for efficiency\n                    bestOverallRoute.segments.push({\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Pickup Point near ${from}`,\n                        duration: 3,\n                        cost: 0,\n                        lineInfo: \"Walk to pickup point\"\n                    });\n                    bestOverallRoute.segments.push({\n                        mode: \"uber\",\n                        startLocation: `Pickup Point near ${from}`,\n                        endLocation: to,\n                        duration: Math.round(distance * 8),\n                        cost: parseFloat((distance * 2.25).toFixed(2)),\n                        lineInfo: \"UberX\"\n                    });\n                    bestOverallRoute.duration = Math.round(distance * 8) + 3;\n                    bestOverallRoute.cost = parseFloat((distance * 2.25).toFixed(2));\n                    bestOverallRoute.comfort = \"high\";\n                }\n            }\n            routes.push(bestOverallRoute);\n            // 1. If subway is available, create a subway route\n            if (bestSubwayLine || hasTransferOptions) {\n                const subwayRoute = {\n                    id: routes.length + \"\",\n                    name: \"Fastest Route\",\n                    duration: Math.round(distance * 10),\n                    cost: parseFloat((2.75 + (distance > 5 ? 3 : 0)).toFixed(2)),\n                    comfort: distance < 8 ? \"medium\" : \"low\",\n                    vectorScore: 0.89,\n                    segments: [\n                        {\n                            mode: \"walk\",\n                            startLocation: from,\n                            endLocation: `Subway Station near ${from}`,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: `Walk to station`\n                        }\n                    ]\n                };\n                // Add the subway segment(s)\n                if (bestSubwayLine) {\n                    // Direct subway line\n                    subwayRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Subway Station near ${from}`,\n                        endLocation: `Subway Station near ${to}`,\n                        duration: Math.round(distance * 8),\n                        cost: 2.75,\n                        lineInfo: `${bestSubwayLine} Train${bestSubwayLine === \"7\" ? \" (Flushing Line)\" : \"\"}`\n                    });\n                } else if (hasTransferOptions) {\n                    // Need a transfer\n                    const fromLine = fromSubwayLines[0];\n                    const toLine = toSubwayLines[0];\n                    subwayRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Subway Station near ${from}`,\n                        endLocation: `Transfer Station`,\n                        duration: Math.round(distance * 4),\n                        cost: 2.75,\n                        lineInfo: `${fromLine} Train`\n                    });\n                    subwayRoute.segments.push({\n                        mode: \"subway\",\n                        startLocation: `Transfer Station`,\n                        endLocation: `Subway Station near ${to}`,\n                        duration: Math.round(distance * 4),\n                        cost: 0,\n                        lineInfo: `${toLine} Train`\n                    });\n                }\n                // Add the final walking segment\n                subwayRoute.segments.push({\n                    mode: \"walk\",\n                    startLocation: `Subway Station near ${to}`,\n                    endLocation: to,\n                    duration: 7,\n                    cost: 0,\n                    lineInfo: `Walk to destination`\n                });\n                routes.push(subwayRoute);\n            }\n            // 2. Always create a ride-sharing route as an option\n            const uberRoute = {\n                id: routes.length + \"\",\n                name: \"Most Comfortable Route\",\n                duration: Math.round(distance * 12),\n                cost: parseFloat((distance * 2.5).toFixed(2)),\n                comfort: \"high\",\n                vectorScore: 0.78,\n                segments: [\n                    {\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Pickup Point near ${from}`,\n                        duration: 3,\n                        cost: 0,\n                        lineInfo: \"Walk to pickup point\"\n                    },\n                    {\n                        mode: \"uber\",\n                        startLocation: `Pickup Point near ${from}`,\n                        endLocation: `Drop-off near ${to}`,\n                        duration: Math.round(distance * 10),\n                        cost: parseFloat((distance * 2.5).toFixed(2)),\n                        lineInfo: \"UberX\"\n                    },\n                    {\n                        mode: \"walk\",\n                        startLocation: `Drop-off near ${to}`,\n                        endLocation: to,\n                        duration: 4,\n                        cost: 0,\n                        lineInfo: \"Walk to destination\"\n                    }\n                ]\n            };\n            routes.push(uberRoute);\n            // Add a taxi route option\n            const taxiRoute = {\n                id: routes.length + \"\",\n                name: \"Taxi Route\",\n                duration: Math.round(distance * 11),\n                cost: parseFloat((distance * 2.8).toFixed(2)),\n                comfort: \"high\",\n                vectorScore: 0.77,\n                segments: [\n                    {\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: `Taxi Stand near ${from}`,\n                        duration: 4,\n                        cost: 0,\n                        lineInfo: \"Walk to taxi stand\"\n                    },\n                    {\n                        mode: \"taxi\",\n                        startLocation: `Taxi Stand near ${from}`,\n                        endLocation: to,\n                        duration: Math.round(distance * 9),\n                        cost: parseFloat((distance * 2.8).toFixed(2)),\n                        lineInfo: \"NYC Taxi\"\n                    }\n                ]\n            };\n            routes.push(taxiRoute);\n            // Add an E-bike route option if the distance is under 10 miles\n            if (distance < 10) {\n                const ebikeRoute = {\n                    id: routes.length + \"\",\n                    name: \"E-Bike Route\",\n                    duration: Math.round(distance * 15),\n                    cost: 5.00,\n                    comfort: \"medium\",\n                    vectorScore: 0.72,\n                    segments: [\n                        {\n                            mode: \"walk\",\n                            startLocation: from,\n                            endLocation: `E-Bike Station near ${from}`,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to e-bike station\"\n                        },\n                        {\n                            mode: \"ebike\",\n                            startLocation: `E-Bike Station near ${from}`,\n                            endLocation: `E-Bike Station near ${to}`,\n                            duration: Math.round(distance * 12),\n                            cost: 5.00,\n                            lineInfo: \"Citi Bike E-Bike\"\n                        },\n                        {\n                            mode: \"walk\",\n                            startLocation: `E-Bike Station near ${to}`,\n                            endLocation: to,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to destination\"\n                        }\n                    ]\n                };\n                routes.push(ebikeRoute);\n            }\n            // 3. Try to create a bus route if available\n            if (busRoutesFrom.length > 0) {\n                // Use the connecting bus or an area-specific bus route\n                const busOption = {\n                    id: routes.length + \"\",\n                    name: \"Cheapest Route\",\n                    duration: Math.round(distance * 15),\n                    cost: 2.75,\n                    comfort: \"low\",\n                    vectorScore: 0.71,\n                    segments: []\n                };\n                // First walk segment\n                busOption.segments.push({\n                    mode: \"walk\",\n                    startLocation: from,\n                    endLocation: `Bus Stop near ${from}`,\n                    duration: 7,\n                    cost: 0,\n                    lineInfo: \"Walk to bus stop\"\n                });\n                // Cross-borough trips generally need subway or express bus\n                if (isCrossBoroughTrip) {\n                    if (expressBusRoute) {\n                        // Express bus option for cross-borough\n                        busOption.segments.push({\n                            mode: \"bus\",\n                            startLocation: `Bus Stop near ${from}`,\n                            endLocation: `Bus Stop near ${to}`,\n                            duration: Math.round(distance * 10),\n                            cost: 6.75,\n                            lineInfo: `${expressBusRoute} Express Bus`\n                        });\n                        busOption.cost = 6.75;\n                        busOption.name = \"Express Bus Route\";\n                        busOption.comfort = \"medium\";\n                    } else if (fromSubwayLines.length > 0 && toSubwayLines.length > 0) {\n                        // Use a combination of local bus and subway for cross-borough\n                        busOption.segments.push({\n                            mode: \"bus\",\n                            startLocation: `Bus Stop near ${from}`,\n                            endLocation: `${originBorough} Subway Station`,\n                            duration: 10,\n                            cost: 2.75,\n                            lineInfo: `${specificFromBuses[0]} Bus to subway`\n                        });\n                        // Add subway transfer\n                        busOption.segments.push({\n                            mode: \"subway\",\n                            startLocation: `${originBorough} Subway Station`,\n                            endLocation: `${destinationBorough} Subway Station`,\n                            duration: Math.round(distance * 7),\n                            cost: 0,\n                            lineInfo: `${fromSubwayLines[0]} Train`\n                        });\n                        busOption.name = \"Bus + Subway Route\";\n                    } else {\n                        // Fallback to just showing subway if it exists\n                        return routes;\n                    }\n                } else {\n                    // Local bus for same-borough trips\n                    busOption.segments.push({\n                        mode: \"bus\",\n                        startLocation: `Bus Stop near ${from}`,\n                        endLocation: `Bus Stop near ${to}`,\n                        duration: Math.round(distance * 12),\n                        cost: 2.75,\n                        lineInfo: `${busRoute} Bus`\n                    });\n                }\n                // Final walk segment\n                busOption.segments.push({\n                    mode: \"walk\",\n                    startLocation: `Bus Stop near ${to}`,\n                    endLocation: to,\n                    duration: 8,\n                    cost: 0,\n                    lineInfo: \"Walk to destination\"\n                });\n                // Update duration based on segments\n                busOption.duration = busOption.segments.reduce((total, segment)=>total + segment.duration, 0);\n                routes.push(busOption);\n            } else if (!bestSubwayLine && !hasTransferOptions) {\n                // 4. If no subway or bus is available, add a bike option\n                const bikeOption = {\n                    id: routes.length + \"\",\n                    name: \"Eco-Friendly Route\",\n                    duration: Math.round(distance * 18),\n                    cost: 3.50,\n                    comfort: \"medium\",\n                    vectorScore: 0.65,\n                    segments: [\n                        {\n                            mode: \"walk\",\n                            startLocation: from,\n                            endLocation: `Citi Bike Station near ${from}`,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to bike station\"\n                        },\n                        {\n                            mode: \"ebike\",\n                            startLocation: `Citi Bike Station near ${from}`,\n                            endLocation: `Citi Bike Station near ${to}`,\n                            duration: Math.round(distance * 15),\n                            cost: 3.50,\n                            lineInfo: \"Citi Bike\"\n                        },\n                        {\n                            mode: \"walk\",\n                            startLocation: `Citi Bike Station near ${to}`,\n                            endLocation: to,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to destination\"\n                        }\n                    ]\n                };\n                routes.push(bikeOption);\n            }\n            // Sort routes by balanced score\n            routes.forEach((route)=>{\n                route.balancedScore = calculateBalancedScore(route.duration, route.cost, route.comfort, 0, false, false, 1, true);\n            });\n            const mockRoutes = routes.map(finalizeRoute);\n            // Always ensure we have at least 3 routes\n            if (mockRoutes.length < 3) {\n                // Generate more diverse route options if needed\n                if (mockRoutes.length === 1) {\n                    // Add a slower but cheaper option\n                    const cheapestRoute = {\n                        id: \"98\",\n                        name: \"Economy Option\",\n                        duration: Math.round(distance * 18),\n                        cost: 2.75,\n                        comfort: \"low\",\n                        vectorScore: 0.65,\n                        segments: [\n                            {\n                                mode: \"walk\",\n                                startLocation: from,\n                                endLocation: `Bus Stop near ${from}`,\n                                duration: 10,\n                                cost: 0,\n                                lineInfo: \"Walk to bus stop\"\n                            },\n                            {\n                                mode: \"bus\",\n                                startLocation: `Bus Stop near ${from}`,\n                                endLocation: `Bus Stop near ${to}`,\n                                duration: Math.round(distance * 14),\n                                cost: 2.75,\n                                lineInfo: `Local Bus Route`\n                            },\n                            {\n                                mode: \"walk\",\n                                startLocation: `Bus Stop near ${to}`,\n                                endLocation: to,\n                                duration: 10,\n                                cost: 0,\n                                lineInfo: \"Walk to destination\"\n                            }\n                        ]\n                    };\n                    mockRoutes.push(finalizeRoute(cheapestRoute));\n                    // Add a faster but expensive option\n                    const fastestRoute = {\n                        id: \"99\",\n                        name: \"Premium Express\",\n                        duration: Math.round(distance * 8),\n                        cost: parseFloat((distance * 2.5).toFixed(2)),\n                        comfort: \"high\",\n                        vectorScore: 0.75,\n                        segments: [\n                            {\n                                mode: \"walk\",\n                                startLocation: from,\n                                endLocation: `Pickup near ${from}`,\n                                duration: 3,\n                                cost: 0,\n                                lineInfo: \"Walk to pickup point\"\n                            },\n                            {\n                                mode: \"uber\",\n                                startLocation: `Pickup near ${from}`,\n                                endLocation: to,\n                                duration: Math.round(distance * 7),\n                                cost: parseFloat((distance * 2.5).toFixed(2)),\n                                lineInfo: \"UberX Direct\"\n                            }\n                        ]\n                    };\n                    mockRoutes.push(finalizeRoute(fastestRoute));\n                }\n            }\n            // Filter routes based on wheelchair accessibility if required\n            let filteredRoutes = mockRoutes;\n            if (requireWheelchair) {\n                filteredRoutes = mockRoutes.filter((route)=>route.isWheelchairAccessible);\n                // If no accessible routes are found, generate at least one\n                if (filteredRoutes.length === 0) {\n                    const accessibleRoute = {\n                        id: \"99\",\n                        name: \"Wheelchair Accessible Route\",\n                        duration: Math.round(distance * 10),\n                        cost: parseFloat((distance * 2.8).toFixed(2)),\n                        comfort: \"high\",\n                        vectorScore: 0.7,\n                        segments: [\n                            {\n                                mode: \"walk\",\n                                startLocation: from,\n                                endLocation: `Accessible Pickup near ${from}`,\n                                duration: 5,\n                                cost: 0,\n                                lineInfo: \"Short accessible walk to pickup\",\n                                wheelchairAccessible: true\n                            },\n                            {\n                                mode: \"taxi\",\n                                startLocation: `Pickup near ${from}`,\n                                endLocation: to,\n                                duration: Math.round(distance * 9),\n                                cost: parseFloat((distance * 2.8).toFixed(2)),\n                                lineInfo: \"Wheelchair accessible taxi\",\n                                wheelchairAccessible: true\n                            }\n                        ],\n                        isWheelchairAccessible: true\n                    };\n                    filteredRoutes.push(finalizeRoute(accessibleRoute));\n                }\n            }\n            return filteredRoutes;\n        };\n        const routes = generateRoutes();\n        // Ensure we always provide at least 6 routes\n        if (routes.length < 6) {\n            // If we have fewer than 6 routes, create alternative versions with minor variations\n            const existingRoutesCount = routes.length;\n            for(let i = existingRoutesCount; i < 6; i++){\n                // Clone a route with slight modifications\n                const baseRoute = routes[i % existingRoutesCount];\n                const variationFactor = 0.05 + Math.random() * 0.15; // 5% to 20% variation\n                // Create a variation of the route\n                const variation = {\n                    ...JSON.parse(JSON.stringify(baseRoute)),\n                    id: `${baseRoute.id}-var${i}`,\n                    name: `Alternative Route ${i + 1}`,\n                    duration: Math.round(baseRoute.duration * (1 + (Math.random() > 0.5 ? variationFactor : -variationFactor))),\n                    cost: Math.round(baseRoute.cost * (1 + (Math.random() > 0.5 ? variationFactor : -variationFactor)) * 100) / 100,\n                    vectorScore: baseRoute.vectorScore * (1 - variationFactor * 0.5)\n                };\n                // Adjust segments slightly\n                if (variation.segments && variation.segments.length > 0) {\n                    variation.segments = variation.segments.map((segment)=>{\n                        // Small variations in durations and costs\n                        return {\n                            ...segment,\n                            duration: Math.max(1, Math.round(segment.duration * (1 + (Math.random() * 0.1 - 0.05)))),\n                            cost: Math.max(0, Math.round(segment.cost * (1 + (Math.random() * 0.1 - 0.05)) * 100) / 100)\n                        };\n                    });\n                    // Occasionally swap a segment for a different mode if possible\n                    if (variation.segments.length > 1 && Math.random() > 0.7) {\n                        const segmentToChange = Math.floor(Math.random() * variation.segments.length);\n                        const currentMode = variation.segments[segmentToChange].mode;\n                        // Choose a different mode\n                        const availableModes = [\n                            \"subway\",\n                            \"bus\",\n                            \"walk\",\n                            \"bike\",\n                            \"ebike\",\n                            \"taxi\"\n                        ];\n                        const alternativeModes = availableModes.filter((mode)=>mode !== currentMode);\n                        const newMode = alternativeModes[Math.floor(Math.random() * alternativeModes.length)];\n                        variation.segments[segmentToChange].mode = newMode;\n                        variation.segments[segmentToChange].color = getRouteColor(newMode);\n                    }\n                }\n                // Add the variation to the routes array\n                routes.push(variation);\n            }\n        }\n        return res.status(200).json({\n            routes: routes.slice(0, 6),\n            distance,\n            fromCoords,\n            toCoords,\n            subwayAvailable: bestSubwayLine !== null || hasTransferOptions,\n            transferRequired: !bestSubwayLine && hasTransferOptions,\n            traffic: {\n                origin: originTraffic,\n                destination: destinationTraffic,\n                average: avgTrafficFactor\n            },\n            topology: {\n                origin: originTopology,\n                destination: destinationTopology,\n                average: avgTopologyDifficulty\n            }\n        });\n    } catch (error) {\n        console.error(\"Error calculating routes:\", error);\n        return res.status(500).json({\n            message: \"Error calculating routes\"\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNYO1lBQ0EySCxVQUFVO2dCQUNSSCxRQUFRMUg7Z0JBQ1IySCxhQUFhMUg7Z0JBQ2IySCxTQUFTekg7WUFDWDtRQUNGO0lBQ0YsRUFBRSxPQUFPMkgsT0FBTztRQUNkaEwsUUFBUWdMLEtBQUssQ0FBQyw2QkFBNkJBO1FBQzNDLE9BQU8vTCxJQUFJRSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQUVDLFNBQVM7UUFBMkI7SUFDcEU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1iZWVsaW5lLy4vc3JjL3BhZ2VzL2FwaS9yb3V0ZXMudHM/ZjE0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5leHRBcGlSZXF1ZXN0LCBOZXh0QXBpUmVzcG9uc2UgfSBmcm9tICduZXh0JztcclxuaW1wb3J0IHsgdHJhbnNpdEFQSSB9IGZyb20gJ0AvbGliL2FwaSc7XHJcbmltcG9ydCB7IHRyYW5zcG9ydE1vZGVzLCBmaW5kT3B0aW1hbFJvdXRlcyB9IGZyb20gJ0AvdXRpbHMvdmVjdG9yQ2FsY3VsYXRpb24nO1xyXG5cclxuLy8gTW9jayBjb29yZGluYXRlcyBmb3Igc29tZSBOWUMgbG9jYXRpb25zXHJcbmNvbnN0IGxvY2F0aW9uQ29vcmRpbmF0ZXM6IFJlY29yZDxzdHJpbmcsIFtudW1iZXIsIG51bWJlcl0+ID0ge1xyXG4gICdNYW5oYXR0YW4nOiBbNDAuNzgzMSwgLTczLjk3MTJdLFxyXG4gICdCcm9va2x5bic6IFs0MC42NzgyLCAtNzMuOTQ0Ml0sXHJcbiAgJ1F1ZWVucyc6IFs0MC43MjgyLCAtNzMuNzk0OV0sXHJcbiAgJ0Jyb254JzogWzQwLjg0NDgsIC03My44NjQ4XSxcclxuICAnU3RhdGVuIElzbGFuZCc6IFs0MC41Nzk1LCAtNzQuMTUwMl0sXHJcbiAgJ1RpbWVzIFNxdWFyZSc6IFs0MC43NTgwLCAtNzMuOTg1NV0sXHJcbiAgJ0NlbnRyYWwgUGFyayc6IFs0MC43ODI5LCAtNzMuOTY1NF0sXHJcbiAgJ1Byb3NwZWN0IFBhcmsnOiBbNDAuNjYwMiwgLTczLjk2OTBdLFxyXG4gICdGbHVzaGluZyBNZWFkb3dzJzogWzQwLjc0NjYsIC03My44NDIyXSxcclxuICAnRmx1c2hpbmcnOiBbNDAuNzY1NCwgLTczLjgzMThdLFxyXG4gICdCYXlzaWRlJzogWzQwLjc2MTIsIC03My43NzE2XSxcclxuICAnTWFpbiBTdCc6IFs0MC43NTkwLCAtNzMuODMwMF0sXHJcbiAgJ1lhbmtlZSBTdGFkaXVtJzogWzQwLjgyOTYsIC03My45MjYyXSxcclxufTtcclxuXHJcbi8vIFRyYWZmaWMgZGF0YSBtb2NrIChpbiBhIHJlYWwgYXBwIHRoaXMgd291bGQgYmUgcmVhbC10aW1lIGRhdGEpXHJcbmNvbnN0IHRyYWZmaWNDb25kaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCB7IGxldmVsOiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnLCBmYWN0b3I6IG51bWJlciB9PiA9IHtcclxuICAnTWFuaGF0dGFuJzogeyBsZXZlbDogJ2hpZ2gnLCBmYWN0b3I6IDEuNSB9LFxyXG4gICdCcm9va2x5bic6IHsgbGV2ZWw6ICdtZWRpdW0nLCBmYWN0b3I6IDEuMyB9LFxyXG4gICdRdWVlbnMnOiB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjIgfSxcclxuICAnQnJvbngnOiB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjI1IH0sXHJcbiAgJ1N0YXRlbiBJc2xhbmQnOiB7IGxldmVsOiAnbG93JywgZmFjdG9yOiAxLjEgfSxcclxuICAnRmx1c2hpbmcnOiB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjIgfSxcclxuICAnQmF5c2lkZSc6IHsgbGV2ZWw6ICdsb3cnLCBmYWN0b3I6IDEuMSB9LFxyXG4gICdUaW1lcyBTcXVhcmUnOiB7IGxldmVsOiAnaGlnaCcsIGZhY3RvcjogMS42IH0sXHJcbiAgJ0NlbnRyYWwgUGFyayc6IHsgbGV2ZWw6ICdtZWRpdW0nLCBmYWN0b3I6IDEuMyB9LFxyXG59O1xyXG5cclxuLy8gVG9wb2xvZ3kgZGF0YSAtIGVsZXZhdGlvbiBjaGFuZ2VzIHRoYXQgYWZmZWN0IHdhbGtpbmcvYmlraW5nIGNvbWZvcnRcclxuY29uc3QgdG9wb2xvZ3lEaWZmaWN1bHR5OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xyXG4gICdNYW5oYXR0YW4nOiAwLjIsIC8vIFNvbWUgaGlsbHNcclxuICAnQnJvb2tseW4nOiAwLjEsIC8vIE1vc3RseSBmbGF0XHJcbiAgJ1F1ZWVucyc6IDAuMSwgLy8gTW9zdGx5IGZsYXRcclxuICAnQnJvbngnOiAwLjQsIC8vIEhpbGx5XHJcbiAgJ1N0YXRlbiBJc2xhbmQnOiAwLjUsIC8vIFZlcnkgaGlsbHlcclxuICAnRmx1c2hpbmcnOiAwLjEsIC8vIE1vc3RseSBmbGF0XHJcbiAgJ0JheXNpZGUnOiAwLjIsIC8vIFNvbWUgaGlsbHNcclxuICAnVGltZXMgU3F1YXJlJzogMC4xLCAvLyBGbGF0XHJcbiAgJ0NlbnRyYWwgUGFyayc6IDAuMywgLy8gUm9sbGluZyBoaWxsc1xyXG59O1xyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBjb29yZGluYXRlcyBmcm9tIGEgbG9jYXRpb24gc3RyaW5nXHJcbmNvbnN0IGdldENvb3JkaW5hdGVzID0gKGxvY2F0aW9uOiBzdHJpbmcpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcclxuICAvLyBOb3JtYWxpemUgdGhlIGxvY2F0aW9uIHN0cmluZyBmb3IgYmV0dGVyIG1hdGNoaW5nXHJcbiAgY29uc3Qgbm9ybWFsaXplZExvY2F0aW9uID0gbG9jYXRpb24udG9Mb3dlckNhc2UoKTtcclxuICBcclxuICAvLyBGaXJzdCB0cnkgZXhhY3QgbWF0Y2hlcyBmb3Igc3BlY2lmaWMgbmVpZ2hib3Job29kcy9sb2NhdGlvbnNcclxuICBmb3IgKGNvbnN0IFtuYW1lLCBjb29yZHNdIG9mIE9iamVjdC5lbnRyaWVzKGxvY2F0aW9uQ29vcmRpbmF0ZXMpKSB7XHJcbiAgICBpZiAobm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKG5hbWUudG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgcmV0dXJuIGNvb3JkcztcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gSWYgbm8gc3BlY2lmaWMgbWF0Y2gsIHRyeSB0byBkZXRlcm1pbmUgd2hpY2ggYm9yb3VnaCBpdCdzIGluXHJcbiAgaWYgKG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygncXVlZW5zJykgfHwgXHJcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnZmx1c2hpbmcnKSB8fCBcclxuICAgICAgbm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKCdiYXlzaWRlJykgfHxcclxuICAgICAgbm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKCdqYW1haWNhJykgfHxcclxuICAgICAgbm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKCdhc3RvcmlhJykpIHtcclxuICAgIHJldHVybiBsb2NhdGlvbkNvb3JkaW5hdGVzWydRdWVlbnMnXTtcclxuICB9XHJcbiAgXHJcbiAgaWYgKG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnYnJvb2tseW4nKSB8fFxyXG4gICAgICBub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMoJ3dpbGxpYW1zYnVyZycpIHx8XHJcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygncGFyayBzbG9wZScpKSB7XHJcbiAgICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snQnJvb2tseW4nXTtcclxuICB9XHJcbiAgXHJcbiAgaWYgKG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnYnJvbngnKSkge1xyXG4gICAgcmV0dXJuIGxvY2F0aW9uQ29vcmRpbmF0ZXNbJ0Jyb254J107XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMoJ3N0YXRlbicpKSB7XHJcbiAgICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snU3RhdGVuIElzbGFuZCddO1xyXG4gIH1cclxuICBcclxuICAvLyBEZWZhdWx0IHRvIE1hbmhhdHRhbiBpZiBub3QgZm91bmRcclxuICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snTWFuaGF0dGFuJ107XHJcbn07XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXHJcbmNvbnN0IGNhbGN1bGF0ZURpc3RhbmNlID0gKFxyXG4gIGxhdDE6IG51bWJlciwgXHJcbiAgbG5nMTogbnVtYmVyLCBcclxuICBsYXQyOiBudW1iZXIsIFxyXG4gIGxuZzI6IG51bWJlclxyXG4pOiBudW1iZXIgPT4ge1xyXG4gIGNvbnN0IFIgPSAzOTU4Ljg7IC8vIEVhcnRoIHJhZGl1cyBpbiBtaWxlc1xyXG4gIGNvbnN0IGRMYXQgPSAobGF0MiAtIGxhdDEpICogTWF0aC5QSSAvIDE4MDtcclxuICBjb25zdCBkTG5nID0gKGxuZzIgLSBsbmcxKSAqIE1hdGguUEkgLyAxODA7XHJcbiAgY29uc3QgYSA9XHJcbiAgICBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xyXG4gICAgTWF0aC5jb3MobGF0MSAqIE1hdGguUEkgLyAxODApICogTWF0aC5jb3MobGF0MiAqIE1hdGguUEkgLyAxODApICpcclxuICAgIE1hdGguc2luKGRMbmcgLyAyKSAqIE1hdGguc2luKGRMbmcgLyAyKTtcclxuICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcclxuICBjb25zdCBkaXN0YW5jZSA9IFIgKiBjO1xyXG4gIFxyXG4gIHJldHVybiBkaXN0YW5jZTtcclxufTtcclxuXHJcbi8vIERlZmluZSB0aGUgcm91dGUgY29sb3JzIGZvciBkaWZmZXJlbnQgbW9kZXNcclxuY29uc3QgZ2V0Um91dGVDb2xvciA9IChtb2RlOiBzdHJpbmcpID0+IHtcclxuICBzd2l0Y2ggKG1vZGUpIHtcclxuICAgIGNhc2UgJ3N1YndheSc6XHJcbiAgICAgIHJldHVybiAnIzNiODJmNic7ICAvLyBibHVlLTUwMFxyXG4gICAgY2FzZSAnYnVzJzpcclxuICAgICAgcmV0dXJuICcjMjJjNTVlJzsgIC8vIGdyZWVuLTUwMFxyXG4gICAgY2FzZSAnd2Fsayc6XHJcbiAgICAgIHJldHVybiAnIzZiNzI4MCc7ICAvLyBncmF5LTUwMFxyXG4gICAgY2FzZSAnYmlrZSc6XHJcbiAgICBjYXNlICdlYmlrZSc6XHJcbiAgICAgIHJldHVybiAnIzhiNWNmNic7ICAvLyBwdXJwbGUtNTAwXHJcbiAgICBjYXNlICdmZXJyeSc6XHJcbiAgICAgIHJldHVybiAnIzA2YjZkNCc7ICAvLyBjeWFuLTUwMFxyXG4gICAgY2FzZSAndGF4aSc6XHJcbiAgICBjYXNlICd1YmVyJzpcclxuICAgICAgcmV0dXJuICcjZjU5ZTBiJzsgIC8vIGFtYmVyLTUwMFxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuICcjZWY0NDQ0JzsgIC8vIHJlZC01MDBcclxuICB9XHJcbn07XHJcblxyXG4vLyBBZGQgdGhpcyBhZnRlciBnZXRSb3V0ZUNvbG9yIGZ1bmN0aW9uIGFuZCBiZWZvcmUgaW50ZXJmYWNlIFJvdXRlSXRlbVxyXG5jb25zdCBjYWxjdWxhdGVDTzJFbWlzc2lvbnMgPSAobW9kZTogc3RyaW5nLCBkaXN0YW5jZUttOiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG4gIC8vIENPMiBlbWlzc2lvbnMgaW4gZ3JhbXMgcGVyIGtpbG9tZXRlclxyXG4gIGNvbnN0IGVtaXNzaW9uc0ZhY3RvcnM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XHJcbiAgICAnc3Vid2F5JzogMzAsICAgICAvLyBFbGVjdHJpYyBzdWJ3YXlcclxuICAgICdidXMnOiA3MCwgICAgICAgIC8vIEJ1cyAoZGllc2VsKVxyXG4gICAgJ3dhbGsnOiAwLCAgICAgICAgLy8gV2Fsa2luZyAtIG5vIGVtaXNzaW9uc1xyXG4gICAgJ2Jpa2UnOiAwLCAgICAgICAgLy8gQmlraW5nIC0gbm8gZW1pc3Npb25zXHJcbiAgICAnZWJpa2UnOiA1LCAgICAgICAvLyBFLWJpa2UgLSBtaW5pbWFsIGVtaXNzaW9ucyBmcm9tIGVsZWN0cmljaXR5XHJcbiAgICAnZmVycnknOiAxMjAsICAgICAvLyBGZXJyeVxyXG4gICAgJ3RheGknOiAxNTAsICAgICAgLy8gVGF4aVxyXG4gICAgJ3ViZXInOiAxNTAsICAgICAgLy8gVWJlclxyXG4gICAgJ3NoYXJlZCc6IDkwLCAgICAgLy8gU2hhcmVkIHJpZGUgKHBlciBwYXNzZW5nZXIpXHJcbiAgICAnZGVmYXVsdCc6IDEwMCAgICAvLyBEZWZhdWx0IHZhbHVlXHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZW1pc3Npb25GYWN0b3IgPSBlbWlzc2lvbnNGYWN0b3JzW21vZGVdIHx8IGVtaXNzaW9uc0ZhY3RvcnMuZGVmYXVsdDtcclxuICByZXR1cm4gTWF0aC5yb3VuZChlbWlzc2lvbkZhY3RvciAqIGRpc3RhbmNlS20pO1xyXG59O1xyXG5cclxuLy8gRGVmaW5lIHRoZSByb3V0ZSB0eXBlXHJcbmludGVyZmFjZSBSb3V0ZUl0ZW0ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGR1cmF0aW9uOiBudW1iZXI7XHJcbiAgY29zdDogbnVtYmVyO1xyXG4gIGNvbWZvcnQ6IHN0cmluZztcclxuICB2ZWN0b3JTY29yZTogbnVtYmVyO1xyXG4gIHNlZ21lbnRzOiBhbnlbXTtcclxuICBiYWxhbmNlZFNjb3JlPzoge1xyXG4gICAgcmF3OiBudW1iZXI7XHJcbiAgICBzY29yZTogbnVtYmVyO1xyXG4gICAgdGltZVNjb3JlOiBudW1iZXI7XHJcbiAgICBjb3N0U2NvcmU6IG51bWJlcjtcclxuICAgIGNvbWZvcnRTY29yZTogbnVtYmVyO1xyXG4gICAgdHJhbnNmZXJTY29yZTogbnVtYmVyO1xyXG4gIH07XHJcbiAgLy8gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXHJcbiAgaGFzVG9wb2xvZ3lJbXBhY3Q/OiBib29sZWFuO1xyXG4gIG51bVRyYW5zZmVycz86IG51bWJlcjtcclxuICB0cmFmZmljPzogeyBsZXZlbDogc3RyaW5nOyBpbXBhY3Q6IG51bWJlciB9O1xyXG4gIGV0YT86IHN0cmluZztcclxuICBjbzI/OiBudW1iZXI7XHJcbiAgaXNXaGVlbGNoYWlyQWNjZXNzaWJsZT86IGJvb2xlYW47XHJcbiAgc2NvcmVzPzogYW55O1xyXG4gIHJvdXRlQ29sb3I/OiBzdHJpbmc7XHJcbiAgcGF0aERhdGE/OiBhbnlbXTtcclxuICBjb3N0QnJlYWtkb3duPzogYW55O1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxyXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXHJcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2VcclxuKSB7XHJcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmpzb24oeyBtZXNzYWdlOiAnTWV0aG9kIE5vdCBBbGxvd2VkJyB9KTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZnJvbSwgdG8sIHByaW9yaXR5LCBub2lzZSwgc2FmZXR5LCBiYWdzLCB3aGVlbGNoYWlyIH0gPSByZXEucXVlcnk7XHJcblxyXG4gIGlmICghZnJvbSB8fCAhdG8pIHtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IG1lc3NhZ2U6ICdPcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGFyZSByZXF1aXJlZCcgfSk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgLy8gSW4gYSByZWFsIGFwcCwgd2Ugd291bGQgdXNlIGdlb2NvZGluZyB0byBnZXQgY29vcmRpbmF0ZXNcclxuICAgIGNvbnN0IGZyb21Db29yZHMgPSBnZXRDb29yZGluYXRlcyhmcm9tIGFzIHN0cmluZyk7XHJcbiAgICBjb25zdCB0b0Nvb3JkcyA9IGdldENvb3JkaW5hdGVzKHRvIGFzIHN0cmluZyk7XHJcbiAgICBcclxuICAgIC8vIExvZyB0aGUgY29vcmRpbmF0ZXMgZm9yIGRlYnVnZ2luZ1xyXG4gICAgY29uc29sZS5sb2coYEZyb20gbG9jYXRpb246IFwiJHtmcm9tfVwiIOKGkiBjb29yZGluYXRlczogWyR7ZnJvbUNvb3Jkc1swXX0sICR7ZnJvbUNvb3Jkc1sxXX1dYCk7XHJcbiAgICBjb25zb2xlLmxvZyhgVG8gbG9jYXRpb246IFwiJHt0b31cIiDihpIgY29vcmRpbmF0ZXM6IFske3RvQ29vcmRzWzBdfSwgJHt0b0Nvb3Jkc1sxXX1dYCk7XHJcbiAgICBcclxuICAgIC8vIEdldCB1c2VyIHByZWZlcmVuY2VzXHJcbiAgICBjb25zdCB1c2VyUHJpb3JpdHkgPSBwcmlvcml0eSBhcyBzdHJpbmcgfHwgJ2JhbGFuY2VkJztcclxuICAgIGNvbnN0IHVzZXJOb2lzZSA9IG5vaXNlIGFzIHN0cmluZyB8fCAnbW9kZXJhdGUnO1xyXG4gICAgY29uc3QgdXNlclNhZmV0eSA9IHNhZmV0eSBhcyBzdHJpbmcgfHwgJ21vZGVyYXRlJztcclxuICAgIGNvbnN0IHVzZXJCYWdzID0gcGFyc2VJbnQoYmFncyBhcyBzdHJpbmcgfHwgJzAnLCAxMCk7XHJcbiAgICBjb25zdCByZXF1aXJlV2hlZWxjaGFpciA9IHdoZWVsY2hhaXIgPT09ICd0cnVlJztcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlXHJcbiAgICBjb25zdCBkaXN0YW5jZSA9IGNhbGN1bGF0ZURpc3RhbmNlKFxyXG4gICAgICBmcm9tQ29vcmRzWzBdLCBmcm9tQ29vcmRzWzFdLCBcclxuICAgICAgdG9Db29yZHNbMF0sIHRvQ29vcmRzWzFdXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEdldCByZWFsLXRpbWUgdHJhbnNpdCBkYXRhXHJcbiAgICBjb25zdCBzdWJ3YXlTdGF0dXMgPSBhd2FpdCB0cmFuc2l0QVBJLmdldFN1YndheVN0YXR1cygpO1xyXG4gICAgXHJcbiAgICAvLyBEZXRlcm1pbmUgYXZhaWxhYmxlIHN1YndheSBsaW5lcyBiYXNlZCBvbiBsb2NhdGlvblxyXG4gICAgY29uc3Qgc3Vid2F5TGluZXNCeUxvY2F0aW9uOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7XHJcbiAgICAgICdNYW5oYXR0YW4nOiBbJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJ0EnLCAnQycsICdFJywgJ0InLCAnRCcsICdGJywgJ00nLCAnTicsICdRJywgJ1InLCAnVycsICdMJ10sXHJcbiAgICAgICdCcm9va2x5bic6IFsnQScsICdDJywgJ0cnLCAnSicsICdaJywgJ0wnLCAnTScsICdOJywgJ1EnLCAnUicsICcyJywgJzMnLCAnNCcsICc1J10sXHJcbiAgICAgICdRdWVlbnMnOiBbJ0UnLCAnRicsICdNJywgJ1InLCAnTicsICdXJywgJ0cnLCAnNyddLFxyXG4gICAgICAnQnJvbngnOiBbJzEnLCAnMicsICc0JywgJzUnLCAnNicsICdCJywgJ0QnXSxcclxuICAgICAgJ1N0YXRlbiBJc2xhbmQnOiBbJ1NJUiddLFxyXG4gICAgICAnRmx1c2hpbmcnOiBbJzcnXSxcclxuICAgICAgJ01haW4gU3QnOiBbJzcnXSxcclxuICAgICAgJ1RpbWVzIFNxdWFyZSc6IFsnMScsICcyJywgJzMnLCAnTicsICdRJywgJ1InLCAnVycsICc3JywgJ1MnXSxcclxuICAgICAgJ0NlbnRyYWwgUGFyayc6IFsnQScsICdCJywgJ0MnLCAnRCcsICcxJ10sXHJcbiAgICAgICdZYW5rZWUgU3RhZGl1bSc6IFsnNCcsICdCJywgJ0QnXSxcclxuICAgICAgJ0pGSyBBaXJwb3J0JzogWydBJywgJ0UnXSxcclxuICAgICAgJ0xhR3VhcmRpYSBBaXJwb3J0JzogW10sXHJcbiAgICAgICdQcm9zcGVjdCBQYXJrJzogWydCJywgJ1EnLCAnUyddLFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gRGV0ZXJtaW5lIGZyb20gYW5kIHRvIGFyZWFzIHRvIGNoZWNrIHN1YndheSBhdmFpbGFiaWxpdHlcclxuICAgIGNvbnN0IGZyb21BcmVhID0gT2JqZWN0LmtleXMobG9jYXRpb25Db29yZGluYXRlcykuZmluZChhcmVhID0+IFxyXG4gICAgICAoZnJvbSBhcyBzdHJpbmcpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoYXJlYS50b0xvd2VyQ2FzZSgpKVxyXG4gICAgKSB8fCAnTWFuaGF0dGFuJztcclxuICAgIFxyXG4gICAgY29uc3QgdG9BcmVhID0gT2JqZWN0LmtleXMobG9jYXRpb25Db29yZGluYXRlcykuZmluZChhcmVhID0+IFxyXG4gICAgICAodG8gYXMgc3RyaW5nKS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGFyZWEudG9Mb3dlckNhc2UoKSlcclxuICAgICkgfHwgJ01hbmhhdHRhbic7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGF2YWlsYWJsZSBzdWJ3YXkgbGluZXMgZm9yIHRoZSByb3V0ZVxyXG4gICAgY29uc3QgZnJvbVN1YndheUxpbmVzID0gc3Vid2F5TGluZXNCeUxvY2F0aW9uW2Zyb21BcmVhXSB8fCBbXTtcclxuICAgIGNvbnN0IHRvU3Vid2F5TGluZXMgPSBzdWJ3YXlMaW5lc0J5TG9jYXRpb25bdG9BcmVhXSB8fCBbXTtcclxuICAgIFxyXG4gICAgLy8gRmluZCBjb21tb24gc3Vid2F5IGxpbmVzIG9yIGxpbmVzIHRoYXQgY2FuIGdldCB5b3UgdGhlcmUgd2l0aCBhIHRyYW5zZmVyXHJcbiAgICBsZXQgYXZhaWxhYmxlU3Vid2F5TGluZXMgPSBmcm9tU3Vid2F5TGluZXMuZmlsdGVyKGxpbmUgPT4gdG9TdWJ3YXlMaW5lcy5pbmNsdWRlcyhsaW5lKSk7XHJcbiAgICBcclxuICAgIC8vIElmIG5vIGRpcmVjdCBsaW5lcywgY29uc2lkZXIgb3B0aW9ucyB3aXRoIHRyYW5zZmVyc1xyXG4gICAgY29uc3QgaGFzVHJhbnNmZXJPcHRpb25zID0gZnJvbVN1YndheUxpbmVzLmxlbmd0aCA+IDAgJiYgdG9TdWJ3YXlMaW5lcy5sZW5ndGggPiAwO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBzdWJ3YXkgc3RhdHVzIHRvIHNlZSBpZiB0aGUgbGluZXMgYXJlIG9wZXJhdGluZyBub3JtYWxseVxyXG4gICAgY29uc3Qgb3BlcmF0aW5nU3Vid2F5TGluZXMgPSBhdmFpbGFibGVTdWJ3YXlMaW5lcy5maWx0ZXIobGluZSA9PiB7XHJcbiAgICAgIGNvbnN0IGxpbmVTdGF0dXMgPSBzdWJ3YXlTdGF0dXMuZmluZChzID0+IHMubGluZSA9PT0gbGluZSk7XHJcbiAgICAgIHJldHVybiBsaW5lU3RhdHVzICYmIGxpbmVTdGF0dXMuc3RhdHVzID09PSAnbm9ybWFsJztcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBGaWx0ZXIgdG8ganVzdCBnZXQgb25lIG9wZXJhdGluZyBsaW5lIGlmIGF2YWlsYWJsZVxyXG4gICAgY29uc3QgYmVzdFN1YndheUxpbmUgPSBvcGVyYXRpbmdTdWJ3YXlMaW5lcy5sZW5ndGggPiAwID8gb3BlcmF0aW5nU3Vid2F5TGluZXNbMF0gOiBudWxsO1xyXG4gICAgXHJcbiAgICAvLyBHZXQgYWxsIHRoZSBidXMgcm91dGVzIGZvciBib3RoIGFyZWFzXHJcbiAgICBjb25zdCBmcm9tQm9yb3VnaFByZWZpeCA9IGZyb21BcmVhLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgY29uc3QgdG9Cb3JvdWdoUHJlZml4ID0gdG9BcmVhLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgY29uc3QgYnVzUm91dGVzRnJvbSA9IGF3YWl0IHRyYW5zaXRBUEkuZ2V0QnVzUm91dGVzKGZyb21BcmVhKTtcclxuICAgIFxyXG4gICAgLy8gTWFwIHNwZWNpZmljIG5laWdoYm9yaG9vZHMgdG8gYXBwcm9wcmlhdGUgYnVzIHJvdXRlc1xyXG4gICAgY29uc3QgYnVzUm91dGVzQnlBcmVhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7XHJcbiAgICAgICdNYW5oYXR0YW4nOiBbJ00xJywgJ00yJywgJ00zJywgJ000JywgJ001JywgJ00xNScsICdNMzEnLCAnTTQyJywgJ002MCddLFxyXG4gICAgICAnQnJvb2tseW4nOiBbJ0I0MScsICdCNDInLCAnQjQ0JywgJ0I0NicsICdCNjcnLCAnQjY4JywgJ0I2OSddLFxyXG4gICAgICAnUXVlZW5zJzogWydRNTgnLCAnUTU5JywgJ1E2MCcsICdRNjUnLCAnUTY2JywgJ1E0NCcsICdRNDYnXSxcclxuICAgICAgJ0Jyb254JzogWydCWDEnLCAnQlgyJywgJ0JYOScsICdCWDEwJywgJ0JYMTInLCAnQlgyMiddLFxyXG4gICAgICAnU3RhdGVuIElzbGFuZCc6IFsnUzQwJywgJ1M0NCcsICdTNDYnLCAnUzQ4JywgJ1M1MScsICdTNTMnXSxcclxuICAgICAgJ0ZsdXNoaW5nJzogWydRNjUnLCAnUTY2JywgJ1ExNycsICdRMjcnLCAnUTQ0J10sXHJcbiAgICAgICdCYXlzaWRlJzogWydRMjcnLCAnUTMxJywgJ1E3NicsICdRMTMnXSxcclxuICAgICAgJ1RpbWVzIFNxdWFyZSc6IFsnTTQyJywgJ00xMDQnLCAnUTEwNCddLFxyXG4gICAgICAnSkZLIEFpcnBvcnQnOiBbJ1EzJywgJ1ExMCcsICdCMTUnXSxcclxuICAgICAgJ0xhR3VhcmRpYSBBaXJwb3J0JzogWydRNzAnLCAnTTYwJ10sXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBHZXQgc3BlY2lmaWMgYnVzIHJvdXRlcyBmb3Igb3JpZ2luIGFuZCBkZXN0aW5hdGlvblxyXG4gICAgY29uc3Qgc3BlY2lmaWNGcm9tQnVzZXMgPSBidXNSb3V0ZXNCeUFyZWFbZnJvbUFyZWFdIHx8IFtdO1xyXG4gICAgY29uc3Qgc3BlY2lmaWNUb0J1c2VzID0gYnVzUm91dGVzQnlBcmVhW3RvQXJlYV0gfHwgW107XHJcbiAgICBcclxuICAgIC8vIEZpbmQgYnVzIHJvdXRlcyB0aGF0IG1pZ2h0IGNvbm5lY3QgdGhlIHR3byBhcmVhc1xyXG4gICAgbGV0IGNvbm5lY3RpbmdCdXNlcyA9IHNwZWNpZmljRnJvbUJ1c2VzLmZpbHRlcihidXMgPT4gc3BlY2lmaWNUb0J1c2VzLmluY2x1ZGVzKGJ1cykpO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGFyZSBpbiBkaWZmZXJlbnQgYm9yb3VnaHNcclxuICAgIGNvbnN0IG9yaWdpbkJvcm91Z2ggPSBcclxuICAgICAgZnJvbUFyZWEgPT09ICdNYW5oYXR0YW4nIHx8IGZyb21BcmVhID09PSAnVGltZXMgU3F1YXJlJyB8fCBmcm9tQXJlYSA9PT0gJ0NlbnRyYWwgUGFyaycgPyAnTWFuaGF0dGFuJyA6XHJcbiAgICAgIGZyb21BcmVhID09PSAnQnJvb2tseW4nIHx8IGZyb21BcmVhID09PSAnUHJvc3BlY3QgUGFyaycgPyAnQnJvb2tseW4nIDpcclxuICAgICAgZnJvbUFyZWEgPT09ICdRdWVlbnMnIHx8IGZyb21BcmVhID09PSAnRmx1c2hpbmcnIHx8IGZyb21BcmVhID09PSAnQmF5c2lkZScgfHwgZnJvbUFyZWEgPT09ICdKRksgQWlycG9ydCcgPyAnUXVlZW5zJyA6XHJcbiAgICAgIGZyb21BcmVhID09PSAnQnJvbngnIHx8IGZyb21BcmVhID09PSAnWWFua2VlIFN0YWRpdW0nID8gJ0Jyb254JyA6XHJcbiAgICAgIGZyb21BcmVhID09PSAnU3RhdGVuIElzbGFuZCcgPyAnU3RhdGVuIElzbGFuZCcgOiAnTWFuaGF0dGFuJztcclxuICAgIFxyXG4gICAgY29uc3QgZGVzdGluYXRpb25Cb3JvdWdoID0gXHJcbiAgICAgIHRvQXJlYSA9PT0gJ01hbmhhdHRhbicgfHwgdG9BcmVhID09PSAnVGltZXMgU3F1YXJlJyB8fCB0b0FyZWEgPT09ICdDZW50cmFsIFBhcmsnID8gJ01hbmhhdHRhbicgOlxyXG4gICAgICB0b0FyZWEgPT09ICdCcm9va2x5bicgfHwgdG9BcmVhID09PSAnUHJvc3BlY3QgUGFyaycgPyAnQnJvb2tseW4nIDpcclxuICAgICAgdG9BcmVhID09PSAnUXVlZW5zJyB8fCB0b0FyZWEgPT09ICdGbHVzaGluZycgfHwgdG9BcmVhID09PSAnQmF5c2lkZScgfHwgdG9BcmVhID09PSAnSkZLIEFpcnBvcnQnID8gJ1F1ZWVucycgOlxyXG4gICAgICB0b0FyZWEgPT09ICdCcm9ueCcgfHwgdG9BcmVhID09PSAnWWFua2VlIFN0YWRpdW0nID8gJ0Jyb254JyA6XHJcbiAgICAgIHRvQXJlYSA9PT0gJ1N0YXRlbiBJc2xhbmQnID8gJ1N0YXRlbiBJc2xhbmQnIDogJ01hbmhhdHRhbic7XHJcbiAgICBcclxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjcm9zcy1ib3JvdWdoIHRyaXAgcmVxdWlyaW5nIHRyYW5zZmVyc1xyXG4gICAgY29uc3QgaXNDcm9zc0Jvcm91Z2hUcmlwID0gb3JpZ2luQm9yb3VnaCAhPT0gZGVzdGluYXRpb25Cb3JvdWdoO1xyXG4gICAgXHJcbiAgICAvLyBFeHByZXNzIEJ1cyByb3V0ZXMgZm9yIGNyb3NzLWJvcm91Z2ggdHJhdmVsXHJcbiAgICBjb25zdCBleHByZXNzQnVzUm91dGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7XHJcbiAgICAgICdRdWVlbnMtTWFuaGF0dGFuJzogWydRTTEnLCAnUU01JywgJ1FNNycsICdRTTgnXSxcclxuICAgICAgJ0Jyb29rbHluLU1hbmhhdHRhbic6IFsnQk0xJywgJ0JNMicsICdCTTMnLCAnQk00J10sXHJcbiAgICAgICdCcm9ueC1NYW5oYXR0YW4nOiBbJ0J4TTEnLCAnQnhNMicsICdCeE0zJywgJ0J4TTQnXSxcclxuICAgICAgJ1N0YXRlbiBJc2xhbmQtTWFuaGF0dGFuJzogWydTSU0xJywgJ1NJTTMnLCAnU0lNNCcsICdTSU01J10sXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBHZXQgYXBwcm9wcmlhdGUgZXhwcmVzcyBidXMgaWYgdGhpcyBpcyBjcm9zcy1ib3JvdWdoXHJcbiAgICBsZXQgZXhwcmVzc0J1c1JvdXRlID0gJyc7XHJcbiAgICBpZiAoaXNDcm9zc0Jvcm91Z2hUcmlwKSB7XHJcbiAgICAgIGNvbnN0IHJvdXRlS2V5ID0gYCR7b3JpZ2luQm9yb3VnaH0tJHtkZXN0aW5hdGlvbkJvcm91Z2h9YDtcclxuICAgICAgY29uc3QgcmV2ZXJzZVJvdXRlS2V5ID0gYCR7ZGVzdGluYXRpb25Cb3JvdWdofS0ke29yaWdpbkJvcm91Z2h9YDtcclxuICAgICAgXHJcbiAgICAgIGlmIChleHByZXNzQnVzUm91dGVzW3JvdXRlS2V5XSkge1xyXG4gICAgICAgIGV4cHJlc3NCdXNSb3V0ZSA9IGV4cHJlc3NCdXNSb3V0ZXNbcm91dGVLZXldWzBdO1xyXG4gICAgICB9IGVsc2UgaWYgKGV4cHJlc3NCdXNSb3V0ZXNbcmV2ZXJzZVJvdXRlS2V5XSkge1xyXG4gICAgICAgIGV4cHJlc3NCdXNSb3V0ZSA9IGV4cHJlc3NCdXNSb3V0ZXNbcmV2ZXJzZVJvdXRlS2V5XVswXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBJZiBubyBkaXJlY3QgY29ubmVjdGlvbiwgcGljayBhIGJ1cyBmcm9tIG9yaWdpbiBmb3IgbG9jYWwgdHJpcHMgb25seVxyXG4gICAgLy8gRm9yIGNyb3NzLWJvcm91Z2ggdHJpcHMgd2l0aG91dCBleHByZXNzIGJ1c2VzLCB3ZSdsbCByZWx5IG9uIHN1YndheSBpbnN0ZWFkXHJcbiAgICBpZiAoY29ubmVjdGluZ0J1c2VzLmxlbmd0aCA9PT0gMCAmJiBzcGVjaWZpY0Zyb21CdXNlcy5sZW5ndGggPiAwICYmICFpc0Nyb3NzQm9yb3VnaFRyaXApIHtcclxuICAgICAgY29ubmVjdGluZ0J1c2VzID0gW3NwZWNpZmljRnJvbUJ1c2VzWzBdXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gRGVmYXVsdCB0byBhIGJvcm91Z2gtc3BlY2lmaWMgYnVzIGlmIG5vdGhpbmcgZWxzZSBpcyBhdmFpbGFibGVcclxuICAgIGNvbnN0IGJ1c1JvdXRlID0gY29ubmVjdGluZ0J1c2VzLmxlbmd0aCA+IDAgXHJcbiAgICAgID8gY29ubmVjdGluZ0J1c2VzWzBdIFxyXG4gICAgICA6IChleHByZXNzQnVzUm91dGUgfHwgYCR7ZnJvbUJvcm91Z2hQcmVmaXh9JHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1MCkgKyAxfWApO1xyXG4gICAgXHJcbiAgICAvLyBHZXQgdHJhZmZpYyBjb25kaXRpb25zIGZvciBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGFyZWFzXHJcbiAgICBjb25zdCBvcmlnaW5UcmFmZmljID0gdHJhZmZpY0NvbmRpdGlvbnNbb3JpZ2luQm9yb3VnaF0gfHwgeyBsZXZlbDogJ21lZGl1bScsIGZhY3RvcjogMS4yNSB9O1xyXG4gICAgY29uc3QgZGVzdGluYXRpb25UcmFmZmljID0gdHJhZmZpY0NvbmRpdGlvbnNbZGVzdGluYXRpb25Cb3JvdWdoXSB8fCB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjI1IH07XHJcbiAgICBcclxuICAgIC8vIEdldCB0b3BvbG9neSBkaWZmaWN1bHR5IGZvciBlYWNoIGFyZWFcclxuICAgIGNvbnN0IG9yaWdpblRvcG9sb2d5ID0gdG9wb2xvZ3lEaWZmaWN1bHR5W29yaWdpbkJvcm91Z2hdIHx8IDAuMjtcclxuICAgIGNvbnN0IGRlc3RpbmF0aW9uVG9wb2xvZ3kgPSB0b3BvbG9neURpZmZpY3VsdHlbZGVzdGluYXRpb25Cb3JvdWdoXSB8fCAwLjI7XHJcbiAgICBcclxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIHRyYWZmaWMgYW5kIHRvcG9sb2d5IGRpZmZpY3VsdHlcclxuICAgIGNvbnN0IGF2Z1RyYWZmaWNGYWN0b3IgPSAob3JpZ2luVHJhZmZpYy5mYWN0b3IgKyBkZXN0aW5hdGlvblRyYWZmaWMuZmFjdG9yKSAvIDI7XHJcbiAgICBjb25zdCBhdmdUb3BvbG9neURpZmZpY3VsdHkgPSAob3JpZ2luVG9wb2xvZ3kgKyBkZXN0aW5hdGlvblRvcG9sb2d5KSAvIDI7XHJcbiAgICBcclxuICAgIC8vIFJvdXRlcyBnZW5lcmF0aW9uIGxvZ2ljXHJcbiAgICBjb25zdCBnZW5lcmF0ZVJvdXRlcyA9ICgpID0+IHtcclxuICAgICAgY29uc3Qgcm91dGVzOiBSb3V0ZUl0ZW1bXSA9IFtdO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2FsY3VsYXRlIGEgYmFsYW5jZWQgc2NvcmUgdG8gZGV0ZXJtaW5lIHdoaWNoIHJvdXRlIHNob3VsZCBiZSBcIkJlc3QgT3ZlcmFsbFwiXHJcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZUJhbGFuY2VkU2NvcmUgPSAoZHVyYXRpb246IG51bWJlciwgY29zdDogbnVtYmVyLCBjb21mb3J0OiBzdHJpbmcsIG51bVRyYW5zZmVyczogbnVtYmVyLCBoYXNCYWdzOiBib29sZWFuLCBpc0hpbGx5OiBib29sZWFuLCB0cmFmZmljSW1wYWN0OiBudW1iZXIsIGlzV2hlZWxjaGFpckFjY2Vzc2libGU6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAvLyBCYXNlIGNvbWZvcnQgc2NvcmUgZnJvbSBjb21mb3J0IGxldmVsXHJcbiAgICAgICAgbGV0IGNvbWZvcnRTY29yZSA9IGNvbWZvcnQgPT09ICdoaWdoJyA/IDAuOSA6IGNvbWZvcnQgPT09ICdtZWRpdW0nID8gMC42IDogMC4zO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkanVzdCBjb21mb3J0IGZvciBudW1iZXIgb2YgYmFnc1xyXG4gICAgICAgIGlmICh1c2VyQmFncyA+IDApIHtcclxuICAgICAgICAgIC8vIEVhY2ggYmFnIHJlZHVjZXMgY29tZm9ydCwgZXNwZWNpYWxseSBmb3Igd2Fsa2luZy9iaWtpbmdcclxuICAgICAgICAgIGNvbWZvcnRTY29yZSA9IE1hdGgubWF4KDAuMSwgY29tZm9ydFNjb3JlIC0gKHVzZXJCYWdzICogMC4xKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkanVzdCBjb21mb3J0IGZvciB0b3BvbG9neSBpZiByb3V0ZSBpbnZvbHZlcyB3YWxraW5nIG9yIGJpa2luZ1xyXG4gICAgICAgIGlmIChpc0hpbGx5KSB7XHJcbiAgICAgICAgICBjb21mb3J0U2NvcmUgPSBNYXRoLm1heCgwLjEsIGNvbWZvcnRTY29yZSAtIGF2Z1RvcG9sb2d5RGlmZmljdWx0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aW1lIGFuZCBjb3N0IG9uIGEgc2NhbGUgd2hlcmUgbG93ZXIgaXMgYmV0dGVyXHJcbiAgICAgICAgLy8gVHJhZmZpYyBmYWN0b3IgaW5jcmVhc2VzIGR1cmF0aW9uIGZvciByb2FkLWJhc2VkIHRyYW5zcG9ydFxyXG4gICAgICAgIGNvbnN0IGFkanVzdGVkRHVyYXRpb24gPSBkdXJhdGlvbiAqIHRyYWZmaWNJbXBhY3Q7XHJcbiAgICAgICAgY29uc3QgdGltZVNjb3JlID0gTWF0aC5tYXgoMCwgMSAtIChhZGp1c3RlZER1cmF0aW9uIC8gMTIwKSk7IC8vIEFzc3VtZSAxMjAgbWlucyBpcyB3b3JzdCBjYXNlXHJcbiAgICAgICAgY29uc3QgY29zdFNjb3JlID0gTWF0aC5tYXgoMCwgMSAtIChjb3N0IC8gMzApKTsgICAgICAvLyBBc3N1bWUgJDMwIGlzIHdvcnN0IGNhc2VcclxuICAgICAgICBcclxuICAgICAgICAvLyBUcmFuc2ZlciBwZW5hbHR5XHJcbiAgICAgICAgY29uc3QgdHJhbnNmZXJTY29yZSA9IE1hdGgubWF4KDAsIDEgLSAobnVtVHJhbnNmZXJzICogMC4xNSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkanVzdCB3ZWlnaHRzIGJhc2VkIG9uIHVzZXIgcHJpb3JpdHlcclxuICAgICAgICBsZXQgdGltZVdlaWdodCA9IDAuNDA7XHJcbiAgICAgICAgbGV0IGNvc3RXZWlnaHQgPSAwLjM1O1xyXG4gICAgICAgIGxldCBjb21mb3J0V2VpZ2h0ID0gMC4xNTtcclxuICAgICAgICBsZXQgdHJhbnNmZXJXZWlnaHQgPSAwLjEwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHN3aXRjaCAodXNlclByaW9yaXR5KSB7XHJcbiAgICAgICAgICBjYXNlICdzcGVlZCc6XHJcbiAgICAgICAgICAgIHRpbWVXZWlnaHQgPSAwLjYwO1xyXG4gICAgICAgICAgICBjb3N0V2VpZ2h0ID0gMC4yMDtcclxuICAgICAgICAgICAgY29tZm9ydFdlaWdodCA9IDAuMTA7XHJcbiAgICAgICAgICAgIHRyYW5zZmVyV2VpZ2h0ID0gMC4xMDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdjb3N0JzpcclxuICAgICAgICAgICAgdGltZVdlaWdodCA9IDAuMjA7XHJcbiAgICAgICAgICAgIGNvc3RXZWlnaHQgPSAwLjYwO1xyXG4gICAgICAgICAgICBjb21mb3J0V2VpZ2h0ID0gMC4xMDtcclxuICAgICAgICAgICAgdHJhbnNmZXJXZWlnaHQgPSAwLjEwO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2NvbWZvcnQnOlxyXG4gICAgICAgICAgICB0aW1lV2VpZ2h0ID0gMC4yMDtcclxuICAgICAgICAgICAgY29zdFdlaWdodCA9IDAuMjA7XHJcbiAgICAgICAgICAgIGNvbWZvcnRXZWlnaHQgPSAwLjQ1O1xyXG4gICAgICAgICAgICB0cmFuc2ZlcldlaWdodCA9IDAuMTU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDogLy8gJ2JhbGFuY2VkJ1xyXG4gICAgICAgICAgICAvLyBLZWVwIHRoZSBkZWZhdWx0IHdlaWdodHNcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZ1cnRoZXIgYWRqdXN0IGNvbWZvcnQgd2VpZ2h0IGJhc2VkIG9uIG5vaXNlIHNlbnNpdGl2aXR5XHJcbiAgICAgICAgaWYgKHVzZXJOb2lzZSA9PT0gJ2hpZ2gnKSB7XHJcbiAgICAgICAgICAvLyBJZiB1c2VyIGlzIGhpZ2hseSBzZW5zaXRpdmUgdG8gbm9pc2UsIGluY3JlYXNlIGNvbWZvcnQgd2VpZ2h0IHNsaWdodGx5XHJcbiAgICAgICAgICBjb21mb3J0V2VpZ2h0ICs9IDAuMTtcclxuICAgICAgICAgIC8vIEFuZCByZWR1Y2Ugb3RoZXIgd2VpZ2h0cyBwcm9wb3J0aW9uYWxseVxyXG4gICAgICAgICAgdGltZVdlaWdodCAtPSAwLjA0O1xyXG4gICAgICAgICAgY29zdFdlaWdodCAtPSAwLjAzO1xyXG4gICAgICAgICAgdHJhbnNmZXJXZWlnaHQgLT0gMC4wMztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRqdXN0IGZvciBzYWZldHkgcHJlZmVyZW5jZVxyXG4gICAgICAgIGlmICh1c2VyU2FmZXR5ID09PSAnaGlnaCcpIHtcclxuICAgICAgICAgIC8vIEZvciBoaWdoIHNhZmV0eSBwcmVmZXJlbmNlLCBmZXdlciB0cmFuc2ZlcnMgYW5kIGhpZ2hlciBjb21mb3J0IGFyZSBwcmVmZXJyZWRcclxuICAgICAgICAgIHRyYW5zZmVyV2VpZ2h0ICs9IDAuMDU7XHJcbiAgICAgICAgICBjb21mb3J0V2VpZ2h0ICs9IDAuMDU7XHJcbiAgICAgICAgICB0aW1lV2VpZ2h0IC09IDAuMDU7XHJcbiAgICAgICAgICBjb3N0V2VpZ2h0IC09IDAuMDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCB3aGVlbGNoYWlyIGFjY2Vzc2liaWxpdHkgZmFjdG9yIGlmIG5lZWRlZFxyXG4gICAgICAgIGxldCBhY2Nlc3NpYmlsaXR5UGVuYWx0eSA9IDA7XHJcbiAgICAgICAgaWYgKHJlcXVpcmVXaGVlbGNoYWlyICYmICFpc1doZWVsY2hhaXJBY2Nlc3NpYmxlKSB7XHJcbiAgICAgICAgICAvLyBTaWduaWZpY2FudGx5IHBlbmFsaXplIG5vbi1hY2Nlc3NpYmxlIHJvdXRlcyB3aGVuIHdoZWVsY2hhaXIgaXMgcmVxdWlyZWRcclxuICAgICAgICAgIGFjY2Vzc2liaWxpdHlQZW5hbHR5ID0gMC41O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjb25zdCByYXdTY29yZSA9ICgodGltZVNjb3JlICogdGltZVdlaWdodCkgKyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAoY29zdFNjb3JlICogY29zdFdlaWdodCkgKyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAoY29tZm9ydFNjb3JlICogY29tZm9ydFdlaWdodCkgKyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAodHJhbnNmZXJTY29yZSAqIHRyYW5zZmVyV2VpZ2h0KSkgKiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAoMSAtIGFjY2Vzc2liaWxpdHlQZW5hbHR5KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDb252ZXJ0IHRvIDEtMTAgc2NhbGVcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgcmF3OiByYXdTY29yZSxcclxuICAgICAgICAgIHNjb3JlOiBNYXRoLnJvdW5kKHJhd1Njb3JlICogMTApLFxyXG4gICAgICAgICAgdGltZVNjb3JlOiBNYXRoLnJvdW5kKHRpbWVTY29yZSAqIDEwKSxcclxuICAgICAgICAgIGNvc3RTY29yZTogTWF0aC5yb3VuZChjb3N0U2NvcmUgKiAxMCksXHJcbiAgICAgICAgICBjb21mb3J0U2NvcmU6IE1hdGgucm91bmQoY29tZm9ydFNjb3JlICogMTApLFxyXG4gICAgICAgICAgdHJhbnNmZXJTY29yZTogTWF0aC5yb3VuZCh0cmFuc2ZlclNjb3JlICogMTApXHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIEZ1bmN0aW9uIHRvIGdlbmVyYXRlIHJvdXRlIGNvbG9yIGJhc2VkIG9uIHNjb3JlXHJcbiAgICAgIGNvbnN0IGdldFJvdXRlQ29sb3JGcm9tU2NvcmUgPSAoc2NvcmU6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIC8vIENvbG9yIGdyYWRpZW50IGZyb20gcmVkICgxKSB0byB5ZWxsb3cgKDUpIHRvIGdyZWVuICgxMClcclxuICAgICAgICBpZiAoc2NvcmUgPD0gMykgcmV0dXJuICcjZWY0NDQ0JzsgLy8gcmVkLTUwMFxyXG4gICAgICAgIGlmIChzY29yZSA8PSA1KSByZXR1cm4gJyNmNTllMGInOyAvLyBhbWJlci01MDBcclxuICAgICAgICBpZiAoc2NvcmUgPD0gNykgcmV0dXJuICcjZmFjYzE1JzsgLy8geWVsbG93LTQwMFxyXG4gICAgICAgIGlmIChzY29yZSA8PSA5KSByZXR1cm4gJyM2NWEzMGQnOyAvLyBsaW1lLTYwMFxyXG4gICAgICAgIHJldHVybiAnIzE2YTM0YSc7IC8vIGdyZWVuLTYwMFxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgLy8gUmVmZXJlbmNlIHRoZSBvdXRlciBnZXRSb3V0ZUNvbG9yIGZ1bmN0aW9uIG9yIHJlZGVmaW5lIGl0IGhlcmVcclxuICAgICAgY29uc3QgZ2V0Um91dGVDb2xvckZvck1vZGUgPSAobW9kZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGdldFJvdXRlQ29sb3IobW9kZSk7XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyAwLiBCZXN0IE92ZXJhbGwgcm91dGVcclxuICAgICAgY29uc3QgYmVzdE92ZXJhbGxSb3V0ZTogUm91dGVJdGVtID0ge1xyXG4gICAgICAgIGlkOiAnMCcsXHJcbiAgICAgICAgbmFtZTogJ0Jlc3QgT3ZlcmFsbCBSb3V0ZScsXHJcbiAgICAgICAgZHVyYXRpb246IDAsXHJcbiAgICAgICAgY29zdDogMCxcclxuICAgICAgICBjb21mb3J0OiAnbWVkaXVtJyBhcyAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnLFxyXG4gICAgICAgIHZlY3RvclNjb3JlOiAwLjk1LFxyXG4gICAgICAgIHNlZ21lbnRzOiBbXSxcclxuICAgICAgICAvLyBBZGRpdGlvbmFsIGRldGFpbGVkIGluZm9ybWF0aW9uXHJcbiAgICAgICAgaGFzVG9wb2xvZ3lJbXBhY3Q6IGZhbHNlLFxyXG4gICAgICAgIG51bVRyYW5zZmVyczogMCxcclxuICAgICAgICB0cmFmZmljOiB7IGxldmVsOiAnbWVkaXVtJywgaW1wYWN0OiAxLjAgfSxcclxuICAgICAgICBldGE6ICcnLFxyXG4gICAgICAgIGNvc3RCcmVha2Rvd246IHsgXHJcbiAgICAgICAgICBmYXJlOiAwLCBcclxuICAgICAgICAgIGFkZGl0aW9uYWxGZWVzOiAwLFxyXG4gICAgICAgICAgdG90YWxDb3N0OiAwIFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NvcmVzOiB7XHJcbiAgICAgICAgICBvdmVyYWxsOiAwLFxyXG4gICAgICAgICAgdGltZTogMCxcclxuICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICBjb21mb3J0OiAwLFxyXG4gICAgICAgICAgdHJhbnNmZXJzOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb3V0ZUNvbG9yOiAnJyxcclxuICAgICAgICBwYXRoRGF0YTogW11cclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIEhlbHBlciB0byBjYWxjdWxhdGUgRVRBXHJcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZUVUQSA9IChkdXJhdGlvbk1pbnV0ZXM6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgY29uc3QgZXRhID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIGR1cmF0aW9uTWludXRlcyAqIDYwMDAwKTtcclxuICAgICAgICByZXR1cm4gZXRhLnRvTG9jYWxlVGltZVN0cmluZyhbXSwgeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgLy8gR2VuZXJhdGUgcGF0aCBkYXRhIGZvciBtYXAgdmlzdWFsaXphdGlvblxyXG4gICAgICBjb25zdCBnZW5lcmF0ZVBhdGhEYXRhID0gKHJvdXRlOiBhbnkpID0+IHtcclxuICAgICAgICBjb25zdCBwYXRoRGF0YTogYW55W10gPSBbXTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgbGFzdENvb3JkcyA9IGZyb21Db29yZHM7XHJcbiAgICAgICAgcm91dGUuc2VnbWVudHMuZm9yRWFjaCgoc2VnbWVudDogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gaW5kZXggPT09IHJvdXRlLnNlZ21lbnRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICBjb25zdCBlbmRDb29yZHMgPSBpc0xhc3RTZWdtZW50ID8gdG9Db29yZHMgOiBnZXRDb29yZGluYXRlcyhzZWdtZW50LmVuZExvY2F0aW9uKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gRm9yIGRpZmZlcmVudCB0cmFuc3BvcnQgbW9kZXMsIGdlbmVyYXRlIGRpZmZlcmVudCBwYXRoIHR5cGVzXHJcbiAgICAgICAgICBzd2l0Y2goc2VnbWVudC5tb2RlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N1YndheSc6XHJcbiAgICAgICAgICAgICAgLy8gU3Vid2F5IHJvdXRlcyBzaG91bGQgZm9sbG93IG1vc3RseSBzdHJhaWdodCBsaW5lcyB3aXRoIHNsaWdodCBjdXJ2ZXNcclxuICAgICAgICAgICAgICBwYXRoRGF0YS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdWJ3YXknLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGdldFJvdXRlQ29sb3JGb3JNb2RlKHNlZ21lbnQubW9kZSksXHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IFtcclxuICAgICAgICAgICAgICAgICAgbGFzdENvb3JkcyxcclxuICAgICAgICAgICAgICAgICAgLy8gQWRkIGEgbWlkcG9pbnQgd2l0aCBzbGlnaHQgb2Zmc2V0IGZvciBhIG5hdHVyYWwgY3VydmVcclxuICAgICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHNbMF0gKyAoZW5kQ29vcmRzWzBdIC0gbGFzdENvb3Jkc1swXSkgKiAwLjUgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHNbMV0gKyAoZW5kQ29vcmRzWzFdIC0gbGFzdENvb3Jkc1sxXSkgKiAwLjUgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAxXHJcbiAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgIGVuZENvb3Jkc1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdidXMnOlxyXG4gICAgICAgICAgICAgIC8vIEJ1cyByb3V0ZXMgc2hvdWxkIGZvbGxvdyBhIG1vcmUgemlnemFnIHN0cmVldC1saWtlIHBhdHRlcm5cclxuICAgICAgICAgICAgICBjb25zdCBudW1Qb2ludHMgPSBNYXRoLmNlaWwoY2FsY3VsYXRlRGlzdGFuY2UobGFzdENvb3Jkc1swXSwgbGFzdENvb3Jkc1sxXSwgZW5kQ29vcmRzWzBdLCBlbmRDb29yZHNbMV0pICogMik7XHJcbiAgICAgICAgICAgICAgY29uc3QgcG9pbnRzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbbGFzdENvb3Jkc107XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgcG9pbnRzIHRoYXQgemlnemFnIGxpa2UgY2l0eSBzdHJlZXRzXHJcbiAgICAgICAgICAgICAgbGV0IGN1cnJlbnRQb2ludDogW251bWJlciwgbnVtYmVyXSA9IFsuLi5sYXN0Q29vcmRzXSBhcyBbbnVtYmVyLCBudW1iZXJdO1xyXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIEFsdGVybmF0ZSBiZXR3ZWVuIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIG1vdmVtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgY3VycmVudFBvaW50ID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludFswXSxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRbMV0gKyAoZW5kQ29vcmRzWzFdIC0gY3VycmVudFBvaW50WzFdKSAqIDAuM1xyXG4gICAgICAgICAgICAgICAgICBdIGFzIFtudW1iZXIsIG51bWJlcl07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnQgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvaW50WzBdICsgKGVuZENvb3Jkc1swXSAtIGN1cnJlbnRQb2ludFswXSkgKiAwLjMsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvaW50WzFdXHJcbiAgICAgICAgICAgICAgICAgIF0gYXMgW251bWJlciwgbnVtYmVyXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN1cnJlbnRQb2ludCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHBvaW50cy5wdXNoKGVuZENvb3Jkcyk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgcGF0aERhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnVzJyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBnZXRSb3V0ZUNvbG9yRm9yTW9kZShzZWdtZW50Lm1vZGUpLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3dhbGsnOlxyXG4gICAgICAgICAgICAgIC8vIFdhbGtpbmcgc2hvdWxkIGJlIGEgcmVsYXRpdmVseSBkaXJlY3QgcGF0aFxyXG4gICAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGdldFJvdXRlQ29sb3JGb3JNb2RlKHNlZ21lbnQubW9kZSksXHJcbiAgICAgICAgICAgICAgICBkYXNoQXJyYXk6ICc0LDQnLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXHJcbiAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHMsXHJcbiAgICAgICAgICAgICAgICAgIGVuZENvb3Jkc1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd1YmVyJzpcclxuICAgICAgICAgICAgY2FzZSAndGF4aSc6XHJcbiAgICAgICAgICAgICAgLy8gQ2FyIHJvdXRlcyBmb2xsb3cgc3RyZWV0cyBidXQgbW9yZSBkaXJlY3QgdGhhbiBidXNlc1xyXG4gICAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogc2VnbWVudC5tb2RlLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGdldFJvdXRlQ29sb3JGb3JNb2RlKHNlZ21lbnQubW9kZSksXHJcbiAgICAgICAgICAgICAgICBwb2ludHM6IFtcclxuICAgICAgICAgICAgICAgICAgbGFzdENvb3JkcyxcclxuICAgICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHNbMF0gKyAoZW5kQ29vcmRzWzBdIC0gbGFzdENvb3Jkc1swXSkgKiAwLjMzLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHNbMV0gKyAoZW5kQ29vcmRzWzFdIC0gbGFzdENvb3Jkc1sxXSkgKiAwLjY2XHJcbiAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzWzBdICsgKGVuZENvb3Jkc1swXSAtIGxhc3RDb29yZHNbMF0pICogMC42NixcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzWzFdICsgKGVuZENvb3Jkc1sxXSAtIGxhc3RDb29yZHNbMV0pICogMC4zM1xyXG4gICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICBlbmRDb29yZHNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZWJpa2UnOlxyXG4gICAgICAgICAgICAgIC8vIEJpa2Ugcm91dGVzIHNob3VsZCBmb2xsb3cgc3RyZWV0cyBidXQgbWlnaHQgdGFrZSBzaG9ydGN1dHNcclxuICAgICAgICAgICAgICBwYXRoRGF0YS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdlYmlrZScsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0Um91dGVDb2xvckZvck1vZGUoc2VnbWVudC5tb2RlKSxcclxuICAgICAgICAgICAgICAgIHBvaW50czogW1xyXG4gICAgICAgICAgICAgICAgICBsYXN0Q29vcmRzLFxyXG4gICAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvb3Jkc1swXSArIChlbmRDb29yZHNbMF0gLSBsYXN0Q29vcmRzWzBdKSAqIDAuNSArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMDA1LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb29yZHNbMV0gKyAoZW5kQ29vcmRzWzFdIC0gbGFzdENvb3Jkc1sxXSkgKiAwLjUgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAwNVxyXG4gICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICBlbmRDb29yZHNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAvLyBEZWZhdWx0IGRpcmVjdCBsaW5lXHJcbiAgICAgICAgICAgICAgcGF0aERhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBzZWdtZW50Lm1vZGUsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0Um91dGVDb2xvckZvck1vZGUoc2VnbWVudC5tb2RlKSxcclxuICAgICAgICAgICAgICAgIHBvaW50czogW2xhc3RDb29yZHMsIGVuZENvb3Jkc11cclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgbGFzdENvb3JkcyA9IGVuZENvb3JkcztcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcGF0aERhdGE7XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBQcm9jZXNzIGEgY29tcGxldGVkIHJvdXRlIHdpdGggYWxsIGRldGFpbGVkIGluZm9ybWF0aW9uXHJcbiAgICAgIGNvbnN0IGZpbmFsaXplUm91dGUgPSAocm91dGU6IGFueSkgPT4ge1xyXG4gICAgICAgIC8vIENvdW50IHRyYW5zZmVycyAoc2VnbWVudHMgdGhhdCBjaGFuZ2UgbW9kZSBvZiB0cmFuc3BvcnRhdGlvbilcclxuICAgICAgICBjb25zdCBudW1UcmFuc2ZlcnMgPSByb3V0ZS5zZWdtZW50cy5sZW5ndGggPiAwID8gcm91dGUuc2VnbWVudHMubGVuZ3RoIC0gMSA6IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgcm91dGUgaGFzIHdhbGtpbmcvYmlraW5nIGNvbXBvbmVudHMgdG8gY29uc2lkZXIgdG9wb2xvZ3lcclxuICAgICAgICBjb25zdCBoYXNUb3BvbG9neUltcGFjdCA9IHJvdXRlLnNlZ21lbnRzLnNvbWUoKHNlZ21lbnQ6IGFueSkgPT4gXHJcbiAgICAgICAgICBzZWdtZW50Lm1vZGUgPT09ICd3YWxrJyB8fCBzZWdtZW50Lm1vZGUgPT09ICdlYmlrZSdcclxuICAgICAgICApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0cmFmZmljIGltcGFjdCBmb3Igcm9hZC1iYXNlZCBzZWdtZW50c1xyXG4gICAgICAgIGNvbnN0IHJvYWRCYXNlZFNlZ21lbnRzID0gcm91dGUuc2VnbWVudHMuZmlsdGVyKChzZWdtZW50OiBhbnkpID0+IFxyXG4gICAgICAgICAgc2VnbWVudC5tb2RlID09PSAnYnVzJyB8fCBzZWdtZW50Lm1vZGUgPT09ICd1YmVyJyB8fCBzZWdtZW50Lm1vZGUgPT09ICd0YXhpJ1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgdHJhZmZpY0ltcGFjdCA9IHJvYWRCYXNlZFNlZ21lbnRzLmxlbmd0aCA+IDAgPyBhdmdUcmFmZmljRmFjdG9yIDogMS4wO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGVlbGNoYWlyIGFjY2Vzc2liaWxpdHlcclxuICAgICAgICBjb25zdCBpc1doZWVsY2hhaXJBY2Nlc3NpYmxlID0gcm91dGUuc2VnbWVudHMuZXZlcnkoKHNlZ21lbnQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgaWYgKHNlZ21lbnQubW9kZSA9PT0gJ3dhbGsnKSByZXR1cm4gdHJ1ZTsgLy8gV2Fsa2luZyBpcyBhbHdheXMgYWNjZXNzaWJsZVxyXG4gICAgICAgICAgaWYgKHNlZ21lbnQubW9kZSA9PT0gJ3N1YndheScpIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNwZWNpZmljIHN0YXRpb24gaXMgYWNjZXNzaWJsZSAtIGluIGEgcmVhbCBhcHAgdGhpcyB3b3VsZCBjaGVjayBhY3R1YWwgc3RhdGlvbiBkYXRhXHJcbiAgICAgICAgICAgIC8vIEZvciBub3cgd2UnbGwgZXN0aW1hdGUgdGhhdCA0MCUgb2Ygc3Vid2F5IHNlZ21lbnRzIGFyZSB3aGVlbGNoYWlyIGFjY2Vzc2libGVcclxuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQuaGFzT3duUHJvcGVydHkoJ3doZWVsY2hhaXJBY2Nlc3NpYmxlJykgPyBzZWdtZW50LndoZWVsY2hhaXJBY2Nlc3NpYmxlIDogTWF0aC5yYW5kb20oKSA+IDAuNjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzZWdtZW50Lm1vZGUgPT09ICdidXMnKSB7XHJcbiAgICAgICAgICAgIC8vIE1vc3QgYnVzZXMgYXJlIGFjY2Vzc2libGVcclxuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQuaGFzT3duUHJvcGVydHkoJ3doZWVsY2hhaXJBY2Nlc3NpYmxlJykgPyBzZWdtZW50LndoZWVsY2hhaXJBY2Nlc3NpYmxlIDogTWF0aC5yYW5kb20oKSA+IDAuMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzZWdtZW50Lm1vZGUgPT09ICd1YmVyJyB8fCBzZWdtZW50Lm1vZGUgPT09ICd0YXhpJykge1xyXG4gICAgICAgICAgICAvLyBTb21lIHRheGlzL3ViZXJzIGFyZSB3aGVlbGNoYWlyIGFjY2Vzc2libGVcclxuICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQuaGFzT3duUHJvcGVydHkoJ3doZWVsY2hhaXJBY2Nlc3NpYmxlJykgPyBzZWdtZW50LndoZWVsY2hhaXJBY2Nlc3NpYmxlIDogTWF0aC5yYW5kb20oKSA+IDAuNztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDYWxjdWxhdGUgY29zdCBicmVha2Rvd25cclxuICAgICAgICBjb25zdCBjb3N0QnJlYWtkb3duID0ge1xyXG4gICAgICAgICAgZmFyZTogcm91dGUuc2VnbWVudHMucmVkdWNlKCh0b3RhbDogbnVtYmVyLCBzZWdtZW50OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgLy8gT25seSBjb3VudCBwb3NpdGl2ZSBjb3N0cyAoZS5nLiwgZXhjbHVkZSBmcmVlIHRyYW5zZmVycylcclxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsICsgKHNlZ21lbnQuY29zdCA+IDAgPyBzZWdtZW50LmNvc3QgOiAwKTtcclxuICAgICAgICAgIH0sIDApLFxyXG4gICAgICAgICAgYWRkaXRpb25hbEZlZXM6IDAsXHJcbiAgICAgICAgICB0b3RhbENvc3Q6IHJvdXRlLmNvc3RcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBmZWVzIGZvciBVYmVyL1RheGkgZHVyaW5nIGhpZ2ggdHJhZmZpY1xyXG4gICAgICAgIGlmIChyb2FkQmFzZWRTZWdtZW50cy5sZW5ndGggPiAwICYmIHRyYWZmaWNJbXBhY3QgPiAxLjIpIHtcclxuICAgICAgICAgIGNvc3RCcmVha2Rvd24uYWRkaXRpb25hbEZlZXMgPSBwYXJzZUZsb2F0KChjb3N0QnJlYWtkb3duLmZhcmUgKiAwLjE1KS50b0ZpeGVkKDIpKTtcclxuICAgICAgICAgIGNvc3RCcmVha2Rvd24udG90YWxDb3N0ID0gcGFyc2VGbG9hdCgoY29zdEJyZWFrZG93bi5mYXJlICsgY29zdEJyZWFrZG93bi5hZGRpdGlvbmFsRmVlcykudG9GaXhlZCgyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSByb3V0ZSBzY29yZXNcclxuICAgICAgICBjb25zdCBzY29yZXMgPSBjYWxjdWxhdGVCYWxhbmNlZFNjb3JlKFxyXG4gICAgICAgICAgcm91dGUuZHVyYXRpb24sIFxyXG4gICAgICAgICAgY29zdEJyZWFrZG93bi50b3RhbENvc3QsIFxyXG4gICAgICAgICAgcm91dGUuY29tZm9ydCwgXHJcbiAgICAgICAgICBudW1UcmFuc2ZlcnMsXHJcbiAgICAgICAgICB1c2VyQmFncyA+IDAsXHJcbiAgICAgICAgICBoYXNUb3BvbG9neUltcGFjdCxcclxuICAgICAgICAgIHRyYWZmaWNJbXBhY3QsXHJcbiAgICAgICAgICBpc1doZWVsY2hhaXJBY2Nlc3NpYmxlXHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDYWxjdWxhdGUgRVRBXHJcbiAgICAgICAgY29uc3QgZXRhID0gY2FsY3VsYXRlRVRBKE1hdGgucm91bmQocm91dGUuZHVyYXRpb24gKiB0cmFmZmljSW1wYWN0KSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gR2VuZXJhdGUgcm91dGUgY29sb3IgYmFzZWQgb24gb3ZlcmFsbCBzY29yZVxyXG4gICAgICAgIGNvbnN0IHJvdXRlQ29sb3IgPSBnZXRSb3V0ZUNvbG9yRnJvbVNjb3JlKHNjb3Jlcy5zY29yZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIENPMiBlbWlzc2lvbnMgZm9yIHRoZSBlbnRpcmUgcm91dGVcclxuICAgICAgICBsZXQgdG90YWxDTzIgPSAwO1xyXG4gICAgICAgIHJvdXRlLnNlZ21lbnRzLmZvckVhY2goKHNlZ21lbnQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHNlZ21lbnQgZGlzdGFuY2UgaW4ga21cclxuICAgICAgICAgIGNvbnN0IHNlZ21lbnREaXN0YW5jZSA9IHNlZ21lbnQuZGlzdGFuY2UgfHwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjYWxjdWxhdGVEaXN0YW5jZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tQ29vcmRzWzBdLCBmcm9tQ29vcmRzWzFdLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0Nvb3Jkc1swXSwgdG9Db29yZHNbMV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSAqIDEuNSk7IC8vIFVzZSBhIG11bHRpcGxpZXIgdG8gYWNjb3VudCBmb3Igbm9uLWRpcmVjdCByb3V0ZXNcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIENPMiBmb3IgdGhpcyBzZWdtZW50XHJcbiAgICAgICAgICBjb25zdCBzZWdtZW50Q08yID0gY2FsY3VsYXRlQ08yRW1pc3Npb25zKHNlZ21lbnQubW9kZSwgc2VnbWVudERpc3RhbmNlKTtcclxuICAgICAgICAgIHNlZ21lbnQuY28yID0gc2VnbWVudENPMjtcclxuICAgICAgICAgIHRvdGFsQ08yICs9IHNlZ21lbnRDTzI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2V0IHRvdGFsIENPMiBmb3IgdGhlIHJvdXRlXHJcbiAgICAgICAgcm91dGUuY28yID0gdG90YWxDTzI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gR2VuZXJhdGUgcGF0aCBkYXRhIGZvciBtYXBcclxuICAgICAgICBjb25zdCBwYXRoRGF0YSA9IGdlbmVyYXRlUGF0aERhdGEocm91dGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBkZXRhaWxlZCBpbmZvcm1hdGlvbiB0byByb3V0ZVxyXG4gICAgICAgIHJvdXRlLm51bVRyYW5zZmVycyA9IG51bVRyYW5zZmVycztcclxuICAgICAgICByb3V0ZS5oYXNUb3BvbG9neUltcGFjdCA9IGhhc1RvcG9sb2d5SW1wYWN0O1xyXG4gICAgICAgIHJvdXRlLnRyYWZmaWMgPSB7IFxyXG4gICAgICAgICAgbGV2ZWw6IHRyYWZmaWNJbXBhY3QgPiAxLjMgPyAnaGlnaCcgOiB0cmFmZmljSW1wYWN0ID4gMS4xID8gJ21lZGl1bScgOiAnbG93JyxcclxuICAgICAgICAgIGltcGFjdDogdHJhZmZpY0ltcGFjdFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcm91dGUuZXRhID0gZXRhO1xyXG4gICAgICAgIHJvdXRlLmNvc3RCcmVha2Rvd24gPSBjb3N0QnJlYWtkb3duO1xyXG4gICAgICAgIHJvdXRlLnNjb3JlcyA9IHNjb3JlcztcclxuICAgICAgICByb3V0ZS5yb3V0ZUNvbG9yID0gcm91dGVDb2xvcjtcclxuICAgICAgICByb3V0ZS5wYXRoRGF0YSA9IHBhdGhEYXRhO1xyXG4gICAgICAgIHJvdXRlLmlzV2hlZWxjaGFpckFjY2Vzc2libGUgPSBpc1doZWVsY2hhaXJBY2Nlc3NpYmxlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEVuaGFuY2Ugc2VnbWVudHMgd2l0aCBzY29yZXNcclxuICAgICAgICByb3V0ZS5zZWdtZW50cy5mb3JFYWNoKChzZWdtZW50OiBhbnkpID0+IHtcclxuICAgICAgICAgIC8vIFNjb3JlIGVhY2ggc2VnbWVudCBiYXNlZCBvbiBtb2RlIGFuZCBjb25kaXRpb25zXHJcbiAgICAgICAgICBjb25zdCBzZWdtZW50U2NvcmUgPSBzZWdtZW50Lm1vZGUgPT09ICd3YWxrJyAmJiBoYXNUb3BvbG9neUltcGFjdCA/IFxyXG4gICAgICAgICAgICBNYXRoLm1heCgzLCA3IC0gTWF0aC5mbG9vcihhdmdUb3BvbG9neURpZmZpY3VsdHkgKiAxMCkpIDogLy8gV2Fsa2luZyBzY29yZSBhZmZlY3RlZCBieSBoaWxsc1xyXG4gICAgICAgICAgICBzZWdtZW50Lm1vZGUgPT09ICdlYmlrZScgJiYgaGFzVG9wb2xvZ3lJbXBhY3QgP1xyXG4gICAgICAgICAgICBNYXRoLm1heCgyLCA2IC0gTWF0aC5mbG9vcihhdmdUb3BvbG9neURpZmZpY3VsdHkgKiAxMCkpIDogLy8gRS1iaWtlIHNjb3JlIGFmZmVjdGVkIGJ5IGhpbGxzXHJcbiAgICAgICAgICAgIHNlZ21lbnQubW9kZSA9PT0gJ2J1cycgfHwgc2VnbWVudC5tb2RlID09PSAndWJlcicgfHwgc2VnbWVudC5tb2RlID09PSAndGF4aScgP1xyXG4gICAgICAgICAgICBNYXRoLm1heCgyLCA5IC0gTWF0aC5mbG9vcigodHJhZmZpY0ltcGFjdCAtIDEpICogMTApKSA6IC8vIFJvYWQgdHJhbnNwb3J0IGFmZmVjdGVkIGJ5IHRyYWZmaWNcclxuICAgICAgICAgICAgNzsgLy8gRGVmYXVsdCByZWFzb25hYmxlIHNjb3JlXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgc2VnbWVudC5zY29yZSA9IHNlZ21lbnRTY29yZTtcclxuICAgICAgICAgIHNlZ21lbnQuYWRqdXN0ZWREdXJhdGlvbiA9IHNlZ21lbnQubW9kZSA9PT0gJ3dhbGsnICYmIGhhc1RvcG9sb2d5SW1wYWN0ID8gXHJcbiAgICAgICAgICAgIE1hdGgucm91bmQoc2VnbWVudC5kdXJhdGlvbiAqICgxICsgYXZnVG9wb2xvZ3lEaWZmaWN1bHR5KSkgOiAvLyBXYWxraW5nIGlzIHNsb3dlciBpbiBoaWxseSBhcmVhc1xyXG4gICAgICAgICAgICAoc2VnbWVudC5tb2RlID09PSAnYnVzJyB8fCBzZWdtZW50Lm1vZGUgPT09ICd1YmVyJyB8fCBzZWdtZW50Lm1vZGUgPT09ICd0YXhpJykgP1xyXG4gICAgICAgICAgICBNYXRoLnJvdW5kKHNlZ21lbnQuZHVyYXRpb24gKiB0cmFmZmljSW1wYWN0KSA6IC8vIFRyYWZmaWMgYWZmZWN0cyByb2FkIHRyYW5zcG9ydFxyXG4gICAgICAgICAgICBzZWdtZW50LmR1cmF0aW9uOyAvLyBObyBhZGp1c3RtZW50IGZvciBzdWJ3YXlcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcm91dGU7XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBEZWNpZGUgb24gdGhlIGJlc3Qgb3ZlcmFsbCByb3V0ZSBiYXNlZCBvbiBkaXN0YW5jZVxyXG4gICAgICBpZiAoZGlzdGFuY2UgPCAxKSB7XHJcbiAgICAgICAgLy8gVmVyeSBzaG9ydCBkaXN0YW5jZSAtIHdhbGtpbmcgbWlnaHQgYmUgYmVzdFxyXG4gICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICBtb2RlOiAnd2FsaycsXHJcbiAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcclxuICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXHJcbiAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDIwKSwgLy8gMjAgbWluIHBlciBtaWxlIHdhbGtpbmdcclxuICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gZGVzdGluYXRpb24nLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJlc3RPdmVyYWxsUm91dGUuZHVyYXRpb24gPSBNYXRoLnJvdW5kKGRpc3RhbmNlICogMjApO1xyXG4gICAgICAgIGJlc3RPdmVyYWxsUm91dGUuY29tZm9ydCA9ICdoaWdoJztcclxuICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZSA8IDUgJiYgKGJlc3RTdWJ3YXlMaW5lIHx8IGNvbm5lY3RpbmdCdXNlcy5sZW5ndGggPiAwKSkge1xyXG4gICAgICAgIC8vIE1lZGl1bSBkaXN0YW5jZSB3aXRoIHRyYW5zaXQgb3B0aW9uc1xyXG4gICAgICAgIC8vIEZpcnN0IHNlZ21lbnQgLSB3YWxrIHRvIHN0YXRpb25cclxuICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXHJcbiAgICAgICAgICBlbmRMb2NhdGlvbjogYmVzdFN1YndheUxpbmUgPyBgU3Vid2F5IFN0YXRpb24gbmVhciAke2Zyb219YCA6IGBCdXMgU3RvcCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgZHVyYXRpb246IDUsXHJcbiAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgbGluZUluZm86IGBXYWxrIHRvICR7YmVzdFN1YndheUxpbmUgPyAnc3RhdGlvbicgOiAnYnVzIHN0b3AnfWAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2Vjb25kIHNlZ21lbnQgLSB0cmFuc2l0XHJcbiAgICAgICAgaWYgKGJlc3RTdWJ3YXlMaW5lKSB7XHJcbiAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICBtb2RlOiAnc3Vid2F5JyxcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke3RvfWAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogOCksXHJcbiAgICAgICAgICAgIGNvc3Q6IDIuNzUsXHJcbiAgICAgICAgICAgIGxpbmVJbmZvOiBgJHtiZXN0U3Vid2F5TGluZX0gVHJhaW4ke2Jlc3RTdWJ3YXlMaW5lID09PSAnNycgPyAnIChGbHVzaGluZyBMaW5lKScgOiAnJ31gLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIG1vZGU6ICdidXMnLFxyXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgQnVzIFN0b3AgbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgZW5kTG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxMCksXHJcbiAgICAgICAgICAgIGNvc3Q6IDIuNzUsXHJcbiAgICAgICAgICAgIGxpbmVJbmZvOiBgJHtidXNSb3V0ZX0gQnVzYCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBMYXN0IHNlZ21lbnQgLSB3YWxrIHRvIGRlc3RpbmF0aW9uXHJcbiAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGJlc3RTdWJ3YXlMaW5lID8gYFN1YndheSBTdGF0aW9uIG5lYXIgJHt0b31gIDogYEJ1cyBTdG9wIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcclxuICAgICAgICAgIGR1cmF0aW9uOiA1LFxyXG4gICAgICAgICAgY29zdDogMCxcclxuICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBkZXN0aW5hdGlvbicsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5kdXJhdGlvbiA9IGJlc3RTdWJ3YXlMaW5lIFxyXG4gICAgICAgICAgPyBNYXRoLnJvdW5kKGRpc3RhbmNlICogOCkgKyAxMCAvLyBTdWJ3YXkgdGltZSArIHdhbGtpbmdcclxuICAgICAgICAgIDogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEwKSArIDEwOyAvLyBCdXMgdGltZSArIHdhbGtpbmdcclxuICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmNvc3QgPSAyLjc1O1xyXG4gICAgICAgIGJlc3RPdmVyYWxsUm91dGUuY29tZm9ydCA9IGJlc3RTdWJ3YXlMaW5lID8gJ21lZGl1bScgOiAnbG93JztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBMb25nZXIgZGlzdGFuY2Ugb3Igbm8gZ29vZCB0cmFuc2l0IC0gbWl4ZWQgbW9kZSBtaWdodCBiZSBiZXN0XHJcbiAgICAgICAgLy8gU3RhcnQgd2l0aCB0cmFuc2l0IGlmIGF2YWlsYWJsZSBmb3IgbW9zdCBvZiB0aGUgcm91dGVcclxuICAgICAgICBpZiAoYmVzdFN1YndheUxpbmUgfHwgaGFzVHJhbnNmZXJPcHRpb25zKSB7XHJcbiAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICBtb2RlOiAnd2FsaycsXHJcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1LFxyXG4gICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gc3RhdGlvbicsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGJlc3RTdWJ3YXlMaW5lKSB7XHJcbiAgICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgbW9kZTogJ3N1YndheScsXHJcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDcpLFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDIuNzUsXHJcbiAgICAgICAgICAgICAgbGluZUluZm86IGAke2Jlc3RTdWJ3YXlMaW5lfSBUcmFpbiR7YmVzdFN1YndheUxpbmUgPT09ICc3JyA/ICcgKEZsdXNoaW5nIExpbmUpJyA6ICcnfWAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVXNlIHRyYW5zZmVyIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICBjb25zdCBmcm9tTGluZSA9IGZyb21TdWJ3YXlMaW5lc1swXTtcclxuICAgICAgICAgICAgY29uc3QgdG9MaW5lID0gdG9TdWJ3YXlMaW5lc1swXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgbW9kZTogJ3N1YndheScsXHJcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246ICdUcmFuc2ZlciBTdGF0aW9uJyxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDQpLFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDIuNzUsXHJcbiAgICAgICAgICAgICAgbGluZUluZm86IGAke2Zyb21MaW5lfSBUcmFpbmAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICBtb2RlOiAnc3Vid2F5JyxcclxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiAnVHJhbnNmZXIgU3RhdGlvbicsXHJcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDQpLFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgICAgbGluZUluZm86IGAke3RvTGluZX0gVHJhaW5gLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gRm9yIGxvbmdlciBkaXN0YW5jZXMsIHVzZSBVYmVyIGZvciB0aGUgbGFzdCBtaWxlXHJcbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiA4KSB7XHJcbiAgICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgbW9kZTogJ3ViZXInLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA4LFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDcuNTAsXHJcbiAgICAgICAgICAgICAgbGluZUluZm86ICdVYmVyWCAobGFzdCBtaWxlKScsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5kdXJhdGlvbiA9IE1hdGgucm91bmQoZGlzdGFuY2UgKiA2KSArIDEzOyAvLyBUcmFuc2l0ICsgdWJlciArIGluaXRpYWwgd2Fsa1xyXG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmNvc3QgPSAxMC4yNTsgLy8gU3Vid2F5ICsgdWJlclxyXG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmNvbWZvcnQgPSAnaGlnaCc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke3RvfWAsXHJcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcclxuICAgICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBkZXN0aW5hdGlvbicsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5kdXJhdGlvbiA9IGJlc3RTdWJ3YXlMaW5lIFxyXG4gICAgICAgICAgICAgID8gTWF0aC5yb3VuZChkaXN0YW5jZSAqIDcpICsgMTAgLy8gU3Vid2F5IHRpbWUgKyB3YWxraW5nXHJcbiAgICAgICAgICAgICAgOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogOCkgKyAxMDsgLy8gVHJhbnNmZXIgc3Vid2F5IHRpbWUgKyB3YWxraW5nXHJcbiAgICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuY29zdCA9IDIuNzU7XHJcbiAgICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuY29tZm9ydCA9ICdtZWRpdW0nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBObyBnb29kIHRyYW5zaXQgb3B0aW9uIC0gdXNlIFViZXIgZm9yIGVmZmljaWVuY3lcclxuICAgICAgICAgIGJlc3RPdmVyYWxsUm91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgUGlja3VwIFBvaW50IG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzLFxyXG4gICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gcGlja3VwIHBvaW50JyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICBtb2RlOiAndWJlcicsXHJcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBQaWNrdXAgUG9pbnQgbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA4KSxcclxuICAgICAgICAgICAgY29zdDogcGFyc2VGbG9hdCgoZGlzdGFuY2UgKiAyLjI1KS50b0ZpeGVkKDIpKSxcclxuICAgICAgICAgICAgbGluZUluZm86ICdVYmVyWCcsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5kdXJhdGlvbiA9IE1hdGgucm91bmQoZGlzdGFuY2UgKiA4KSArIDM7XHJcbiAgICAgICAgICBiZXN0T3ZlcmFsbFJvdXRlLmNvc3QgPSBwYXJzZUZsb2F0KChkaXN0YW5jZSAqIDIuMjUpLnRvRml4ZWQoMikpO1xyXG4gICAgICAgICAgYmVzdE92ZXJhbGxSb3V0ZS5jb21mb3J0ID0gJ2hpZ2gnO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcm91dGVzLnB1c2goYmVzdE92ZXJhbGxSb3V0ZSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyAxLiBJZiBzdWJ3YXkgaXMgYXZhaWxhYmxlLCBjcmVhdGUgYSBzdWJ3YXkgcm91dGVcclxuICAgICAgaWYgKGJlc3RTdWJ3YXlMaW5lIHx8IGhhc1RyYW5zZmVyT3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHN1YndheVJvdXRlOiBSb3V0ZUl0ZW0gPSB7XHJcbiAgICAgICAgICBpZDogcm91dGVzLmxlbmd0aCArICcnLFxyXG4gICAgICAgICAgbmFtZTogJ0Zhc3Rlc3QgUm91dGUnLFxyXG4gICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxMCksXHJcbiAgICAgICAgICBjb3N0OiBwYXJzZUZsb2F0KCgyLjc1ICsgKGRpc3RhbmNlID4gNSA/IDMgOiAwKSkudG9GaXhlZCgyKSksXHJcbiAgICAgICAgICBjb21mb3J0OiBkaXN0YW5jZSA8IDggPyAnbWVkaXVtJyA6ICdsb3cnLFxyXG4gICAgICAgICAgdmVjdG9yU2NvcmU6IDAuODksXHJcbiAgICAgICAgICBzZWdtZW50czogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcclxuICAgICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiBgV2FsayB0byBzdGF0aW9uYCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCB0aGUgc3Vid2F5IHNlZ21lbnQocylcclxuICAgICAgICBpZiAoYmVzdFN1YndheUxpbmUpIHtcclxuICAgICAgICAgIC8vIERpcmVjdCBzdWJ3YXkgbGluZVxyXG4gICAgICAgICAgc3Vid2F5Um91dGUuc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIG1vZGU6ICdzdWJ3YXknLFxyXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgU3Vid2F5IFN0YXRpb24gbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgZW5kTG9jYXRpb246IGBTdWJ3YXkgU3RhdGlvbiBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA4KSxcclxuICAgICAgICAgICAgY29zdDogMi43NSxcclxuICAgICAgICAgICAgbGluZUluZm86IGAke2Jlc3RTdWJ3YXlMaW5lfSBUcmFpbiR7YmVzdFN1YndheUxpbmUgPT09ICc3JyA/ICcgKEZsdXNoaW5nIExpbmUpJyA6ICcnfWAsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGhhc1RyYW5zZmVyT3B0aW9ucykge1xyXG4gICAgICAgICAgLy8gTmVlZCBhIHRyYW5zZmVyXHJcbiAgICAgICAgICBjb25zdCBmcm9tTGluZSA9IGZyb21TdWJ3YXlMaW5lc1swXTtcclxuICAgICAgICAgIGNvbnN0IHRvTGluZSA9IHRvU3Vid2F5TGluZXNbMF07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHN1YndheVJvdXRlLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICBtb2RlOiAnc3Vid2F5JyxcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgVHJhbnNmZXIgU3RhdGlvbmAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogNCksXHJcbiAgICAgICAgICAgIGNvc3Q6IDIuNzUsXHJcbiAgICAgICAgICAgIGxpbmVJbmZvOiBgJHtmcm9tTGluZX0gVHJhaW5gLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHN1YndheVJvdXRlLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICBtb2RlOiAnc3Vid2F5JyxcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFRyYW5zZmVyIFN0YXRpb25gLFxyXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDQpLFxyXG4gICAgICAgICAgICBjb3N0OiAwLCAvLyBGcmVlIHRyYW5zZmVyXHJcbiAgICAgICAgICAgIGxpbmVJbmZvOiBgJHt0b0xpbmV9IFRyYWluYCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBBZGQgdGhlIGZpbmFsIHdhbGtpbmcgc2VnbWVudFxyXG4gICAgICAgIHN1YndheVJvdXRlLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFN1YndheSBTdGF0aW9uIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcclxuICAgICAgICAgIGR1cmF0aW9uOiA3LFxyXG4gICAgICAgICAgY29zdDogMCxcclxuICAgICAgICAgIGxpbmVJbmZvOiBgV2FsayB0byBkZXN0aW5hdGlvbmAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcm91dGVzLnB1c2goc3Vid2F5Um91dGUpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyAyLiBBbHdheXMgY3JlYXRlIGEgcmlkZS1zaGFyaW5nIHJvdXRlIGFzIGFuIG9wdGlvblxyXG4gICAgICBjb25zdCB1YmVyUm91dGU6IFJvdXRlSXRlbSA9IHtcclxuICAgICAgICBpZDogcm91dGVzLmxlbmd0aCArICcnLFxyXG4gICAgICAgIG5hbWU6ICdNb3N0IENvbWZvcnRhYmxlIFJvdXRlJyxcclxuICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEyKSxcclxuICAgICAgICBjb3N0OiBwYXJzZUZsb2F0KChkaXN0YW5jZSAqIDIuNSkudG9GaXhlZCgyKSksXHJcbiAgICAgICAgY29tZm9ydDogJ2hpZ2gnLFxyXG4gICAgICAgIHZlY3RvclNjb3JlOiAwLjc4LFxyXG4gICAgICAgIHNlZ21lbnRzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgUGlja3VwIFBvaW50IG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzLFxyXG4gICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gcGlja3VwIHBvaW50JyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG1vZGU6ICd1YmVyJyxcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFBpY2t1cCBQb2ludCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYERyb3Atb2ZmIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEwKSxcclxuICAgICAgICAgICAgY29zdDogcGFyc2VGbG9hdCgoZGlzdGFuY2UgKiAyLjUpLnRvRml4ZWQoMikpLFxyXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1ViZXJYJyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYERyb3Atb2ZmIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogNCxcclxuICAgICAgICAgICAgY29zdDogMCxcclxuICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGRlc3RpbmF0aW9uJyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfTtcclxuICAgICAgcm91dGVzLnB1c2godWJlclJvdXRlKTtcclxuXHJcbiAgICAgIC8vIEFkZCBhIHRheGkgcm91dGUgb3B0aW9uXHJcbiAgICAgIGNvbnN0IHRheGlSb3V0ZTogUm91dGVJdGVtID0ge1xyXG4gICAgICAgIGlkOiByb3V0ZXMubGVuZ3RoICsgJycsXHJcbiAgICAgICAgbmFtZTogJ1RheGkgUm91dGUnLFxyXG4gICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTEpLFxyXG4gICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi44KS50b0ZpeGVkKDIpKSxcclxuICAgICAgICBjb21mb3J0OiAnaGlnaCcsXHJcbiAgICAgICAgdmVjdG9yU2NvcmU6IDAuNzcsXHJcbiAgICAgICAgc2VnbWVudHM6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgZW5kTG9jYXRpb246IGBUYXhpIFN0YW5kIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiA0LFxyXG4gICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gdGF4aSBzdGFuZCcsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBtb2RlOiAndGF4aScsXHJcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBUYXhpIFN0YW5kIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogOSksXHJcbiAgICAgICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi44KS50b0ZpeGVkKDIpKSxcclxuICAgICAgICAgICAgbGluZUluZm86ICdOWUMgVGF4aScsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgfTtcclxuICAgICAgcm91dGVzLnB1c2godGF4aVJvdXRlKTtcclxuXHJcbiAgICAgIC8vIEFkZCBhbiBFLWJpa2Ugcm91dGUgb3B0aW9uIGlmIHRoZSBkaXN0YW5jZSBpcyB1bmRlciAxMCBtaWxlc1xyXG4gICAgICBpZiAoZGlzdGFuY2UgPCAxMCkge1xyXG4gICAgICAgIGNvbnN0IGViaWtlUm91dGU6IFJvdXRlSXRlbSA9IHtcclxuICAgICAgICAgIGlkOiByb3V0ZXMubGVuZ3RoICsgJycsXHJcbiAgICAgICAgICBuYW1lOiAnRS1CaWtlIFJvdXRlJyxcclxuICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTUpLFxyXG4gICAgICAgICAgY29zdDogNS4wMCxcclxuICAgICAgICAgIGNvbWZvcnQ6ICdtZWRpdW0nLFxyXG4gICAgICAgICAgdmVjdG9yU2NvcmU6IDAuNzIsXHJcbiAgICAgICAgICBzZWdtZW50czogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgRS1CaWtlIFN0YXRpb24gbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcclxuICAgICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBlLWJpa2Ugc3RhdGlvbicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBtb2RlOiAnZWJpa2UnLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBFLUJpa2UgU3RhdGlvbiBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgRS1CaWtlIFN0YXRpb24gbmVhciAke3RvfWAsXHJcbiAgICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxMiksXHJcbiAgICAgICAgICAgICAgY29zdDogNS4wMCxcclxuICAgICAgICAgICAgICBsaW5lSW5mbzogJ0NpdGkgQmlrZSBFLUJpa2UnLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBFLUJpa2UgU3RhdGlvbiBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA1LFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGRlc3RpbmF0aW9uJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICByb3V0ZXMucHVzaChlYmlrZVJvdXRlKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gMy4gVHJ5IHRvIGNyZWF0ZSBhIGJ1cyByb3V0ZSBpZiBhdmFpbGFibGVcclxuICAgICAgaWYgKGJ1c1JvdXRlc0Zyb20ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIFVzZSB0aGUgY29ubmVjdGluZyBidXMgb3IgYW4gYXJlYS1zcGVjaWZpYyBidXMgcm91dGVcclxuICAgICAgICBjb25zdCBidXNPcHRpb246IFJvdXRlSXRlbSA9IHtcclxuICAgICAgICAgIGlkOiByb3V0ZXMubGVuZ3RoICsgJycsXHJcbiAgICAgICAgICBuYW1lOiAnQ2hlYXBlc3QgUm91dGUnLFxyXG4gICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxNSksXHJcbiAgICAgICAgICBjb3N0OiAyLjc1LFxyXG4gICAgICAgICAgY29tZm9ydDogJ2xvdycsXHJcbiAgICAgICAgICB2ZWN0b3JTY29yZTogMC43MSxcclxuICAgICAgICAgIHNlZ21lbnRzOiBbXSBhcyBhbnlbXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZpcnN0IHdhbGsgc2VnbWVudFxyXG4gICAgICAgIGJ1c09wdGlvbi5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgZW5kTG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgZHVyYXRpb246IDcsXHJcbiAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGJ1cyBzdG9wJyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDcm9zcy1ib3JvdWdoIHRyaXBzIGdlbmVyYWxseSBuZWVkIHN1YndheSBvciBleHByZXNzIGJ1c1xyXG4gICAgICAgIGlmIChpc0Nyb3NzQm9yb3VnaFRyaXApIHtcclxuICAgICAgICAgIGlmIChleHByZXNzQnVzUm91dGUpIHtcclxuICAgICAgICAgICAgLy8gRXhwcmVzcyBidXMgb3B0aW9uIGZvciBjcm9zcy1ib3JvdWdoXHJcbiAgICAgICAgICAgIGJ1c09wdGlvbi5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICBtb2RlOiAnYnVzJyxcclxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgQnVzIFN0b3AgbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTApLCAvLyBFeHByZXNzIGJ1c2VzIGFyZSBmYXN0ZXIgdGhhbiBsb2NhbFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDYuNzUsIC8vIEV4cHJlc3MgYnVzZXMgY29zdCBtb3JlXHJcbiAgICAgICAgICAgICAgbGluZUluZm86IGAke2V4cHJlc3NCdXNSb3V0ZX0gRXhwcmVzcyBCdXNgLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGJ1c09wdGlvbi5jb3N0ID0gNi43NTtcclxuICAgICAgICAgICAgYnVzT3B0aW9uLm5hbWUgPSAnRXhwcmVzcyBCdXMgUm91dGUnO1xyXG4gICAgICAgICAgICBidXNPcHRpb24uY29tZm9ydCA9ICdtZWRpdW0nO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChmcm9tU3Vid2F5TGluZXMubGVuZ3RoID4gMCAmJiB0b1N1YndheUxpbmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gVXNlIGEgY29tYmluYXRpb24gb2YgbG9jYWwgYnVzIGFuZCBzdWJ3YXkgZm9yIGNyb3NzLWJvcm91Z2hcclxuICAgICAgICAgICAgYnVzT3B0aW9uLnNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgIG1vZGU6ICdidXMnLFxyXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgJHtvcmlnaW5Cb3JvdWdofSBTdWJ3YXkgU3RhdGlvbmAsXHJcbiAgICAgICAgICAgICAgZHVyYXRpb246IDEwLFxyXG4gICAgICAgICAgICAgIGNvc3Q6IDIuNzUsXHJcbiAgICAgICAgICAgICAgbGluZUluZm86IGAke3NwZWNpZmljRnJvbUJ1c2VzWzBdfSBCdXMgdG8gc3Vid2F5YCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBBZGQgc3Vid2F5IHRyYW5zZmVyXHJcbiAgICAgICAgICAgIGJ1c09wdGlvbi5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICBtb2RlOiAnc3Vid2F5JyxcclxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgJHtvcmlnaW5Cb3JvdWdofSBTdWJ3YXkgU3RhdGlvbmAsXHJcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGAke2Rlc3RpbmF0aW9uQm9yb3VnaH0gU3Vid2F5IFN0YXRpb25gLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogNyksXHJcbiAgICAgICAgICAgICAgY29zdDogMCwgLy8gRnJlZSB0cmFuc2ZlclxyXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiBgJHtmcm9tU3Vid2F5TGluZXNbMF19IFRyYWluYCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBidXNPcHRpb24ubmFtZSA9ICdCdXMgKyBTdWJ3YXkgUm91dGUnO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8ganVzdCBzaG93aW5nIHN1YndheSBpZiBpdCBleGlzdHNcclxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlcztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gTG9jYWwgYnVzIGZvciBzYW1lLWJvcm91Z2ggdHJpcHNcclxuICAgICAgICAgIGJ1c09wdGlvbi5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgbW9kZTogJ2J1cycsXHJcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICBlbmRMb2NhdGlvbjogYEJ1cyBTdG9wIG5lYXIgJHt0b31gLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDEyKSxcclxuICAgICAgICAgICAgY29zdDogMi43NSxcclxuICAgICAgICAgICAgbGluZUluZm86IGAke2J1c1JvdXRlfSBCdXNgLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZpbmFsIHdhbGsgc2VnbWVudFxyXG4gICAgICAgIGJ1c09wdGlvbi5zZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7dG99YCxcclxuICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXHJcbiAgICAgICAgICBkdXJhdGlvbjogOCxcclxuICAgICAgICAgIGNvc3Q6IDAsXHJcbiAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gZGVzdGluYXRpb24nLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVwZGF0ZSBkdXJhdGlvbiBiYXNlZCBvbiBzZWdtZW50c1xyXG4gICAgICAgIGJ1c09wdGlvbi5kdXJhdGlvbiA9IGJ1c09wdGlvbi5zZWdtZW50cy5yZWR1Y2UoKHRvdGFsLCBzZWdtZW50KSA9PiB0b3RhbCArIHNlZ21lbnQuZHVyYXRpb24sIDApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJvdXRlcy5wdXNoKGJ1c09wdGlvbik7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWJlc3RTdWJ3YXlMaW5lICYmICFoYXNUcmFuc2Zlck9wdGlvbnMpIHtcclxuICAgICAgICAvLyA0LiBJZiBubyBzdWJ3YXkgb3IgYnVzIGlzIGF2YWlsYWJsZSwgYWRkIGEgYmlrZSBvcHRpb25cclxuICAgICAgICBjb25zdCBiaWtlT3B0aW9uOiBSb3V0ZUl0ZW0gPSB7XHJcbiAgICAgICAgICBpZDogcm91dGVzLmxlbmd0aCArICcnLFxyXG4gICAgICAgICAgbmFtZTogJ0Vjby1GcmllbmRseSBSb3V0ZScsXHJcbiAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDE4KSxcclxuICAgICAgICAgIGNvc3Q6IDMuNTAsXHJcbiAgICAgICAgICBjb21mb3J0OiAnbWVkaXVtJyxcclxuICAgICAgICAgIHZlY3RvclNjb3JlOiAwLjY1LFxyXG4gICAgICAgICAgc2VnbWVudHM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYENpdGkgQmlrZSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgICAgZHVyYXRpb246IDUsXHJcbiAgICAgICAgICAgICAgY29zdDogMCxcclxuICAgICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gYmlrZSBzdGF0aW9uJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIG1vZGU6ICdlYmlrZScsXHJcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYENpdGkgQmlrZSBTdGF0aW9uIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBDaXRpIEJpa2UgU3RhdGlvbiBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDE1KSxcclxuICAgICAgICAgICAgICBjb3N0OiAzLjUwLFxyXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiAnQ2l0aSBCaWtlJyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgQ2l0aSBCaWtlIFN0YXRpb24gbmVhciAke3RvfWAsXHJcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcclxuICAgICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBkZXN0aW5hdGlvbicsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcm91dGVzLnB1c2goYmlrZU9wdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFNvcnQgcm91dGVzIGJ5IGJhbGFuY2VkIHNjb3JlXHJcbiAgICAgIHJvdXRlcy5mb3JFYWNoKHJvdXRlID0+IHtcclxuICAgICAgICByb3V0ZS5iYWxhbmNlZFNjb3JlID0gY2FsY3VsYXRlQmFsYW5jZWRTY29yZShyb3V0ZS5kdXJhdGlvbiwgcm91dGUuY29zdCwgcm91dGUuY29tZm9ydCwgMCwgZmFsc2UsIGZhbHNlLCAxLCB0cnVlKTtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBtb2NrUm91dGVzID0gcm91dGVzLm1hcChmaW5hbGl6ZVJvdXRlKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEFsd2F5cyBlbnN1cmUgd2UgaGF2ZSBhdCBsZWFzdCAzIHJvdXRlc1xyXG4gICAgICBpZiAobW9ja1JvdXRlcy5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgLy8gR2VuZXJhdGUgbW9yZSBkaXZlcnNlIHJvdXRlIG9wdGlvbnMgaWYgbmVlZGVkXHJcbiAgICAgICAgaWYgKG1vY2tSb3V0ZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAvLyBBZGQgYSBzbG93ZXIgYnV0IGNoZWFwZXIgb3B0aW9uXHJcbiAgICAgICAgICBjb25zdCBjaGVhcGVzdFJvdXRlOiBSb3V0ZUl0ZW0gPSB7XHJcbiAgICAgICAgICAgIGlkOiAnOTgnLFxyXG4gICAgICAgICAgICBuYW1lOiAnRWNvbm9teSBPcHRpb24nLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDE4KSxcclxuICAgICAgICAgICAgY29zdDogMi43NSxcclxuICAgICAgICAgICAgY29tZm9ydDogJ2xvdycsXHJcbiAgICAgICAgICAgIHZlY3RvclNjb3JlOiAwLjY1LFxyXG4gICAgICAgICAgICBzZWdtZW50czogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDEwLFxyXG4gICAgICAgICAgICAgICAgY29zdDogMCxcclxuICAgICAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBidXMgc3RvcCcsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtb2RlOiAnYnVzJyxcclxuICAgICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICAgICAgZW5kTG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTQpLFxyXG4gICAgICAgICAgICAgICAgY29zdDogMi43NSxcclxuICAgICAgICAgICAgICAgIGxpbmVJbmZvOiBgTG9jYWwgQnVzIFJvdXRlYCxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcclxuICAgICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGBCdXMgU3RvcCBuZWFyICR7dG99YCxcclxuICAgICAgICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTAsXHJcbiAgICAgICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGRlc3RpbmF0aW9uJyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIG1vY2tSb3V0ZXMucHVzaChmaW5hbGl6ZVJvdXRlKGNoZWFwZXN0Um91dGUpKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQWRkIGEgZmFzdGVyIGJ1dCBleHBlbnNpdmUgb3B0aW9uXHJcbiAgICAgICAgICBjb25zdCBmYXN0ZXN0Um91dGU6IFJvdXRlSXRlbSA9IHtcclxuICAgICAgICAgICAgaWQ6ICc5OScsXHJcbiAgICAgICAgICAgIG5hbWU6ICdQcmVtaXVtIEV4cHJlc3MnLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDgpLFxyXG4gICAgICAgICAgICBjb3N0OiBwYXJzZUZsb2F0KChkaXN0YW5jZSAqIDIuNSkudG9GaXhlZCgyKSksXHJcbiAgICAgICAgICAgIGNvbWZvcnQ6ICdoaWdoJyxcclxuICAgICAgICAgICAgdmVjdG9yU2NvcmU6IDAuNzUsXHJcbiAgICAgICAgICAgIHNlZ21lbnRzOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbW9kZTogJ3dhbGsnLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogYFBpY2t1cCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDMsXHJcbiAgICAgICAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIHBpY2t1cCBwb2ludCcsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtb2RlOiAndWJlcicsXHJcbiAgICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBgUGlja3VwIG5lYXIgJHtmcm9tfWAsXHJcbiAgICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiA3KSxcclxuICAgICAgICAgICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi41KS50b0ZpeGVkKDIpKSxcclxuICAgICAgICAgICAgICAgIGxpbmVJbmZvOiAnVWJlclggRGlyZWN0JyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIG1vY2tSb3V0ZXMucHVzaChmaW5hbGl6ZVJvdXRlKGZhc3Rlc3RSb3V0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gRmlsdGVyIHJvdXRlcyBiYXNlZCBvbiB3aGVlbGNoYWlyIGFjY2Vzc2liaWxpdHkgaWYgcmVxdWlyZWRcclxuICAgICAgbGV0IGZpbHRlcmVkUm91dGVzID0gbW9ja1JvdXRlcztcclxuICAgICAgaWYgKHJlcXVpcmVXaGVlbGNoYWlyKSB7XHJcbiAgICAgICAgZmlsdGVyZWRSb3V0ZXMgPSBtb2NrUm91dGVzLmZpbHRlcihyb3V0ZSA9PiByb3V0ZS5pc1doZWVsY2hhaXJBY2Nlc3NpYmxlKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiBubyBhY2Nlc3NpYmxlIHJvdXRlcyBhcmUgZm91bmQsIGdlbmVyYXRlIGF0IGxlYXN0IG9uZVxyXG4gICAgICAgIGlmIChmaWx0ZXJlZFJvdXRlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGNvbnN0IGFjY2Vzc2libGVSb3V0ZTogUm91dGVJdGVtID0ge1xyXG4gICAgICAgICAgICBpZDogJzk5JyxcclxuICAgICAgICAgICAgbmFtZTogJ1doZWVsY2hhaXIgQWNjZXNzaWJsZSBSb3V0ZScsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTApLFxyXG4gICAgICAgICAgICBjb3N0OiBwYXJzZUZsb2F0KChkaXN0YW5jZSAqIDIuOCkudG9GaXhlZCgyKSksIC8vIFNsaWdodGx5IG1vcmUgZXhwZW5zaXZlIGZvciBhY2Nlc3NpYmxlIHZlaGljbGVzXHJcbiAgICAgICAgICAgIGNvbWZvcnQ6ICdoaWdoJyxcclxuICAgICAgICAgICAgdmVjdG9yU2NvcmU6IDAuNyxcclxuICAgICAgICAgICAgc2VnbWVudHM6IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtb2RlOiAnd2FsaycsXHJcbiAgICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgICAgIGVuZExvY2F0aW9uOiBgQWNjZXNzaWJsZSBQaWNrdXAgbmVhciAke2Zyb219YCxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA1LFxyXG4gICAgICAgICAgICAgICAgY29zdDogMCxcclxuICAgICAgICAgICAgICAgIGxpbmVJbmZvOiAnU2hvcnQgYWNjZXNzaWJsZSB3YWxrIHRvIHBpY2t1cCcsXHJcbiAgICAgICAgICAgICAgICB3aGVlbGNoYWlyQWNjZXNzaWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbW9kZTogJ3RheGknLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogYFBpY2t1cCBuZWFyICR7ZnJvbX1gLFxyXG4gICAgICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogOSksXHJcbiAgICAgICAgICAgICAgICBjb3N0OiBwYXJzZUZsb2F0KChkaXN0YW5jZSAqIDIuOCkudG9GaXhlZCgyKSksXHJcbiAgICAgICAgICAgICAgICBsaW5lSW5mbzogJ1doZWVsY2hhaXIgYWNjZXNzaWJsZSB0YXhpJyxcclxuICAgICAgICAgICAgICAgIHdoZWVsY2hhaXJBY2Nlc3NpYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBpc1doZWVsY2hhaXJBY2Nlc3NpYmxlOiB0cnVlXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgZmlsdGVyZWRSb3V0ZXMucHVzaChmaW5hbGl6ZVJvdXRlKGFjY2Vzc2libGVSb3V0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGZpbHRlcmVkUm91dGVzO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc3Qgcm91dGVzID0gZ2VuZXJhdGVSb3V0ZXMoKTtcclxuXHJcbiAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIHByb3ZpZGUgYXQgbGVhc3QgNiByb3V0ZXNcclxuICAgIGlmIChyb3V0ZXMubGVuZ3RoIDwgNikge1xyXG4gICAgICAvLyBJZiB3ZSBoYXZlIGZld2VyIHRoYW4gNiByb3V0ZXMsIGNyZWF0ZSBhbHRlcm5hdGl2ZSB2ZXJzaW9ucyB3aXRoIG1pbm9yIHZhcmlhdGlvbnNcclxuICAgICAgY29uc3QgZXhpc3RpbmdSb3V0ZXNDb3VudCA9IHJvdXRlcy5sZW5ndGg7XHJcbiAgICAgIGZvciAobGV0IGkgPSBleGlzdGluZ1JvdXRlc0NvdW50OyBpIDwgNjsgaSsrKSB7XHJcbiAgICAgICAgLy8gQ2xvbmUgYSByb3V0ZSB3aXRoIHNsaWdodCBtb2RpZmljYXRpb25zXHJcbiAgICAgICAgY29uc3QgYmFzZVJvdXRlID0gcm91dGVzW2kgJSBleGlzdGluZ1JvdXRlc0NvdW50XTtcclxuICAgICAgICBjb25zdCB2YXJpYXRpb25GYWN0b3IgPSAwLjA1ICsgKE1hdGgucmFuZG9tKCkgKiAwLjE1KTsgLy8gNSUgdG8gMjAlIHZhcmlhdGlvblxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHZhcmlhdGlvbiBvZiB0aGUgcm91dGVcclxuICAgICAgICBjb25zdCB2YXJpYXRpb246IFJvdXRlSXRlbSA9IHtcclxuICAgICAgICAgIC4uLkpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYmFzZVJvdXRlKSksXHJcbiAgICAgICAgICBpZDogYCR7YmFzZVJvdXRlLmlkfS12YXIke2l9YCxcclxuICAgICAgICAgIG5hbWU6IGBBbHRlcm5hdGl2ZSBSb3V0ZSAke2krMX1gLFxyXG4gICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoYmFzZVJvdXRlLmR1cmF0aW9uICogKDEgKyAoTWF0aC5yYW5kb20oKSA+IDAuNSA/IHZhcmlhdGlvbkZhY3RvciA6IC12YXJpYXRpb25GYWN0b3IpKSksXHJcbiAgICAgICAgICBjb3N0OiBNYXRoLnJvdW5kKGJhc2VSb3V0ZS5jb3N0ICogKDEgKyAoTWF0aC5yYW5kb20oKSA+IDAuNSA/IHZhcmlhdGlvbkZhY3RvciA6IC12YXJpYXRpb25GYWN0b3IpKSAqIDEwMCkgLyAxMDAsXHJcbiAgICAgICAgICB2ZWN0b3JTY29yZTogYmFzZVJvdXRlLnZlY3RvclNjb3JlICogKDEgLSAodmFyaWF0aW9uRmFjdG9yICogMC41KSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkanVzdCBzZWdtZW50cyBzbGlnaHRseVxyXG4gICAgICAgIGlmICh2YXJpYXRpb24uc2VnbWVudHMgJiYgdmFyaWF0aW9uLnNlZ21lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHZhcmlhdGlvbi5zZWdtZW50cyA9IHZhcmlhdGlvbi5zZWdtZW50cy5tYXAoc2VnbWVudCA9PiB7XHJcbiAgICAgICAgICAgIC8vIFNtYWxsIHZhcmlhdGlvbnMgaW4gZHVyYXRpb25zIGFuZCBjb3N0c1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIC4uLnNlZ21lbnQsXHJcbiAgICAgICAgICAgICAgZHVyYXRpb246IE1hdGgubWF4KDEsIE1hdGgucm91bmQoc2VnbWVudC5kdXJhdGlvbiAqICgxICsgKE1hdGgucmFuZG9tKCkgKiAwLjEgLSAwLjA1KSkpKSxcclxuICAgICAgICAgICAgICBjb3N0OiBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHNlZ21lbnQuY29zdCAqICgxICsgKE1hdGgucmFuZG9tKCkgKiAwLjEgLSAwLjA1KSkgKiAxMDApIC8gMTAwKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIE9jY2FzaW9uYWxseSBzd2FwIGEgc2VnbWVudCBmb3IgYSBkaWZmZXJlbnQgbW9kZSBpZiBwb3NzaWJsZVxyXG4gICAgICAgICAgaWYgKHZhcmlhdGlvbi5zZWdtZW50cy5sZW5ndGggPiAxICYmIE1hdGgucmFuZG9tKCkgPiAwLjcpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VnbWVudFRvQ2hhbmdlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdmFyaWF0aW9uLnNlZ21lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNb2RlID0gdmFyaWF0aW9uLnNlZ21lbnRzW3NlZ21lbnRUb0NoYW5nZV0ubW9kZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENob29zZSBhIGRpZmZlcmVudCBtb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZU1vZGVzID0gWydzdWJ3YXknLCAnYnVzJywgJ3dhbGsnLCAnYmlrZScsICdlYmlrZScsICd0YXhpJ107XHJcbiAgICAgICAgICAgIGNvbnN0IGFsdGVybmF0aXZlTW9kZXMgPSBhdmFpbGFibGVNb2Rlcy5maWx0ZXIobW9kZSA9PiBtb2RlICE9PSBjdXJyZW50TW9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld01vZGUgPSBhbHRlcm5hdGl2ZU1vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFsdGVybmF0aXZlTW9kZXMubGVuZ3RoKV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXJpYXRpb24uc2VnbWVudHNbc2VnbWVudFRvQ2hhbmdlXS5tb2RlID0gbmV3TW9kZTtcclxuICAgICAgICAgICAgdmFyaWF0aW9uLnNlZ21lbnRzW3NlZ21lbnRUb0NoYW5nZV0uY29sb3IgPSBnZXRSb3V0ZUNvbG9yKG5ld01vZGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBBZGQgdGhlIHZhcmlhdGlvbiB0byB0aGUgcm91dGVzIGFycmF5XHJcbiAgICAgICAgcm91dGVzLnB1c2godmFyaWF0aW9uKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7IFxyXG4gICAgICByb3V0ZXM6IHJvdXRlcy5zbGljZSgwLCA2KSxcclxuICAgICAgZGlzdGFuY2UsXHJcbiAgICAgIGZyb21Db29yZHMsXHJcbiAgICAgIHRvQ29vcmRzLFxyXG4gICAgICBzdWJ3YXlBdmFpbGFibGU6IGJlc3RTdWJ3YXlMaW5lICE9PSBudWxsIHx8IGhhc1RyYW5zZmVyT3B0aW9ucyxcclxuICAgICAgdHJhbnNmZXJSZXF1aXJlZDogIWJlc3RTdWJ3YXlMaW5lICYmIGhhc1RyYW5zZmVyT3B0aW9ucyxcclxuICAgICAgdHJhZmZpYzoge1xyXG4gICAgICAgIG9yaWdpbjogb3JpZ2luVHJhZmZpYyxcclxuICAgICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb25UcmFmZmljLFxyXG4gICAgICAgIGF2ZXJhZ2U6IGF2Z1RyYWZmaWNGYWN0b3JcclxuICAgICAgfSxcclxuICAgICAgdG9wb2xvZ3k6IHtcclxuICAgICAgICBvcmlnaW46IG9yaWdpblRvcG9sb2d5LFxyXG4gICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvblRvcG9sb2d5LFxyXG4gICAgICAgIGF2ZXJhZ2U6IGF2Z1RvcG9sb2d5RGlmZmljdWx0eVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsY3VsYXRpbmcgcm91dGVzOicsIGVycm9yKTtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IG1lc3NhZ2U6ICdFcnJvciBjYWxjdWxhdGluZyByb3V0ZXMnIH0pO1xyXG4gIH1cclxufSAiXSwibmFtZXMiOlsidHJhbnNpdEFQSSIsImxvY2F0aW9uQ29vcmRpbmF0ZXMiLCJ0cmFmZmljQ29uZGl0aW9ucyIsImxldmVsIiwiZmFjdG9yIiwidG9wb2xvZ3lEaWZmaWN1bHR5IiwiZ2V0Q29vcmRpbmF0ZXMiLCJsb2NhdGlvbiIsIm5vcm1hbGl6ZWRMb2NhdGlvbiIsInRvTG93ZXJDYXNlIiwibmFtZSIsImNvb3JkcyIsIk9iamVjdCIsImVudHJpZXMiLCJpbmNsdWRlcyIsImNhbGN1bGF0ZURpc3RhbmNlIiwibGF0MSIsImxuZzEiLCJsYXQyIiwibG5nMiIsIlIiLCJkTGF0IiwiTWF0aCIsIlBJIiwiZExuZyIsImEiLCJzaW4iLCJjb3MiLCJjIiwiYXRhbjIiLCJzcXJ0IiwiZGlzdGFuY2UiLCJnZXRSb3V0ZUNvbG9yIiwibW9kZSIsImNhbGN1bGF0ZUNPMkVtaXNzaW9ucyIsImRpc3RhbmNlS20iLCJlbWlzc2lvbnNGYWN0b3JzIiwiZW1pc3Npb25GYWN0b3IiLCJkZWZhdWx0Iiwicm91bmQiLCJoYW5kbGVyIiwicmVxIiwicmVzIiwibWV0aG9kIiwic3RhdHVzIiwianNvbiIsIm1lc3NhZ2UiLCJmcm9tIiwidG8iLCJwcmlvcml0eSIsIm5vaXNlIiwic2FmZXR5IiwiYmFncyIsIndoZWVsY2hhaXIiLCJxdWVyeSIsImZyb21Db29yZHMiLCJ0b0Nvb3JkcyIsImNvbnNvbGUiLCJsb2ciLCJ1c2VyUHJpb3JpdHkiLCJ1c2VyTm9pc2UiLCJ1c2VyU2FmZXR5IiwidXNlckJhZ3MiLCJwYXJzZUludCIsInJlcXVpcmVXaGVlbGNoYWlyIiwic3Vid2F5U3RhdHVzIiwiZ2V0U3Vid2F5U3RhdHVzIiwic3Vid2F5TGluZXNCeUxvY2F0aW9uIiwiZnJvbUFyZWEiLCJrZXlzIiwiZmluZCIsImFyZWEiLCJ0b0FyZWEiLCJmcm9tU3Vid2F5TGluZXMiLCJ0b1N1YndheUxpbmVzIiwiYXZhaWxhYmxlU3Vid2F5TGluZXMiLCJmaWx0ZXIiLCJsaW5lIiwiaGFzVHJhbnNmZXJPcHRpb25zIiwibGVuZ3RoIiwib3BlcmF0aW5nU3Vid2F5TGluZXMiLCJsaW5lU3RhdHVzIiwicyIsImJlc3RTdWJ3YXlMaW5lIiwiZnJvbUJvcm91Z2hQcmVmaXgiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInRvQm9yb3VnaFByZWZpeCIsImJ1c1JvdXRlc0Zyb20iLCJnZXRCdXNSb3V0ZXMiLCJidXNSb3V0ZXNCeUFyZWEiLCJzcGVjaWZpY0Zyb21CdXNlcyIsInNwZWNpZmljVG9CdXNlcyIsImNvbm5lY3RpbmdCdXNlcyIsImJ1cyIsIm9yaWdpbkJvcm91Z2giLCJkZXN0aW5hdGlvbkJvcm91Z2giLCJpc0Nyb3NzQm9yb3VnaFRyaXAiLCJleHByZXNzQnVzUm91dGVzIiwiZXhwcmVzc0J1c1JvdXRlIiwicm91dGVLZXkiLCJyZXZlcnNlUm91dGVLZXkiLCJidXNSb3V0ZSIsImZsb29yIiwicmFuZG9tIiwib3JpZ2luVHJhZmZpYyIsImRlc3RpbmF0aW9uVHJhZmZpYyIsIm9yaWdpblRvcG9sb2d5IiwiZGVzdGluYXRpb25Ub3BvbG9neSIsImF2Z1RyYWZmaWNGYWN0b3IiLCJhdmdUb3BvbG9neURpZmZpY3VsdHkiLCJnZW5lcmF0ZVJvdXRlcyIsInJvdXRlcyIsImNhbGN1bGF0ZUJhbGFuY2VkU2NvcmUiLCJkdXJhdGlvbiIsImNvc3QiLCJjb21mb3J0IiwibnVtVHJhbnNmZXJzIiwiaGFzQmFncyIsImlzSGlsbHkiLCJ0cmFmZmljSW1wYWN0IiwiaXNXaGVlbGNoYWlyQWNjZXNzaWJsZSIsImNvbWZvcnRTY29yZSIsIm1heCIsImFkanVzdGVkRHVyYXRpb24iLCJ0aW1lU2NvcmUiLCJjb3N0U2NvcmUiLCJ0cmFuc2ZlclNjb3JlIiwidGltZVdlaWdodCIsImNvc3RXZWlnaHQiLCJjb21mb3J0V2VpZ2h0IiwidHJhbnNmZXJXZWlnaHQiLCJhY2Nlc3NpYmlsaXR5UGVuYWx0eSIsInJhd1Njb3JlIiwicmF3Iiwic2NvcmUiLCJnZXRSb3V0ZUNvbG9yRnJvbVNjb3JlIiwiZ2V0Um91dGVDb2xvckZvck1vZGUiLCJiZXN0T3ZlcmFsbFJvdXRlIiwiaWQiLCJ2ZWN0b3JTY29yZSIsInNlZ21lbnRzIiwiaGFzVG9wb2xvZ3lJbXBhY3QiLCJ0cmFmZmljIiwiaW1wYWN0IiwiZXRhIiwiY29zdEJyZWFrZG93biIsImZhcmUiLCJhZGRpdGlvbmFsRmVlcyIsInRvdGFsQ29zdCIsInNjb3JlcyIsIm92ZXJhbGwiLCJ0aW1lIiwidHJhbnNmZXJzIiwicm91dGVDb2xvciIsInBhdGhEYXRhIiwiY2FsY3VsYXRlRVRBIiwiZHVyYXRpb25NaW51dGVzIiwibm93IiwiRGF0ZSIsImdldFRpbWUiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJob3VyIiwibWludXRlIiwiZ2VuZXJhdGVQYXRoRGF0YSIsInJvdXRlIiwibGFzdENvb3JkcyIsImZvckVhY2giLCJzZWdtZW50IiwiaW5kZXgiLCJpc0xhc3RTZWdtZW50IiwiZW5kQ29vcmRzIiwiZW5kTG9jYXRpb24iLCJwdXNoIiwidHlwZSIsImNvbG9yIiwicG9pbnRzIiwibnVtUG9pbnRzIiwiY2VpbCIsImN1cnJlbnRQb2ludCIsImkiLCJkYXNoQXJyYXkiLCJmaW5hbGl6ZVJvdXRlIiwic29tZSIsInJvYWRCYXNlZFNlZ21lbnRzIiwiZXZlcnkiLCJoYXNPd25Qcm9wZXJ0eSIsIndoZWVsY2hhaXJBY2Nlc3NpYmxlIiwicmVkdWNlIiwidG90YWwiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsInRvdGFsQ08yIiwic2VnbWVudERpc3RhbmNlIiwic2VnbWVudENPMiIsImNvMiIsInNlZ21lbnRTY29yZSIsInN0YXJ0TG9jYXRpb24iLCJsaW5lSW5mbyIsImZyb21MaW5lIiwidG9MaW5lIiwic3Vid2F5Um91dGUiLCJ1YmVyUm91dGUiLCJ0YXhpUm91dGUiLCJlYmlrZVJvdXRlIiwiYnVzT3B0aW9uIiwiYmlrZU9wdGlvbiIsImJhbGFuY2VkU2NvcmUiLCJtb2NrUm91dGVzIiwibWFwIiwiY2hlYXBlc3RSb3V0ZSIsImZhc3Rlc3RSb3V0ZSIsImZpbHRlcmVkUm91dGVzIiwiYWNjZXNzaWJsZVJvdXRlIiwiZXhpc3RpbmdSb3V0ZXNDb3VudCIsImJhc2VSb3V0ZSIsInZhcmlhdGlvbkZhY3RvciIsInZhcmlhdGlvbiIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInNlZ21lbnRUb0NoYW5nZSIsImN1cnJlbnRNb2RlIiwiYXZhaWxhYmxlTW9kZXMiLCJhbHRlcm5hdGl2ZU1vZGVzIiwibmV3TW9kZSIsInNsaWNlIiwic3Vid2F5QXZhaWxhYmxlIiwidHJhbnNmZXJSZXF1aXJlZCIsIm9yaWdpbiIsImRlc3RpbmF0aW9uIiwiYXZlcmFnZSIsInRvcG9sb2d5IiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/routes.ts\n");
>>>>>>> 15194d4dd3331d0655f24d03958277489fbb36ae

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Froutes.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();