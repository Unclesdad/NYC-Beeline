"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/routes";
exports.ids = ["pages/api/routes"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Froutes.ts&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Froutes.ts&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/pages/api/routes.ts */ \"(api)/./src/pages/api/routes.ts\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/routes\",\n        pathname: \"/api/routes\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _src_pages_api_routes_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRnJvdXRlcyZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnNyYyUyRnBhZ2VzJTJGYXBpJTJGcm91dGVzLnRzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNMO0FBQzFEO0FBQ3NEO0FBQ3REO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyxxREFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMscURBQVE7QUFDcEM7QUFDTyx3QkFBd0IsZ0hBQW1CO0FBQ2xEO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnljLWJlZWxpbmUvPzUwODkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3NyYy9wYWdlcy9hcGkvcm91dGVzLnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvcm91dGVzXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvcm91dGVzXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogXCJcIixcbiAgICAgICAgZmlsZW5hbWU6IFwiXCJcbiAgICB9LFxuICAgIHVzZXJsYW5kXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMtYXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Froutes.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transitAPI: () => (/* binding */ transitAPI)\n/* harmony export */ });\n// API configuration\nconst API_CONFIG = {\n    MTA_BASE_URL: \"https://api.mta.info/api\",\n    CITIBIKE_BASE_URL: \"https://gbfs.citibikenyc.com/gbfs/en\",\n    UBER_BASE_URL: \"https://api.uber.com/v1\",\n    GOOGLE_MAPS_BASE_URL: \"https://maps.googleapis.com/maps/api\"\n};\n// Mock data (in a real app, these would be API calls)\nconst mockSubwayData = [\n    {\n        line: \"A\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"C\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"E\",\n        status: \"delayed\",\n        delay: 10,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"B\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"D\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"F\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"M\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"G\",\n        status: \"delayed\",\n        delay: 5,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"L\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"N\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"Q\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"R\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"W\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"1\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"2\",\n        status: \"delayed\",\n        delay: 8,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"3\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"4\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"5\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"6\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"high\"\n    },\n    {\n        line: \"7\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"medium\"\n    },\n    {\n        line: \"J\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"Z\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    },\n    {\n        line: \"S\",\n        status: \"normal\",\n        delay: 0,\n        crowd_level: \"low\"\n    }\n];\nconst mockBusRoutes = [\n    \"Q58\",\n    \"Q59\",\n    \"Q60\",\n    \"B41\",\n    \"B42\",\n    \"B44\",\n    \"B45\",\n    \"B46\",\n    \"M1\",\n    \"M2\",\n    \"M3\",\n    \"M4\",\n    \"M5\",\n    \"BX1\",\n    \"BX2\",\n    \"BX9\",\n    \"BX10\",\n    \"S40\",\n    \"S44\",\n    \"S46\",\n    \"S48\"\n];\nconst generateMockBusData = ()=>{\n    return mockBusRoutes.map((route)=>({\n            route,\n            location: {\n                lat: 40.7128 + (Math.random() - 0.5) * 0.2,\n                lng: -74.0060 + (Math.random() - 0.5) * 0.2\n            },\n            next_stop: `${route} Stop ${Math.floor(Math.random() * 20) + 1}`,\n            estimated_arrival: new Date(Date.now() + Math.floor(Math.random() * 20) * 60000).toISOString(),\n            crowd_level: [\n                \"low\",\n                \"medium\",\n                \"high\"\n            ][Math.floor(Math.random() * 3)]\n        }));\n};\n// API service functions\nclass TransitAPI {\n    // Subway data\n    async getSubwayStatus() {\n        // In a real app, this would be an API call to MTA\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/subway/status`).then(res => res.data);\n        // Using mock data for now\n        return Promise.resolve(mockSubwayData);\n    }\n    async getSubwayLine(line) {\n        // In a real app, this would be an API call to MTA\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/subway/line/${line}`).then(res => res.data);\n        // Using mock data for now\n        const lineData = mockSubwayData.find((subway)=>subway.line === line);\n        return Promise.resolve(lineData || null);\n    }\n    // Bus data\n    async getBusRoutes(borough) {\n        // In a real app, this would be an API call\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/bus/routes?borough=${borough}`).then(res => res.data);\n        // Using mock data filtered by borough prefix\n        const boroughPrefix = borough.charAt(0).toUpperCase();\n        const routes = mockBusRoutes.filter((route)=>route.startsWith(boroughPrefix));\n        return Promise.resolve(routes);\n    }\n    async getBusLocations(route) {\n        // In a real app, this would be an API call\n        // return axios.get(`${API_CONFIG.MTA_BASE_URL}/bus/route/${route}/locations`).then(res => res.data);\n        // Using mock data\n        const busData = generateMockBusData().filter((bus)=>bus.route === route);\n        return Promise.resolve(busData);\n    }\n    // Bike data\n    async getBikeStations(lat, lng, radius = 1) {\n        // In a real app, this would be an API call to Citi Bike\n        // return axios.get(`${API_CONFIG.CITIBIKE_BASE_URL}/station_information.json`).then(res => res.data.data.stations);\n        // Generate mock bike stations around the provided coordinates\n        const stations = [];\n        const stationCount = Math.floor(Math.random() * 5) + 3; // 3-7 stations\n        for(let i = 0; i < stationCount; i++){\n            const stationLat = lat + (Math.random() - 0.5) * 0.02 * radius;\n            const stationLng = lng + (Math.random() - 0.5) * 0.02 * radius;\n            stations.push({\n                station_id: `station-${i}`,\n                name: `Bike Station ${i + 1}`,\n                location: {\n                    lat: stationLat,\n                    lng: stationLng\n                },\n                available_bikes: Math.floor(Math.random() * 15),\n                available_docks: Math.floor(Math.random() * 10)\n            });\n        }\n        return Promise.resolve(stations);\n    }\n    // Uber/Taxi data\n    async getUberEstimate(startLat, startLng, endLat, endLng) {\n        // In a real app, this would be an API call to Uber\n        // return axios.get(`${API_CONFIG.UBER_BASE_URL}/estimates/price?start_latitude=${startLat}&start_longitude=${startLng}&end_latitude=${endLat}&end_longitude=${endLng}`).then(res => res.data.prices);\n        // Generate mock Uber options\n        const options = [\n            {\n                product_id: \"uberx\",\n                display_name: \"UberX\"\n            },\n            {\n                product_id: \"uberxl\",\n                display_name: \"UberXL\"\n            },\n            {\n                product_id: \"uberblack\",\n                display_name: \"Uber Black\"\n            },\n            {\n                product_id: \"uberpool\",\n                display_name: \"Uber Pool\"\n            }\n        ];\n        // Calculate mock duration and fare based on distance\n        const distance = this.calculateDistance(startLat, startLng, endLat, endLng);\n        return Promise.resolve(options.map((option)=>({\n                ...option,\n                estimate: {\n                    duration: Math.floor(distance * 120),\n                    fare: Math.floor((option.product_id === \"uberpool\" ? 2.0 : 2.5) * distance * 100) / 100\n                }\n            })));\n    }\n    async getTaxiEstimate(startLat, startLng, endLat, endLng) {\n        // In a real app, this would be an API call or calculation\n        // return axios.get(`${API_CONFIG.TAXI_BASE_URL}/estimate?start_latitude=${startLat}&start_longitude=${startLng}&end_latitude=${endLat}&end_longitude=${endLng}`).then(res => res.data.fare);\n        // Calculate mock taxi fare based on distance\n        const distance = this.calculateDistance(startLat, startLng, endLat, endLng);\n        const baseFare = 2.50;\n        const perMileFare = 2.50;\n        return Promise.resolve(Math.floor((baseFare + distance * perMileFare) * 100) / 100);\n    }\n    // Helper functions\n    calculateDistance(lat1, lng1, lat2, lng2) {\n        const R = 3958.8; // Earth radius in miles\n        const dLat = this.toRadians(lat2 - lat1);\n        const dLng = this.toRadians(lng2 - lng1);\n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        const distance = R * c;\n        return distance;\n    }\n    toRadians(degrees) {\n        return degrees * Math.PI / 180;\n    }\n}\n// Export a singleton instance\nconst transitAPI = new TransitAPI();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sS0FBSzlELEtBQUtrRSxHQUFHLENBQUNKLE9BQU8sS0FDckM5RCxLQUFLbUUsR0FBRyxDQUFDLElBQUksQ0FBQ0osU0FBUyxDQUFDTixTQUFTekQsS0FBS21FLEdBQUcsQ0FBQyxJQUFJLENBQUNKLFNBQVMsQ0FBQ0osU0FDekQzRCxLQUFLa0UsR0FBRyxDQUFDRixPQUFPLEtBQUtoRSxLQUFLa0UsR0FBRyxDQUFDRixPQUFPO1FBQ3ZDLE1BQU1JLElBQUksSUFBSXBFLEtBQUtxRSxLQUFLLENBQUNyRSxLQUFLc0UsSUFBSSxDQUFDTCxJQUFJakUsS0FBS3NFLElBQUksQ0FBQyxJQUFJTDtRQUNyRCxNQUFNakIsV0FBV2EsSUFBSU87UUFFckIsT0FBT3BCO0lBQ1Q7SUFFUWUsVUFBVVEsT0FBZSxFQUFVO1FBQ3pDLE9BQU9BLFVBQVV2RSxLQUFLd0UsRUFBRSxHQUFHO0lBQzdCO0FBQ0Y7QUFFQSw4QkFBOEI7QUFDdkIsTUFBTUMsYUFBYSxJQUFJaEUsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL255Yy1iZWVsaW5lLy4vc3JjL2xpYi9hcGkudHM/MmZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG4vLyBBUEkgY29uZmlndXJhdGlvblxuY29uc3QgQVBJX0NPTkZJRyA9IHtcbiAgTVRBX0JBU0VfVVJMOiAnaHR0cHM6Ly9hcGkubXRhLmluZm8vYXBpJyxcbiAgQ0lUSUJJS0VfQkFTRV9VUkw6ICdodHRwczovL2diZnMuY2l0aWJpa2VueWMuY29tL2diZnMvZW4nLFxuICBVQkVSX0JBU0VfVVJMOiAnaHR0cHM6Ly9hcGkudWJlci5jb20vdjEnLFxuICBHT09HTEVfTUFQU19CQVNFX1VSTDogJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaScsXG59O1xuXG4vLyBUcmFuc2l0IGRhdGEgaW50ZXJmYWNlc1xuZXhwb3J0IGludGVyZmFjZSBTdWJ3YXlEYXRhIHtcbiAgbGluZTogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbiAgZGVsYXk6IG51bWJlcjsgLy8gaW4gbWludXRlc1xuICBjcm93ZF9sZXZlbDogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCdXNEYXRhIHtcbiAgcm91dGU6IHN0cmluZztcbiAgbG9jYXRpb246IHtcbiAgICBsYXQ6IG51bWJlcjtcbiAgICBsbmc6IG51bWJlcjtcbiAgfTtcbiAgbmV4dF9zdG9wOiBzdHJpbmc7XG4gIGVzdGltYXRlZF9hcnJpdmFsOiBzdHJpbmc7XG4gIGNyb3dkX2xldmVsOiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJpa2VEYXRhIHtcbiAgc3RhdGlvbl9pZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGxvY2F0aW9uOiB7XG4gICAgbGF0OiBudW1iZXI7XG4gICAgbG5nOiBudW1iZXI7XG4gIH07XG4gIGF2YWlsYWJsZV9iaWtlczogbnVtYmVyO1xuICBhdmFpbGFibGVfZG9ja3M6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVYmVyRGF0YSB7XG4gIHByb2R1Y3RfaWQ6IHN0cmluZztcbiAgZGlzcGxheV9uYW1lOiBzdHJpbmc7XG4gIGVzdGltYXRlOiB7XG4gICAgZHVyYXRpb246IG51bWJlcjsgLy8gaW4gc2Vjb25kc1xuICAgIGZhcmU6IG51bWJlcjsgLy8gaW4gZG9sbGFyc1xuICB9O1xufVxuXG4vLyBNb2NrIGRhdGEgKGluIGEgcmVhbCBhcHAsIHRoZXNlIHdvdWxkIGJlIEFQSSBjYWxscylcbmNvbnN0IG1vY2tTdWJ3YXlEYXRhOiBTdWJ3YXlEYXRhW10gPSBbXG4gIHsgbGluZTogJ0EnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXG4gIHsgbGluZTogJ0MnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXG4gIHsgbGluZTogJ0UnLCBzdGF0dXM6ICdkZWxheWVkJywgZGVsYXk6IDEwLCBjcm93ZF9sZXZlbDogJ2hpZ2gnIH0sXG4gIHsgbGluZTogJ0InLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXG4gIHsgbGluZTogJ0QnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXG4gIHsgbGluZTogJ0YnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXG4gIHsgbGluZTogJ00nLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXG4gIHsgbGluZTogJ0cnLCBzdGF0dXM6ICdkZWxheWVkJywgZGVsYXk6IDUsIGNyb3dkX2xldmVsOiAnbG93JyB9LFxuICB7IGxpbmU6ICdMJywgc3RhdHVzOiAnbm9ybWFsJywgZGVsYXk6IDAsIGNyb3dkX2xldmVsOiAnaGlnaCcgfSxcbiAgeyBsaW5lOiAnTicsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ21lZGl1bScgfSxcbiAgeyBsaW5lOiAnUScsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ21lZGl1bScgfSxcbiAgeyBsaW5lOiAnUicsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ2xvdycgfSxcbiAgeyBsaW5lOiAnVycsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ2xvdycgfSxcbiAgeyBsaW5lOiAnMScsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ21lZGl1bScgfSxcbiAgeyBsaW5lOiAnMicsIHN0YXR1czogJ2RlbGF5ZWQnLCBkZWxheTogOCwgY3Jvd2RfbGV2ZWw6ICdoaWdoJyB9LFxuICB7IGxpbmU6ICczJywgc3RhdHVzOiAnbm9ybWFsJywgZGVsYXk6IDAsIGNyb3dkX2xldmVsOiAnbWVkaXVtJyB9LFxuICB7IGxpbmU6ICc0Jywgc3RhdHVzOiAnbm9ybWFsJywgZGVsYXk6IDAsIGNyb3dkX2xldmVsOiAnaGlnaCcgfSxcbiAgeyBsaW5lOiAnNScsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ21lZGl1bScgfSxcbiAgeyBsaW5lOiAnNicsIHN0YXR1czogJ25vcm1hbCcsIGRlbGF5OiAwLCBjcm93ZF9sZXZlbDogJ2hpZ2gnIH0sXG4gIHsgbGluZTogJzcnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdtZWRpdW0nIH0sXG4gIHsgbGluZTogJ0onLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXG4gIHsgbGluZTogJ1onLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXG4gIHsgbGluZTogJ1MnLCBzdGF0dXM6ICdub3JtYWwnLCBkZWxheTogMCwgY3Jvd2RfbGV2ZWw6ICdsb3cnIH0sXG5dO1xuXG5jb25zdCBtb2NrQnVzUm91dGVzOiBzdHJpbmdbXSA9IFsnUTU4JywgJ1E1OScsICdRNjAnLCAnQjQxJywgJ0I0MicsICdCNDQnLCAnQjQ1JywgJ0I0NicsICdNMScsICdNMicsICdNMycsICdNNCcsICdNNScsICdCWDEnLCAnQlgyJywgJ0JYOScsICdCWDEwJywgJ1M0MCcsICdTNDQnLCAnUzQ2JywgJ1M0OCddO1xuXG5jb25zdCBnZW5lcmF0ZU1vY2tCdXNEYXRhID0gKCk6IEJ1c0RhdGFbXSA9PiB7XG4gIHJldHVybiBtb2NrQnVzUm91dGVzLm1hcChyb3V0ZSA9PiAoe1xuICAgIHJvdXRlLFxuICAgIGxvY2F0aW9uOiB7XG4gICAgICBsYXQ6IDQwLjcxMjggKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjIsXG4gICAgICBsbmc6IC03NC4wMDYwICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4yLFxuICAgIH0sXG4gICAgbmV4dF9zdG9wOiBgJHtyb3V0ZX0gU3RvcCAke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwKSArIDF9YCxcbiAgICBlc3RpbWF0ZWRfYXJyaXZhbDogbmV3IERhdGUoRGF0ZS5ub3coKSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwKSAqIDYwMDAwKS50b0lTT1N0cmluZygpLFxuICAgIGNyb3dkX2xldmVsOiBbJ2xvdycsICdtZWRpdW0nLCAnaGlnaCddW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDMpXSBhcyAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnLFxuICB9KSk7XG59O1xuXG4vLyBBUEkgc2VydmljZSBmdW5jdGlvbnNcbmNsYXNzIFRyYW5zaXRBUEkge1xuICAvLyBTdWJ3YXkgZGF0YVxuICBhc3luYyBnZXRTdWJ3YXlTdGF0dXMoKTogUHJvbWlzZTxTdWJ3YXlEYXRhW10+IHtcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIGFuIEFQSSBjYWxsIHRvIE1UQVxuICAgIC8vIHJldHVybiBheGlvcy5nZXQoYCR7QVBJX0NPTkZJRy5NVEFfQkFTRV9VUkx9L3N1YndheS9zdGF0dXNgKS50aGVuKHJlcyA9PiByZXMuZGF0YSk7XG4gICAgXG4gICAgLy8gVXNpbmcgbW9jayBkYXRhIGZvciBub3dcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1vY2tTdWJ3YXlEYXRhKTtcbiAgfVxuXG4gIGFzeW5jIGdldFN1YndheUxpbmUobGluZTogc3RyaW5nKTogUHJvbWlzZTxTdWJ3YXlEYXRhIHwgbnVsbD4ge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgYmUgYW4gQVBJIGNhbGwgdG8gTVRBXG4gICAgLy8gcmV0dXJuIGF4aW9zLmdldChgJHtBUElfQ09ORklHLk1UQV9CQVNFX1VSTH0vc3Vid2F5L2xpbmUvJHtsaW5lfWApLnRoZW4ocmVzID0+IHJlcy5kYXRhKTtcbiAgICBcbiAgICAvLyBVc2luZyBtb2NrIGRhdGEgZm9yIG5vd1xuICAgIGNvbnN0IGxpbmVEYXRhID0gbW9ja1N1YndheURhdGEuZmluZChzdWJ3YXkgPT4gc3Vid2F5LmxpbmUgPT09IGxpbmUpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobGluZURhdGEgfHwgbnVsbCk7XG4gIH1cblxuICAvLyBCdXMgZGF0YVxuICBhc3luYyBnZXRCdXNSb3V0ZXMoYm9yb3VnaDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgYmUgYW4gQVBJIGNhbGxcbiAgICAvLyByZXR1cm4gYXhpb3MuZ2V0KGAke0FQSV9DT05GSUcuTVRBX0JBU0VfVVJMfS9idXMvcm91dGVzP2Jvcm91Z2g9JHtib3JvdWdofWApLnRoZW4ocmVzID0+IHJlcy5kYXRhKTtcbiAgICBcbiAgICAvLyBVc2luZyBtb2NrIGRhdGEgZmlsdGVyZWQgYnkgYm9yb3VnaCBwcmVmaXhcbiAgICBjb25zdCBib3JvdWdoUHJlZml4ID0gYm9yb3VnaC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCByb3V0ZXMgPSBtb2NrQnVzUm91dGVzLmZpbHRlcihyb3V0ZSA9PiByb3V0ZS5zdGFydHNXaXRoKGJvcm91Z2hQcmVmaXgpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJvdXRlcyk7XG4gIH1cblxuICBhc3luYyBnZXRCdXNMb2NhdGlvbnMocm91dGU6IHN0cmluZyk6IFByb21pc2U8QnVzRGF0YVtdPiB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZSBhbiBBUEkgY2FsbFxuICAgIC8vIHJldHVybiBheGlvcy5nZXQoYCR7QVBJX0NPTkZJRy5NVEFfQkFTRV9VUkx9L2J1cy9yb3V0ZS8ke3JvdXRlfS9sb2NhdGlvbnNgKS50aGVuKHJlcyA9PiByZXMuZGF0YSk7XG4gICAgXG4gICAgLy8gVXNpbmcgbW9jayBkYXRhXG4gICAgY29uc3QgYnVzRGF0YSA9IGdlbmVyYXRlTW9ja0J1c0RhdGEoKS5maWx0ZXIoYnVzID0+IGJ1cy5yb3V0ZSA9PT0gcm91dGUpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYnVzRGF0YSk7XG4gIH1cblxuICAvLyBCaWtlIGRhdGFcbiAgYXN5bmMgZ2V0QmlrZVN0YXRpb25zKGxhdDogbnVtYmVyLCBsbmc6IG51bWJlciwgcmFkaXVzOiBudW1iZXIgPSAxKTogUHJvbWlzZTxCaWtlRGF0YVtdPiB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCBiZSBhbiBBUEkgY2FsbCB0byBDaXRpIEJpa2VcbiAgICAvLyByZXR1cm4gYXhpb3MuZ2V0KGAke0FQSV9DT05GSUcuQ0lUSUJJS0VfQkFTRV9VUkx9L3N0YXRpb25faW5mb3JtYXRpb24uanNvbmApLnRoZW4ocmVzID0+IHJlcy5kYXRhLmRhdGEuc3RhdGlvbnMpO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIG1vY2sgYmlrZSBzdGF0aW9ucyBhcm91bmQgdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGVzXG4gICAgY29uc3Qgc3RhdGlvbnM6IEJpa2VEYXRhW10gPSBbXTtcbiAgICBjb25zdCBzdGF0aW9uQ291bnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1KSArIDM7IC8vIDMtNyBzdGF0aW9uc1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXRpb25MYXQgPSBsYXQgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAyICogcmFkaXVzO1xuICAgICAgY29uc3Qgc3RhdGlvbkxuZyA9IGxuZyArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMDIgKiByYWRpdXM7XG4gICAgICBcbiAgICAgIHN0YXRpb25zLnB1c2goe1xuICAgICAgICBzdGF0aW9uX2lkOiBgc3RhdGlvbi0ke2l9YCxcbiAgICAgICAgbmFtZTogYEJpa2UgU3RhdGlvbiAke2kgKyAxfWAsXG4gICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgbGF0OiBzdGF0aW9uTGF0LFxuICAgICAgICAgIGxuZzogc3RhdGlvbkxuZyxcbiAgICAgICAgfSxcbiAgICAgICAgYXZhaWxhYmxlX2Jpa2VzOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNSksXG4gICAgICAgIGF2YWlsYWJsZV9kb2NrczogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApLFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3RhdGlvbnMpO1xuICB9XG5cbiAgLy8gVWJlci9UYXhpIGRhdGFcbiAgYXN5bmMgZ2V0VWJlckVzdGltYXRlKHN0YXJ0TGF0OiBudW1iZXIsIHN0YXJ0TG5nOiBudW1iZXIsIGVuZExhdDogbnVtYmVyLCBlbmRMbmc6IG51bWJlcik6IFByb21pc2U8VWJlckRhdGFbXT4ge1xuICAgIC8vIEluIGEgcmVhbCBhcHAsIHRoaXMgd291bGQgYmUgYW4gQVBJIGNhbGwgdG8gVWJlclxuICAgIC8vIHJldHVybiBheGlvcy5nZXQoYCR7QVBJX0NPTkZJRy5VQkVSX0JBU0VfVVJMfS9lc3RpbWF0ZXMvcHJpY2U/c3RhcnRfbGF0aXR1ZGU9JHtzdGFydExhdH0mc3RhcnRfbG9uZ2l0dWRlPSR7c3RhcnRMbmd9JmVuZF9sYXRpdHVkZT0ke2VuZExhdH0mZW5kX2xvbmdpdHVkZT0ke2VuZExuZ31gKS50aGVuKHJlcyA9PiByZXMuZGF0YS5wcmljZXMpO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIG1vY2sgVWJlciBvcHRpb25zXG4gICAgY29uc3Qgb3B0aW9ucyA9IFtcbiAgICAgIHsgcHJvZHVjdF9pZDogJ3ViZXJ4JywgZGlzcGxheV9uYW1lOiAnVWJlclgnIH0sXG4gICAgICB7IHByb2R1Y3RfaWQ6ICd1YmVyeGwnLCBkaXNwbGF5X25hbWU6ICdVYmVyWEwnIH0sXG4gICAgICB7IHByb2R1Y3RfaWQ6ICd1YmVyYmxhY2snLCBkaXNwbGF5X25hbWU6ICdVYmVyIEJsYWNrJyB9LFxuICAgICAgeyBwcm9kdWN0X2lkOiAndWJlcnBvb2wnLCBkaXNwbGF5X25hbWU6ICdVYmVyIFBvb2wnIH0sXG4gICAgXTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgbW9jayBkdXJhdGlvbiBhbmQgZmFyZSBiYXNlZCBvbiBkaXN0YW5jZVxuICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5jYWxjdWxhdGVEaXN0YW5jZShzdGFydExhdCwgc3RhcnRMbmcsIGVuZExhdCwgZW5kTG5nKTtcbiAgICBcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMubWFwKG9wdGlvbiA9PiAoe1xuICAgICAgLi4ub3B0aW9uLFxuICAgICAgZXN0aW1hdGU6IHtcbiAgICAgICAgZHVyYXRpb246IE1hdGguZmxvb3IoZGlzdGFuY2UgKiAxMjApLCAvLyAxMjAgc2Vjb25kcyBwZXIgbWlsZVxuICAgICAgICBmYXJlOiBNYXRoLmZsb29yKChvcHRpb24ucHJvZHVjdF9pZCA9PT0gJ3ViZXJwb29sJyA/IDIuMCA6IDIuNSkgKiBkaXN0YW5jZSAqIDEwMCkgLyAxMDAsXG4gICAgICB9LFxuICAgIH0pKSk7XG4gIH1cblxuICBhc3luYyBnZXRUYXhpRXN0aW1hdGUoc3RhcnRMYXQ6IG51bWJlciwgc3RhcnRMbmc6IG51bWJlciwgZW5kTGF0OiBudW1iZXIsIGVuZExuZzogbnVtYmVyKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGJlIGFuIEFQSSBjYWxsIG9yIGNhbGN1bGF0aW9uXG4gICAgLy8gcmV0dXJuIGF4aW9zLmdldChgJHtBUElfQ09ORklHLlRBWElfQkFTRV9VUkx9L2VzdGltYXRlP3N0YXJ0X2xhdGl0dWRlPSR7c3RhcnRMYXR9JnN0YXJ0X2xvbmdpdHVkZT0ke3N0YXJ0TG5nfSZlbmRfbGF0aXR1ZGU9JHtlbmRMYXR9JmVuZF9sb25naXR1ZGU9JHtlbmRMbmd9YCkudGhlbihyZXMgPT4gcmVzLmRhdGEuZmFyZSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIG1vY2sgdGF4aSBmYXJlIGJhc2VkIG9uIGRpc3RhbmNlXG4gICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKHN0YXJ0TGF0LCBzdGFydExuZywgZW5kTGF0LCBlbmRMbmcpO1xuICAgIGNvbnN0IGJhc2VGYXJlID0gMi41MDtcbiAgICBjb25zdCBwZXJNaWxlRmFyZSA9IDIuNTA7XG4gICAgXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShNYXRoLmZsb29yKChiYXNlRmFyZSArIGRpc3RhbmNlICogcGVyTWlsZUZhcmUpICogMTAwKSAvIDEwMCk7XG4gIH1cblxuICAvLyBIZWxwZXIgZnVuY3Rpb25zXG4gIHByaXZhdGUgY2FsY3VsYXRlRGlzdGFuY2UobGF0MTogbnVtYmVyLCBsbmcxOiBudW1iZXIsIGxhdDI6IG51bWJlciwgbG5nMjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBSID0gMzk1OC44OyAvLyBFYXJ0aCByYWRpdXMgaW4gbWlsZXNcbiAgICBjb25zdCBkTGF0ID0gdGhpcy50b1JhZGlhbnMobGF0MiAtIGxhdDEpO1xuICAgIGNvbnN0IGRMbmcgPSB0aGlzLnRvUmFkaWFucyhsbmcyIC0gbG5nMSk7XG4gICAgY29uc3QgYSA9XG4gICAgICBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xuICAgICAgTWF0aC5jb3ModGhpcy50b1JhZGlhbnMobGF0MSkpICogTWF0aC5jb3ModGhpcy50b1JhZGlhbnMobGF0MikpICpcbiAgICAgIE1hdGguc2luKGRMbmcgLyAyKSAqIE1hdGguc2luKGRMbmcgLyAyKTtcbiAgICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IFIgKiBjO1xuICAgIFxuICAgIHJldHVybiBkaXN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgdG9SYWRpYW5zKGRlZ3JlZXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xuICB9XG59XG5cbi8vIEV4cG9ydCBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IHRyYW5zaXRBUEkgPSBuZXcgVHJhbnNpdEFQSSgpOyAiXSwibmFtZXMiOlsiQVBJX0NPTkZJRyIsIk1UQV9CQVNFX1VSTCIsIkNJVElCSUtFX0JBU0VfVVJMIiwiVUJFUl9CQVNFX1VSTCIsIkdPT0dMRV9NQVBTX0JBU0VfVVJMIiwibW9ja1N1YndheURhdGEiLCJsaW5lIiwic3RhdHVzIiwiZGVsYXkiLCJjcm93ZF9sZXZlbCIsIm1vY2tCdXNSb3V0ZXMiLCJnZW5lcmF0ZU1vY2tCdXNEYXRhIiwibWFwIiwicm91dGUiLCJsb2NhdGlvbiIsImxhdCIsIk1hdGgiLCJyYW5kb20iLCJsbmciLCJuZXh0X3N0b3AiLCJmbG9vciIsImVzdGltYXRlZF9hcnJpdmFsIiwiRGF0ZSIsIm5vdyIsInRvSVNPU3RyaW5nIiwiVHJhbnNpdEFQSSIsImdldFN1YndheVN0YXR1cyIsIlByb21pc2UiLCJyZXNvbHZlIiwiZ2V0U3Vid2F5TGluZSIsImxpbmVEYXRhIiwiZmluZCIsInN1YndheSIsImdldEJ1c1JvdXRlcyIsImJvcm91Z2giLCJib3JvdWdoUHJlZml4IiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJyb3V0ZXMiLCJmaWx0ZXIiLCJzdGFydHNXaXRoIiwiZ2V0QnVzTG9jYXRpb25zIiwiYnVzRGF0YSIsImJ1cyIsImdldEJpa2VTdGF0aW9ucyIsInJhZGl1cyIsInN0YXRpb25zIiwic3RhdGlvbkNvdW50IiwiaSIsInN0YXRpb25MYXQiLCJzdGF0aW9uTG5nIiwicHVzaCIsInN0YXRpb25faWQiLCJuYW1lIiwiYXZhaWxhYmxlX2Jpa2VzIiwiYXZhaWxhYmxlX2RvY2tzIiwiZ2V0VWJlckVzdGltYXRlIiwic3RhcnRMYXQiLCJzdGFydExuZyIsImVuZExhdCIsImVuZExuZyIsIm9wdGlvbnMiLCJwcm9kdWN0X2lkIiwiZGlzcGxheV9uYW1lIiwiZGlzdGFuY2UiLCJjYWxjdWxhdGVEaXN0YW5jZSIsIm9wdGlvbiIsImVzdGltYXRlIiwiZHVyYXRpb24iLCJmYXJlIiwiZ2V0VGF4aUVzdGltYXRlIiwiYmFzZUZhcmUiLCJwZXJNaWxlRmFyZSIsImxhdDEiLCJsbmcxIiwibGF0MiIsImxuZzIiLCJSIiwiZExhdCIsInRvUmFkaWFucyIsImRMbmciLCJhIiwic2luIiwiY29zIiwiYyIsImF0YW4yIiwic3FydCIsImRlZ3JlZXMiLCJQSSIsInRyYW5zaXRBUEkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./src/lib/api.ts\n");

/***/ }),

/***/ "(api)/./src/pages/api/routes.ts":
/*!*********************************!*\
  !*** ./src/pages/api/routes.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/api */ \"(api)/./src/lib/api.ts\");\n\n// Mock coordinates for some NYC locations\nconst locationCoordinates = {\n    \"Manhattan\": [\n        40.7831,\n        -73.9712\n    ],\n    \"Brooklyn\": [\n        40.6782,\n        -73.9442\n    ],\n    \"Queens\": [\n        40.7282,\n        -73.7949\n    ],\n    \"Bronx\": [\n        40.8448,\n        -73.8648\n    ],\n    \"Staten Island\": [\n        40.5795,\n        -74.1502\n    ],\n    \"Times Square\": [\n        40.7580,\n        -73.9855\n    ],\n    \"Central Park\": [\n        40.7829,\n        -73.9654\n    ],\n    \"Prospect Park\": [\n        40.6602,\n        -73.9690\n    ],\n    \"Flushing Meadows\": [\n        40.7466,\n        -73.8422\n    ],\n    \"Flushing\": [\n        40.7654,\n        -73.8318\n    ],\n    \"Bayside\": [\n        40.7612,\n        -73.7716\n    ],\n    \"Main St\": [\n        40.7590,\n        -73.8300\n    ],\n    \"Yankee Stadium\": [\n        40.8296,\n        -73.9262\n    ]\n};\n// Traffic data mock (in a real app this would be real-time data)\nconst trafficConditions = {\n    \"Manhattan\": {\n        level: \"high\",\n        factor: 1.5\n    },\n    \"Brooklyn\": {\n        level: \"medium\",\n        factor: 1.3\n    },\n    \"Queens\": {\n        level: \"medium\",\n        factor: 1.2\n    },\n    \"Bronx\": {\n        level: \"medium\",\n        factor: 1.25\n    },\n    \"Staten Island\": {\n        level: \"low\",\n        factor: 1.1\n    },\n    \"Flushing\": {\n        level: \"medium\",\n        factor: 1.2\n    },\n    \"Bayside\": {\n        level: \"low\",\n        factor: 1.1\n    },\n    \"Times Square\": {\n        level: \"high\",\n        factor: 1.6\n    },\n    \"Central Park\": {\n        level: \"medium\",\n        factor: 1.3\n    }\n};\n// Topology data - elevation changes that affect walking/biking comfort\nconst topologyDifficulty = {\n    \"Manhattan\": 0.2,\n    \"Brooklyn\": 0.1,\n    \"Queens\": 0.1,\n    \"Bronx\": 0.4,\n    \"Staten Island\": 0.5,\n    \"Flushing\": 0.1,\n    \"Bayside\": 0.2,\n    \"Times Square\": 0.1,\n    \"Central Park\": 0.3\n};\n// Helper function to get coordinates from a location string\nconst getCoordinates = (location)=>{\n    // Normalize the location string for better matching\n    const normalizedLocation = location.toLowerCase();\n    // First try exact matches for specific neighborhoods/locations\n    for (const [name, coords] of Object.entries(locationCoordinates)){\n        if (normalizedLocation.includes(name.toLowerCase())) {\n            return coords;\n        }\n    }\n    // If no specific match, try to determine which borough it's in\n    if (normalizedLocation.includes(\"queens\") || normalizedLocation.includes(\"flushing\") || normalizedLocation.includes(\"bayside\") || normalizedLocation.includes(\"jamaica\") || normalizedLocation.includes(\"astoria\")) {\n        return locationCoordinates[\"Queens\"];\n    }\n    if (normalizedLocation.includes(\"brooklyn\") || normalizedLocation.includes(\"williamsburg\") || normalizedLocation.includes(\"park slope\")) {\n        return locationCoordinates[\"Brooklyn\"];\n    }\n    if (normalizedLocation.includes(\"bronx\")) {\n        return locationCoordinates[\"Bronx\"];\n    }\n    if (normalizedLocation.includes(\"staten\")) {\n        return locationCoordinates[\"Staten Island\"];\n    }\n    // Default to Manhattan if not found\n    return locationCoordinates[\"Manhattan\"];\n};\n// Helper function to calculate distance between two coordinates\nconst calculateDistance = (lat1, lng1, lat2, lng2)=>{\n    const R = 3958.8; // Earth radius in miles\n    const dLat = (lat2 - lat1) * Math.PI / 180;\n    const dLng = (lng2 - lng1) * Math.PI / 180;\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c;\n    return distance;\n};\n// Define the route colors for different modes\nconst getRouteColor = (mode)=>{\n    switch(mode){\n        case \"subway\":\n            return \"#3b82f6\"; // blue-500\n        case \"bus\":\n            return \"#22c55e\"; // green-500\n        case \"walk\":\n            return \"#6b7280\"; // gray-500\n        case \"bike\":\n        case \"ebike\":\n            return \"#8b5cf6\"; // purple-500\n        case \"ferry\":\n            return \"#06b6d4\"; // cyan-500\n        case \"taxi\":\n        case \"uber\":\n            return \"#f59e0b\"; // amber-500\n        default:\n            return \"#ef4444\"; // red-500\n    }\n};\n// Add this after getRouteColor function and before interface RouteItem\nconst calculateCO2Emissions = (mode, distanceKm)=>{\n    // CO2 emissions in grams per kilometer\n    const emissionsFactors = {\n        \"subway\": 30,\n        \"bus\": 70,\n        \"walk\": 0,\n        \"bike\": 0,\n        \"ebike\": 5,\n        \"ferry\": 120,\n        \"taxi\": 150,\n        \"uber\": 150,\n        \"shared\": 90,\n        \"default\": 100 // Default value\n    };\n    // If mode is walking or biking, return 0 regardless of distance\n    if (mode === \"walk\" || mode === \"bike\") {\n        return 0;\n    }\n    const emissionFactor = emissionsFactors[mode] || emissionsFactors.default;\n    return Math.round(emissionFactor * distanceKm);\n};\nasync function handler(req, res) {\n    if (req.method !== \"GET\") {\n        return res.status(405).json({\n            message: \"Method Not Allowed\"\n        });\n    }\n    const { from, to, priority, noise, safety, bags, wheelchair } = req.query;\n    if (!from || !to) {\n        return res.status(400).json({\n            message: \"Origin and destination are required\"\n        });\n    }\n    try {\n        // In a real app, we would use geocoding to get coordinates\n        const fromCoords = getCoordinates(from);\n        const toCoords = getCoordinates(to);\n        // Log the coordinates for debugging\n        console.log(`From location: \"${from}\" → coordinates: [${fromCoords[0]}, ${fromCoords[1]}]`);\n        console.log(`To location: \"${to}\" → coordinates: [${toCoords[0]}, ${toCoords[1]}]`);\n        // Get user preferences\n        const userPriority = priority || \"balanced\";\n        const userNoise = noise || \"moderate\";\n        const userSafety = safety || \"moderate\";\n        const userBags = parseInt(bags || \"0\", 10);\n        const requireWheelchair = wheelchair === \"true\";\n        // Calculate distance\n        const distance = calculateDistance(fromCoords[0], fromCoords[1], toCoords[0], toCoords[1]);\n        // Get real-time transit data\n        const subwayStatus = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.transitAPI.getSubwayStatus();\n        // Determine available subway lines based on location\n        const subwayLinesByLocation = {\n            \"Manhattan\": [\n                \"1\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"A\",\n                \"C\",\n                \"E\",\n                \"B\",\n                \"D\",\n                \"F\",\n                \"M\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"W\",\n                \"L\"\n            ],\n            \"Brooklyn\": [\n                \"A\",\n                \"C\",\n                \"G\",\n                \"J\",\n                \"Z\",\n                \"L\",\n                \"M\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"2\",\n                \"3\",\n                \"4\",\n                \"5\"\n            ],\n            \"Queens\": [\n                \"E\",\n                \"F\",\n                \"M\",\n                \"R\",\n                \"N\",\n                \"W\",\n                \"G\",\n                \"7\"\n            ],\n            \"Bronx\": [\n                \"1\",\n                \"2\",\n                \"4\",\n                \"5\",\n                \"6\",\n                \"B\",\n                \"D\"\n            ],\n            \"Staten Island\": [\n                \"SIR\"\n            ],\n            \"Flushing\": [\n                \"7\"\n            ],\n            \"Main St\": [\n                \"7\"\n            ],\n            \"Times Square\": [\n                \"1\",\n                \"2\",\n                \"3\",\n                \"N\",\n                \"Q\",\n                \"R\",\n                \"W\",\n                \"7\",\n                \"S\"\n            ],\n            \"Central Park\": [\n                \"A\",\n                \"B\",\n                \"C\",\n                \"D\",\n                \"1\"\n            ],\n            \"Yankee Stadium\": [\n                \"4\",\n                \"B\",\n                \"D\"\n            ],\n            \"JFK Airport\": [\n                \"A\",\n                \"E\"\n            ],\n            \"LaGuardia Airport\": [],\n            \"Prospect Park\": [\n                \"B\",\n                \"Q\",\n                \"S\"\n            ]\n        };\n        // Determine from and to areas to check subway availability\n        const fromArea = Object.keys(locationCoordinates).find((area)=>from.toLowerCase().includes(area.toLowerCase())) || \"Manhattan\";\n        const toArea = Object.keys(locationCoordinates).find((area)=>to.toLowerCase().includes(area.toLowerCase())) || \"Manhattan\";\n        // Check available subway lines for the route\n        const fromSubwayLines = subwayLinesByLocation[fromArea] || [];\n        const toSubwayLines = subwayLinesByLocation[toArea] || [];\n        // Find common subway lines or lines that can get you there with a transfer\n        let availableSubwayLines = fromSubwayLines.filter((line)=>toSubwayLines.includes(line));\n        // If no direct lines, consider options with transfers\n        const hasTransferOptions = fromSubwayLines.length > 0 && toSubwayLines.length > 0;\n        // Check subway status to see if the lines are operating normally\n        const operatingSubwayLines = availableSubwayLines.filter((line)=>{\n            const lineStatus = subwayStatus.find((s)=>s.line === line);\n            return lineStatus && lineStatus.status === \"normal\";\n        });\n        // Filter to just get one operating line if available\n        const bestSubwayLine = operatingSubwayLines.length > 0 ? operatingSubwayLines[0] : null;\n        // Get all the bus routes for both areas\n        const fromBoroughPrefix = fromArea.charAt(0).toUpperCase();\n        const toBoroughPrefix = toArea.charAt(0).toUpperCase();\n        const busRoutesFrom = await _lib_api__WEBPACK_IMPORTED_MODULE_0__.transitAPI.getBusRoutes(fromArea);\n        // Map specific neighborhoods to appropriate bus routes\n        const busRoutesByArea = {\n            \"Manhattan\": [\n                \"M1\",\n                \"M2\",\n                \"M3\",\n                \"M4\",\n                \"M5\",\n                \"M15\",\n                \"M31\",\n                \"M42\",\n                \"M60\"\n            ],\n            \"Brooklyn\": [\n                \"B41\",\n                \"B42\",\n                \"B44\",\n                \"B46\",\n                \"B67\",\n                \"B68\",\n                \"B69\"\n            ],\n            \"Queens\": [\n                \"Q58\",\n                \"Q59\",\n                \"Q60\",\n                \"Q65\",\n                \"Q66\",\n                \"Q44\",\n                \"Q46\"\n            ],\n            \"Bronx\": [\n                \"BX1\",\n                \"BX2\",\n                \"BX9\",\n                \"BX10\",\n                \"BX12\",\n                \"BX22\"\n            ],\n            \"Staten Island\": [\n                \"S40\",\n                \"S44\",\n                \"S46\",\n                \"S48\",\n                \"S51\",\n                \"S53\"\n            ],\n            \"Flushing\": [\n                \"Q65\",\n                \"Q66\",\n                \"Q17\",\n                \"Q27\",\n                \"Q44\"\n            ],\n            \"Bayside\": [\n                \"Q27\",\n                \"Q31\",\n                \"Q76\",\n                \"Q13\"\n            ],\n            \"Times Square\": [\n                \"M42\",\n                \"M104\",\n                \"Q104\"\n            ],\n            \"JFK Airport\": [\n                \"Q3\",\n                \"Q10\",\n                \"B15\"\n            ],\n            \"LaGuardia Airport\": [\n                \"Q70\",\n                \"M60\"\n            ]\n        };\n        // Get specific bus routes for origin and destination\n        const specificFromBuses = busRoutesByArea[fromArea] || [];\n        const specificToBuses = busRoutesByArea[toArea] || [];\n        // Find bus routes that might connect the two areas\n        let connectingBuses = specificFromBuses.filter((bus)=>specificToBuses.includes(bus));\n        // Check if origin and destination are in different boroughs\n        const originBorough = fromArea === \"Manhattan\" || fromArea === \"Times Square\" || fromArea === \"Central Park\" ? \"Manhattan\" : fromArea === \"Brooklyn\" || fromArea === \"Prospect Park\" ? \"Brooklyn\" : fromArea === \"Queens\" || fromArea === \"Flushing\" || fromArea === \"Bayside\" || fromArea === \"JFK Airport\" ? \"Queens\" : fromArea === \"Bronx\" || fromArea === \"Yankee Stadium\" ? \"Bronx\" : fromArea === \"Staten Island\" ? \"Staten Island\" : \"Manhattan\";\n        const destinationBorough = toArea === \"Manhattan\" || toArea === \"Times Square\" || toArea === \"Central Park\" ? \"Manhattan\" : toArea === \"Brooklyn\" || toArea === \"Prospect Park\" ? \"Brooklyn\" : toArea === \"Queens\" || toArea === \"Flushing\" || toArea === \"Bayside\" || toArea === \"JFK Airport\" ? \"Queens\" : toArea === \"Bronx\" || toArea === \"Yankee Stadium\" ? \"Bronx\" : toArea === \"Staten Island\" ? \"Staten Island\" : \"Manhattan\";\n        // Check if this is a cross-borough trip requiring transfers\n        const isCrossBoroughTrip = originBorough !== destinationBorough;\n        // Express Bus routes for cross-borough travel\n        const expressBusRoutes = {\n            \"Queens-Manhattan\": [\n                \"QM1\",\n                \"QM5\",\n                \"QM7\",\n                \"QM8\"\n            ],\n            \"Brooklyn-Manhattan\": [\n                \"BM1\",\n                \"BM2\",\n                \"BM3\",\n                \"BM4\"\n            ],\n            \"Bronx-Manhattan\": [\n                \"BxM1\",\n                \"BxM2\",\n                \"BxM3\",\n                \"BxM4\"\n            ],\n            \"Staten Island-Manhattan\": [\n                \"SIM1\",\n                \"SIM3\",\n                \"SIM4\",\n                \"SIM5\"\n            ]\n        };\n        // Get appropriate express bus if this is cross-borough\n        let expressBusRoute = \"\";\n        if (isCrossBoroughTrip) {\n            const routeKey = `${originBorough}-${destinationBorough}`;\n            const reverseRouteKey = `${destinationBorough}-${originBorough}`;\n            if (expressBusRoutes[routeKey]) {\n                expressBusRoute = expressBusRoutes[routeKey][0];\n            } else if (expressBusRoutes[reverseRouteKey]) {\n                expressBusRoute = expressBusRoutes[reverseRouteKey][0];\n            }\n        }\n        // If no direct connection, pick a bus from origin for local trips only\n        // For cross-borough trips without express buses, we'll rely on subway instead\n        if (connectingBuses.length === 0 && specificFromBuses.length > 0 && !isCrossBoroughTrip) {\n            connectingBuses = [\n                specificFromBuses[0]\n            ];\n        }\n        // Default to a borough-specific bus if nothing else is available\n        const busRoute = connectingBuses.length > 0 ? connectingBuses[0] : expressBusRoute || `${fromBoroughPrefix}${Math.floor(Math.random() * 50) + 1}`;\n        // Get traffic conditions for origin and destination areas\n        const originTraffic = trafficConditions[originBorough] || {\n            level: \"medium\",\n            factor: 1.25\n        };\n        const destinationTraffic = trafficConditions[destinationBorough] || {\n            level: \"medium\",\n            factor: 1.25\n        };\n        // Get topology difficulty for each area\n        const originTopology = topologyDifficulty[originBorough] || 0.2;\n        const destinationTopology = topologyDifficulty[destinationBorough] || 0.2;\n        // Calculate average traffic and topology difficulty\n        const avgTrafficFactor = (originTraffic.factor + destinationTraffic.factor) / 2;\n        const avgTopologyDifficulty = (originTopology + destinationTopology) / 2;\n        const generateRoutes = ()=>{\n            const routes = [];\n            // Helper function to calculate balanced score\n            const calculateBalancedScore = (duration, cost, comfort, numTransfers)=>{\n                // Simple scoring system\n                const timeScore = Math.max(0, 1 - duration / 120); // Normalize to 0-1 (2 hours max)\n                const costScore = Math.max(0, 1 - cost / 30); // Normalize to 0-1 ($30 max)\n                const comfortScore = comfort === \"high\" ? 1 : comfort === \"medium\" ? 0.6 : 0.3;\n                const transferScore = Math.max(0, 1 - numTransfers * 0.2);\n                // Weighted average\n                const score = timeScore * 0.4 + costScore * 0.3 + comfortScore * 0.2 + transferScore * 0.1;\n                return {\n                    raw: score,\n                    score: Math.round(score * 10),\n                    timeScore: Math.round(timeScore * 10),\n                    costScore: Math.round(costScore * 10),\n                    comfortScore: Math.round(comfortScore * 10),\n                    transferScore: Math.round(transferScore * 10)\n                };\n            };\n            // Always add a walking route as a baseline option\n            const walkingRoute = {\n                id: \"0\",\n                name: \"Walking Route\",\n                duration: Math.round(distance * 20),\n                cost: 0,\n                comfort: \"medium\",\n                vectorScore: 0.5,\n                segments: [\n                    {\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: to,\n                        duration: Math.round(distance * 20),\n                        cost: 0,\n                        lineInfo: \"Walk to destination\"\n                    }\n                ]\n            };\n            walkingRoute.balancedScore = calculateBalancedScore(walkingRoute.duration, walkingRoute.cost, walkingRoute.comfort, 0);\n            // Calculate CO2 for walking (0 emissions)\n            walkingRoute.co2 = calculateCO2Emissions(\"walk\", distance * 1.60934); // Convert miles to km\n            routes.push(walkingRoute);\n            // Add a bike route if distance is reasonable (less than 10 miles)\n            if (distance < 10) {\n                const bikeRoute = {\n                    id: \"1\",\n                    name: \"Bike Route\",\n                    duration: Math.round(distance * 12),\n                    cost: 3.50,\n                    comfort: \"medium\",\n                    vectorScore: 0.65,\n                    segments: [\n                        {\n                            mode: \"bike\",\n                            startLocation: from,\n                            endLocation: to,\n                            duration: Math.round(distance * 12),\n                            cost: 3.50,\n                            lineInfo: \"Citi Bike\"\n                        }\n                    ]\n                };\n                bikeRoute.balancedScore = calculateBalancedScore(bikeRoute.duration, bikeRoute.cost, bikeRoute.comfort, 0);\n                // Calculate CO2 for biking (0 emissions)\n                bikeRoute.co2 = calculateCO2Emissions(\"bike\", distance * 1.60934);\n                routes.push(bikeRoute);\n            }\n            // Add subway routes if available\n            if (bestSubwayLine || hasTransferOptions) {\n                const subwayRoute = {\n                    id: \"2\",\n                    name: \"Subway Route\",\n                    duration: Math.round(distance * 8) + 10,\n                    cost: 2.90,\n                    comfort: \"high\",\n                    vectorScore: 0.8,\n                    segments: [\n                        {\n                            mode: \"walk\",\n                            startLocation: from,\n                            endLocation: \"Subway Station\",\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to station\"\n                        },\n                        {\n                            mode: \"subway\",\n                            startLocation: \"Subway Station\",\n                            endLocation: \"Subway Station\",\n                            duration: Math.round(distance * 8),\n                            cost: 2.90,\n                            lineInfo: bestSubwayLine ? `${bestSubwayLine} Train` : \"Subway\"\n                        },\n                        {\n                            mode: \"walk\",\n                            startLocation: \"Subway Station\",\n                            endLocation: to,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to destination\"\n                        }\n                    ]\n                };\n                subwayRoute.balancedScore = calculateBalancedScore(subwayRoute.duration, subwayRoute.cost, subwayRoute.comfort, 0);\n                // Calculate CO2 for subway route (walking + subway segments)\n                subwayRoute.co2 = calculateCO2Emissions(\"walk\", 0.4) + // Assuming 0.4 km walking total\n                calculateCO2Emissions(\"subway\", distance * 1.60934); // Main subway journey\n                routes.push(subwayRoute);\n            }\n            // Add bus route\n            const busRoute = {\n                id: \"3\",\n                name: \"Bus Route\",\n                duration: Math.round(distance * 15) + 10,\n                cost: 2.90,\n                comfort: \"medium\",\n                vectorScore: 0.6,\n                segments: [\n                    {\n                        mode: \"walk\",\n                        startLocation: from,\n                        endLocation: \"Bus Stop\",\n                        duration: 5,\n                        cost: 0,\n                        lineInfo: \"Walk to bus stop\"\n                    },\n                    {\n                        mode: \"bus\",\n                        startLocation: \"Bus Stop\",\n                        endLocation: \"Bus Stop\",\n                        duration: Math.round(distance * 15),\n                        cost: 2.90,\n                        lineInfo: `Local Bus`\n                    },\n                    {\n                        mode: \"walk\",\n                        startLocation: \"Bus Stop\",\n                        endLocation: to,\n                        duration: 5,\n                        cost: 0,\n                        lineInfo: \"Walk to destination\"\n                    }\n                ]\n            };\n            busRoute.balancedScore = calculateBalancedScore(busRoute.duration, busRoute.cost, busRoute.comfort, 0);\n            // Calculate CO2 for bus route (walking + bus segments)\n            busRoute.co2 = calculateCO2Emissions(\"walk\", 0.4) + // Assuming 0.4 km walking total\n            calculateCO2Emissions(\"bus\", distance * 1.60934); // Main bus journey\n            routes.push(busRoute);\n            // Add express bus for longer distances\n            if (distance > 5) {\n                const expressBusRoute = {\n                    id: \"4\",\n                    name: \"Express Bus Route\",\n                    duration: Math.round(distance * 10) + 10,\n                    cost: 7.00,\n                    comfort: \"high\",\n                    vectorScore: 0.75,\n                    segments: [\n                        {\n                            mode: \"walk\",\n                            startLocation: from,\n                            endLocation: \"Express Bus Stop\",\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to bus stop\"\n                        },\n                        {\n                            mode: \"bus\",\n                            startLocation: \"Express Bus Stop\",\n                            endLocation: \"Express Bus Stop\",\n                            duration: Math.round(distance * 10),\n                            cost: 7.00,\n                            lineInfo: \"Express Bus\"\n                        },\n                        {\n                            mode: \"walk\",\n                            startLocation: \"Express Bus Stop\",\n                            endLocation: to,\n                            duration: 5,\n                            cost: 0,\n                            lineInfo: \"Walk to destination\"\n                        }\n                    ]\n                };\n                expressBusRoute.balancedScore = calculateBalancedScore(expressBusRoute.duration, expressBusRoute.cost, expressBusRoute.comfort, 0);\n                // Calculate CO2 for express bus route (walking + bus segments)\n                expressBusRoute.co2 = calculateCO2Emissions(\"walk\", 0.4) + // Assuming 0.4 km walking total\n                calculateCO2Emissions(\"bus\", distance * 1.60934); // Main bus journey\n                routes.push(expressBusRoute);\n            }\n            // Add a ride-sharing route as another option\n            const uberRoute = {\n                id: \"5\",\n                name: \"Ride-Share Route\",\n                duration: Math.round(distance * 3),\n                cost: parseFloat((distance * 2.5).toFixed(2)),\n                comfort: \"high\",\n                vectorScore: 0.78,\n                segments: [\n                    {\n                        mode: \"uber\",\n                        startLocation: from,\n                        endLocation: to,\n                        duration: Math.round(distance * 3),\n                        cost: parseFloat((distance * 2.5).toFixed(2)),\n                        lineInfo: \"UberX\"\n                    }\n                ]\n            };\n            uberRoute.balancedScore = calculateBalancedScore(uberRoute.duration, uberRoute.cost, uberRoute.comfort, 0);\n            // Calculate CO2 for ride-share route\n            uberRoute.co2 = calculateCO2Emissions(\"uber\", distance * 1.60934);\n            routes.push(uberRoute);\n            // Sort routes by balanced score (highest first)\n            routes.sort((a, b)=>(b.balancedScore?.score || 0) - (a.balancedScore?.score || 0));\n            return routes;\n        };\n        const routes = generateRoutes();\n        // Helper function to finalize route details\n        const finalizeRoute = (route)=>{\n            // Calculate number of transfers\n            const numTransfers = route.segments.length > 0 ? route.segments.length - 1 : 0;\n            // Check if route has walking/biking components\n            const hasTopologyImpact = route.segments.some((segment)=>segment.mode === \"walk\" || segment.mode === \"ebike\");\n            // Calculate traffic impact for road-based segments\n            const roadBasedSegments = route.segments.filter((segment)=>segment.mode === \"bus\" || segment.mode === \"uber\" || segment.mode === \"taxi\");\n            const trafficImpact = roadBasedSegments.length > 0 ? avgTrafficFactor : 1.0;\n            // Calculate ETA\n            const now = new Date();\n            const eta = new Date(now.getTime() + route.duration * 60000);\n            // Add route color based on mode\n            const routeColor = getRouteColor(route.segments[0]?.mode || \"walk\");\n            // Return enhanced route\n            return {\n                ...route,\n                numTransfers,\n                hasTopologyImpact,\n                traffic: {\n                    level: trafficImpact > 1.3 ? \"high\" : trafficImpact > 1.1 ? \"medium\" : \"low\",\n                    impact: trafficImpact\n                },\n                eta: eta.toLocaleTimeString([], {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\"\n                }),\n                routeColor,\n                isWheelchairAccessible: true\n            };\n        };\n        const mockRoutes = routes.map(finalizeRoute);\n        // Only sort if we have routes\n        if (mockRoutes.length > 0) {\n            // Sort routes by their balanced score (highest to lowest)\n            mockRoutes.sort((a, b)=>{\n                // Ensure we have valid scores\n                const scoreA = a.scores?.overall || a.balancedScore?.score || 0;\n                const scoreB = b.scores?.overall || b.balancedScore?.score || 0;\n                // Sort in descending order (highest score first)\n                if (scoreA !== scoreB) {\n                    return scoreB - scoreA;\n                }\n                // If scores are equal, prefer faster routes first\n                return (a.duration || 0) - (b.duration || 0);\n            });\n            // Add \"best\" indicator to the first route (now the best one)\n            mockRoutes[0].name = `${mockRoutes[0].name} (Best Route)`;\n        }\n        // Return error if no routes found\n        if (mockRoutes.length === 0) {\n            return res.status(404).json({\n                error: \"No routes found\",\n                message: \"We couldn't find any routes between these locations. Please try different locations or adjust your preferences.\"\n            });\n        }\n        // Return the sorted routes\n        return res.status(200).json({\n            routes: mockRoutes.slice(0, 6),\n            distance,\n            fromCoords,\n            toCoords,\n            subwayAvailable: bestSubwayLine !== null || hasTransferOptions,\n            transferRequired: !bestSubwayLine && hasTransferOptions,\n            traffic: {\n                origin: originTraffic,\n                destination: destinationTraffic,\n                average: avgTrafficFactor\n            },\n            topology: {\n                origin: originTopology,\n                destination: destinationTopology,\n                average: avgTopologyDifficulty\n            }\n        });\n    } catch (error) {\n        console.error(\"Error calculating routes:\", error);\n        return res.status(500).json({\n            message: \"Error calculating routes\"\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cy9hcGkvcm91dGVzLnRzP2YxNGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCc7XG5pbXBvcnQgeyB0cmFuc2l0QVBJIH0gZnJvbSAnQC9saWIvYXBpJztcbmltcG9ydCB7IHRyYW5zcG9ydE1vZGVzLCBmaW5kT3B0aW1hbFJvdXRlcyB9IGZyb20gJ0AvdXRpbHMvdmVjdG9yQ2FsY3VsYXRpb24nO1xuaW1wb3J0IHsgc3Vid2F5Um91dGVzLCBidXNSb3V0ZXMsIGZpbmRDbG9zZXN0UG9pbnRPblJvdXRlLCBnZXRSb3V0ZVNlZ21lbnQsIG10YVJvdXRlcyB9IGZyb20gJ0AvZGF0YS9tdGEtcm91dGVzJztcblxuLy8gTW9jayBjb29yZGluYXRlcyBmb3Igc29tZSBOWUMgbG9jYXRpb25zXG5jb25zdCBsb2NhdGlvbkNvb3JkaW5hdGVzOiBSZWNvcmQ8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdPiA9IHtcbiAgJ01hbmhhdHRhbic6IFs0MC43ODMxLCAtNzMuOTcxMl0sXG4gICdCcm9va2x5bic6IFs0MC42NzgyLCAtNzMuOTQ0Ml0sXG4gICdRdWVlbnMnOiBbNDAuNzI4MiwgLTczLjc5NDldLFxuICAnQnJvbngnOiBbNDAuODQ0OCwgLTczLjg2NDhdLFxuICAnU3RhdGVuIElzbGFuZCc6IFs0MC41Nzk1LCAtNzQuMTUwMl0sXG4gICdUaW1lcyBTcXVhcmUnOiBbNDAuNzU4MCwgLTczLjk4NTVdLFxuICAnQ2VudHJhbCBQYXJrJzogWzQwLjc4MjksIC03My45NjU0XSxcbiAgJ1Byb3NwZWN0IFBhcmsnOiBbNDAuNjYwMiwgLTczLjk2OTBdLFxuICAnRmx1c2hpbmcgTWVhZG93cyc6IFs0MC43NDY2LCAtNzMuODQyMl0sXG4gICdGbHVzaGluZyc6IFs0MC43NjU0LCAtNzMuODMxOF0sXG4gICdCYXlzaWRlJzogWzQwLjc2MTIsIC03My43NzE2XSxcbiAgJ01haW4gU3QnOiBbNDAuNzU5MCwgLTczLjgzMDBdLFxuICAnWWFua2VlIFN0YWRpdW0nOiBbNDAuODI5NiwgLTczLjkyNjJdLFxufTtcblxuLy8gVHJhZmZpYyBkYXRhIG1vY2sgKGluIGEgcmVhbCBhcHAgdGhpcyB3b3VsZCBiZSByZWFsLXRpbWUgZGF0YSlcbmNvbnN0IHRyYWZmaWNDb25kaXRpb25zOiBSZWNvcmQ8c3RyaW5nLCB7IGxldmVsOiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnLCBmYWN0b3I6IG51bWJlciB9PiA9IHtcbiAgJ01hbmhhdHRhbic6IHsgbGV2ZWw6ICdoaWdoJywgZmFjdG9yOiAxLjUgfSxcbiAgJ0Jyb29rbHluJzogeyBsZXZlbDogJ21lZGl1bScsIGZhY3RvcjogMS4zIH0sXG4gICdRdWVlbnMnOiB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjIgfSxcbiAgJ0Jyb254JzogeyBsZXZlbDogJ21lZGl1bScsIGZhY3RvcjogMS4yNSB9LFxuICAnU3RhdGVuIElzbGFuZCc6IHsgbGV2ZWw6ICdsb3cnLCBmYWN0b3I6IDEuMSB9LFxuICAnRmx1c2hpbmcnOiB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjIgfSxcbiAgJ0JheXNpZGUnOiB7IGxldmVsOiAnbG93JywgZmFjdG9yOiAxLjEgfSxcbiAgJ1RpbWVzIFNxdWFyZSc6IHsgbGV2ZWw6ICdoaWdoJywgZmFjdG9yOiAxLjYgfSxcbiAgJ0NlbnRyYWwgUGFyayc6IHsgbGV2ZWw6ICdtZWRpdW0nLCBmYWN0b3I6IDEuMyB9LFxufTtcblxuLy8gVG9wb2xvZ3kgZGF0YSAtIGVsZXZhdGlvbiBjaGFuZ2VzIHRoYXQgYWZmZWN0IHdhbGtpbmcvYmlraW5nIGNvbWZvcnRcbmNvbnN0IHRvcG9sb2d5RGlmZmljdWx0eTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgJ01hbmhhdHRhbic6IDAuMiwgLy8gU29tZSBoaWxsc1xuICAnQnJvb2tseW4nOiAwLjEsIC8vIE1vc3RseSBmbGF0XG4gICdRdWVlbnMnOiAwLjEsIC8vIE1vc3RseSBmbGF0XG4gICdCcm9ueCc6IDAuNCwgLy8gSGlsbHlcbiAgJ1N0YXRlbiBJc2xhbmQnOiAwLjUsIC8vIFZlcnkgaGlsbHlcbiAgJ0ZsdXNoaW5nJzogMC4xLCAvLyBNb3N0bHkgZmxhdFxuICAnQmF5c2lkZSc6IDAuMiwgLy8gU29tZSBoaWxsc1xuICAnVGltZXMgU3F1YXJlJzogMC4xLCAvLyBGbGF0XG4gICdDZW50cmFsIFBhcmsnOiAwLjMsIC8vIFJvbGxpbmcgaGlsbHNcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgY29vcmRpbmF0ZXMgZnJvbSBhIGxvY2F0aW9uIHN0cmluZ1xuY29uc3QgZ2V0Q29vcmRpbmF0ZXMgPSAobG9jYXRpb246IHN0cmluZyk6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xuICAvLyBOb3JtYWxpemUgdGhlIGxvY2F0aW9uIHN0cmluZyBmb3IgYmV0dGVyIG1hdGNoaW5nXG4gIGNvbnN0IG5vcm1hbGl6ZWRMb2NhdGlvbiA9IGxvY2F0aW9uLnRvTG93ZXJDYXNlKCk7XG4gIFxuICAvLyBGaXJzdCB0cnkgZXhhY3QgbWF0Y2hlcyBmb3Igc3BlY2lmaWMgbmVpZ2hib3Job29kcy9sb2NhdGlvbnNcbiAgZm9yIChjb25zdCBbbmFtZSwgY29vcmRzXSBvZiBPYmplY3QuZW50cmllcyhsb2NhdGlvbkNvb3JkaW5hdGVzKSkge1xuICAgIGlmIChub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9XG4gIH1cbiAgXG4gIC8vIElmIG5vIHNwZWNpZmljIG1hdGNoLCB0cnkgdG8gZGV0ZXJtaW5lIHdoaWNoIGJvcm91Z2ggaXQncyBpblxuICBpZiAobm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKCdxdWVlbnMnKSB8fCBcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnZmx1c2hpbmcnKSB8fCBcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnYmF5c2lkZScpIHx8XG4gICAgICBub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMoJ2phbWFpY2EnKSB8fFxuICAgICAgbm9ybWFsaXplZExvY2F0aW9uLmluY2x1ZGVzKCdhc3RvcmlhJykpIHtcbiAgICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snUXVlZW5zJ107XG4gIH1cbiAgXG4gIGlmIChub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMoJ2Jyb29rbHluJykgfHxcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnd2lsbGlhbXNidXJnJykgfHxcbiAgICAgIG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygncGFyayBzbG9wZScpKSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uQ29vcmRpbmF0ZXNbJ0Jyb29rbHluJ107XG4gIH1cbiAgXG4gIGlmIChub3JtYWxpemVkTG9jYXRpb24uaW5jbHVkZXMoJ2Jyb254JykpIHtcbiAgICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snQnJvbngnXTtcbiAgfVxuICBcbiAgaWYgKG5vcm1hbGl6ZWRMb2NhdGlvbi5pbmNsdWRlcygnc3RhdGVuJykpIHtcbiAgICByZXR1cm4gbG9jYXRpb25Db29yZGluYXRlc1snU3RhdGVuIElzbGFuZCddO1xuICB9XG4gIFxuICAvLyBEZWZhdWx0IHRvIE1hbmhhdHRhbiBpZiBub3QgZm91bmRcbiAgcmV0dXJuIGxvY2F0aW9uQ29vcmRpbmF0ZXNbJ01hbmhhdHRhbiddO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuY29uc3QgY2FsY3VsYXRlRGlzdGFuY2UgPSAoXG4gIGxhdDE6IG51bWJlciwgXG4gIGxuZzE6IG51bWJlciwgXG4gIGxhdDI6IG51bWJlciwgXG4gIGxuZzI6IG51bWJlclxuKTogbnVtYmVyID0+IHtcbiAgY29uc3QgUiA9IDM5NTguODsgLy8gRWFydGggcmFkaXVzIGluIG1pbGVzXG4gIGNvbnN0IGRMYXQgPSAobGF0MiAtIGxhdDEpICogTWF0aC5QSSAvIDE4MDtcbiAgY29uc3QgZExuZyA9IChsbmcyIC0gbG5nMSkgKiBNYXRoLlBJIC8gMTgwO1xuICBjb25zdCBhID1cbiAgICBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xuICAgIE1hdGguY29zKGxhdDEgKiBNYXRoLlBJIC8gMTgwKSAqIE1hdGguY29zKGxhdDIgKiBNYXRoLlBJIC8gMTgwKSAqXG4gICAgTWF0aC5zaW4oZExuZyAvIDIpICogTWF0aC5zaW4oZExuZyAvIDIpO1xuICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcbiAgY29uc3QgZGlzdGFuY2UgPSBSICogYztcbiAgXG4gIHJldHVybiBkaXN0YW5jZTtcbn07XG5cbi8vIERlZmluZSB0aGUgcm91dGUgY29sb3JzIGZvciBkaWZmZXJlbnQgbW9kZXNcbmNvbnN0IGdldFJvdXRlQ29sb3IgPSAobW9kZTogc3RyaW5nKSA9PiB7XG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ3N1YndheSc6XG4gICAgICByZXR1cm4gJyMzYjgyZjYnOyAgLy8gYmx1ZS01MDBcbiAgICBjYXNlICdidXMnOlxuICAgICAgcmV0dXJuICcjMjJjNTVlJzsgIC8vIGdyZWVuLTUwMFxuICAgIGNhc2UgJ3dhbGsnOlxuICAgICAgcmV0dXJuICcjNmI3MjgwJzsgIC8vIGdyYXktNTAwXG4gICAgY2FzZSAnYmlrZSc6XG4gICAgY2FzZSAnZWJpa2UnOlxuICAgICAgcmV0dXJuICcjOGI1Y2Y2JzsgIC8vIHB1cnBsZS01MDBcbiAgICBjYXNlICdmZXJyeSc6XG4gICAgICByZXR1cm4gJyMwNmI2ZDQnOyAgLy8gY3lhbi01MDBcbiAgICBjYXNlICd0YXhpJzpcbiAgICBjYXNlICd1YmVyJzpcbiAgICAgIHJldHVybiAnI2Y1OWUwYic7ICAvLyBhbWJlci01MDBcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcjZWY0NDQ0JzsgIC8vIHJlZC01MDBcbiAgfVxufTtcblxuLy8gQWRkIHRoaXMgYWZ0ZXIgZ2V0Um91dGVDb2xvciBmdW5jdGlvbiBhbmQgYmVmb3JlIGludGVyZmFjZSBSb3V0ZUl0ZW1cbmNvbnN0IGNhbGN1bGF0ZUNPMkVtaXNzaW9ucyA9IChtb2RlOiBzdHJpbmcsIGRpc3RhbmNlS206IG51bWJlcik6IG51bWJlciA9PiB7XG4gIC8vIENPMiBlbWlzc2lvbnMgaW4gZ3JhbXMgcGVyIGtpbG9tZXRlclxuICBjb25zdCBlbWlzc2lvbnNGYWN0b3JzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xuICAgICdzdWJ3YXknOiAzMCwgICAgIC8vIEVsZWN0cmljIHN1YndheVxuICAgICdidXMnOiA3MCwgICAgICAgIC8vIEJ1cyAoZGllc2VsKVxuICAgICd3YWxrJzogMCwgICAgICAgIC8vIFdhbGtpbmcgLSBubyBlbWlzc2lvbnNcbiAgICAnYmlrZSc6IDAsICAgICAgICAvLyBCaWtpbmcgLSBubyBlbWlzc2lvbnNcbiAgICAnZWJpa2UnOiA1LCAgICAgICAvLyBFLWJpa2UgLSBtaW5pbWFsIGVtaXNzaW9ucyBmcm9tIGVsZWN0cmljaXR5XG4gICAgJ2ZlcnJ5JzogMTIwLCAgICAgLy8gRmVycnlcbiAgICAndGF4aSc6IDE1MCwgICAgICAvLyBUYXhpXG4gICAgJ3ViZXInOiAxNTAsICAgICAgLy8gVWJlclxuICAgICdzaGFyZWQnOiA5MCwgICAgIC8vIFNoYXJlZCByaWRlIChwZXIgcGFzc2VuZ2VyKVxuICAgICdkZWZhdWx0JzogMTAwICAgIC8vIERlZmF1bHQgdmFsdWVcbiAgfTtcblxuICAvLyBJZiBtb2RlIGlzIHdhbGtpbmcgb3IgYmlraW5nLCByZXR1cm4gMCByZWdhcmRsZXNzIG9mIGRpc3RhbmNlXG4gIGlmIChtb2RlID09PSAnd2FsaycgfHwgbW9kZSA9PT0gJ2Jpa2UnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb25zdCBlbWlzc2lvbkZhY3RvciA9IGVtaXNzaW9uc0ZhY3RvcnNbbW9kZV0gfHwgZW1pc3Npb25zRmFjdG9ycy5kZWZhdWx0O1xuICByZXR1cm4gTWF0aC5yb3VuZChlbWlzc2lvbkZhY3RvciAqIGRpc3RhbmNlS20pO1xufTtcblxuLy8gRGVmaW5lIHRoZSByb3V0ZSB0eXBlXG5pbnRlcmZhY2UgUm91dGVJdGVtIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICBjb3N0OiBudW1iZXI7XG4gIGNvbWZvcnQ6IHN0cmluZztcbiAgdmVjdG9yU2NvcmU6IG51bWJlcjtcbiAgc2VnbWVudHM6IGFueVtdO1xuICBiYWxhbmNlZFNjb3JlPzoge1xuICAgIHJhdzogbnVtYmVyO1xuICAgIHNjb3JlOiBudW1iZXI7XG4gICAgdGltZVNjb3JlOiBudW1iZXI7XG4gICAgY29zdFNjb3JlOiBudW1iZXI7XG4gICAgY29tZm9ydFNjb3JlOiBudW1iZXI7XG4gICAgdHJhbnNmZXJTY29yZTogbnVtYmVyO1xuICB9O1xuICAvLyBBZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgaGFzVG9wb2xvZ3lJbXBhY3Q/OiBib29sZWFuO1xuICBudW1UcmFuc2ZlcnM/OiBudW1iZXI7XG4gIHRyYWZmaWM/OiB7IGxldmVsOiBzdHJpbmc7IGltcGFjdDogbnVtYmVyIH07XG4gIGV0YT86IHN0cmluZztcbiAgY28yPzogbnVtYmVyO1xuICBpc1doZWVsY2hhaXJBY2Nlc3NpYmxlPzogYm9vbGVhbjtcbiAgc2NvcmVzPzogYW55O1xuICByb3V0ZUNvbG9yPzogc3RyaW5nO1xuICBwYXRoRGF0YT86IGFueVtdO1xuICBjb3N0QnJlYWtkb3duPzogYW55O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZVxuKSB7XG4gIGlmIChyZXEubWV0aG9kICE9PSAnR0VUJykge1xuICAgIHJldHVybiByZXMuc3RhdHVzKDQwNSkuanNvbih7IG1lc3NhZ2U6ICdNZXRob2QgTm90IEFsbG93ZWQnIH0pO1xuICB9XG5cbiAgY29uc3QgeyBmcm9tLCB0bywgcHJpb3JpdHksIG5vaXNlLCBzYWZldHksIGJhZ3MsIHdoZWVsY2hhaXIgfSA9IHJlcS5xdWVyeTtcblxuICBpZiAoIWZyb20gfHwgIXRvKSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgbWVzc2FnZTogJ09yaWdpbiBhbmQgZGVzdGluYXRpb24gYXJlIHJlcXVpcmVkJyB9KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgd2Ugd291bGQgdXNlIGdlb2NvZGluZyB0byBnZXQgY29vcmRpbmF0ZXNcbiAgICBjb25zdCBmcm9tQ29vcmRzID0gZ2V0Q29vcmRpbmF0ZXMoZnJvbSBhcyBzdHJpbmcpO1xuICAgIGNvbnN0IHRvQ29vcmRzID0gZ2V0Q29vcmRpbmF0ZXModG8gYXMgc3RyaW5nKTtcbiAgICBcbiAgICAvLyBMb2cgdGhlIGNvb3JkaW5hdGVzIGZvciBkZWJ1Z2dpbmdcbiAgICBjb25zb2xlLmxvZyhgRnJvbSBsb2NhdGlvbjogXCIke2Zyb219XCIg4oaSIGNvb3JkaW5hdGVzOiBbJHtmcm9tQ29vcmRzWzBdfSwgJHtmcm9tQ29vcmRzWzFdfV1gKTtcbiAgICBjb25zb2xlLmxvZyhgVG8gbG9jYXRpb246IFwiJHt0b31cIiDihpIgY29vcmRpbmF0ZXM6IFske3RvQ29vcmRzWzBdfSwgJHt0b0Nvb3Jkc1sxXX1dYCk7XG4gICAgXG4gICAgLy8gR2V0IHVzZXIgcHJlZmVyZW5jZXNcbiAgICBjb25zdCB1c2VyUHJpb3JpdHkgPSBwcmlvcml0eSBhcyBzdHJpbmcgfHwgJ2JhbGFuY2VkJztcbiAgICBjb25zdCB1c2VyTm9pc2UgPSBub2lzZSBhcyBzdHJpbmcgfHwgJ21vZGVyYXRlJztcbiAgICBjb25zdCB1c2VyU2FmZXR5ID0gc2FmZXR5IGFzIHN0cmluZyB8fCAnbW9kZXJhdGUnO1xuICAgIGNvbnN0IHVzZXJCYWdzID0gcGFyc2VJbnQoYmFncyBhcyBzdHJpbmcgfHwgJzAnLCAxMCk7XG4gICAgY29uc3QgcmVxdWlyZVdoZWVsY2hhaXIgPSB3aGVlbGNoYWlyID09PSAndHJ1ZSc7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlXG4gICAgY29uc3QgZGlzdGFuY2UgPSBjYWxjdWxhdGVEaXN0YW5jZShcbiAgICAgIGZyb21Db29yZHNbMF0sIGZyb21Db29yZHNbMV0sIFxuICAgICAgdG9Db29yZHNbMF0sIHRvQ29vcmRzWzFdXG4gICAgKTtcblxuICAgIC8vIEdldCByZWFsLXRpbWUgdHJhbnNpdCBkYXRhXG4gICAgY29uc3Qgc3Vid2F5U3RhdHVzID0gYXdhaXQgdHJhbnNpdEFQSS5nZXRTdWJ3YXlTdGF0dXMoKTtcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgYXZhaWxhYmxlIHN1YndheSBsaW5lcyBiYXNlZCBvbiBsb2NhdGlvblxuICAgIGNvbnN0IHN1YndheUxpbmVzQnlMb2NhdGlvbjogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge1xuICAgICAgJ01hbmhhdHRhbic6IFsnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnQScsICdDJywgJ0UnLCAnQicsICdEJywgJ0YnLCAnTScsICdOJywgJ1EnLCAnUicsICdXJywgJ0wnXSxcbiAgICAgICdCcm9va2x5bic6IFsnQScsICdDJywgJ0cnLCAnSicsICdaJywgJ0wnLCAnTScsICdOJywgJ1EnLCAnUicsICcyJywgJzMnLCAnNCcsICc1J10sXG4gICAgICAnUXVlZW5zJzogWydFJywgJ0YnLCAnTScsICdSJywgJ04nLCAnVycsICdHJywgJzcnXSxcbiAgICAgICdCcm9ueCc6IFsnMScsICcyJywgJzQnLCAnNScsICc2JywgJ0InLCAnRCddLFxuICAgICAgJ1N0YXRlbiBJc2xhbmQnOiBbJ1NJUiddLFxuICAgICAgJ0ZsdXNoaW5nJzogWyc3J10sXG4gICAgICAnTWFpbiBTdCc6IFsnNyddLFxuICAgICAgJ1RpbWVzIFNxdWFyZSc6IFsnMScsICcyJywgJzMnLCAnTicsICdRJywgJ1InLCAnVycsICc3JywgJ1MnXSxcbiAgICAgICdDZW50cmFsIFBhcmsnOiBbJ0EnLCAnQicsICdDJywgJ0QnLCAnMSddLFxuICAgICAgJ1lhbmtlZSBTdGFkaXVtJzogWyc0JywgJ0InLCAnRCddLFxuICAgICAgJ0pGSyBBaXJwb3J0JzogWydBJywgJ0UnXSxcbiAgICAgICdMYUd1YXJkaWEgQWlycG9ydCc6IFtdLFxuICAgICAgJ1Byb3NwZWN0IFBhcmsnOiBbJ0InLCAnUScsICdTJ10sXG4gICAgfTtcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgZnJvbSBhbmQgdG8gYXJlYXMgdG8gY2hlY2sgc3Vid2F5IGF2YWlsYWJpbGl0eVxuICAgIGNvbnN0IGZyb21BcmVhID0gT2JqZWN0LmtleXMobG9jYXRpb25Db29yZGluYXRlcykuZmluZChhcmVhID0+IFxuICAgICAgKGZyb20gYXMgc3RyaW5nKS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGFyZWEudG9Mb3dlckNhc2UoKSlcbiAgICApIHx8ICdNYW5oYXR0YW4nO1xuICAgIFxuICAgIGNvbnN0IHRvQXJlYSA9IE9iamVjdC5rZXlzKGxvY2F0aW9uQ29vcmRpbmF0ZXMpLmZpbmQoYXJlYSA9PiBcbiAgICAgICh0byBhcyBzdHJpbmcpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoYXJlYS50b0xvd2VyQ2FzZSgpKVxuICAgICkgfHwgJ01hbmhhdHRhbic7XG4gICAgXG4gICAgLy8gQ2hlY2sgYXZhaWxhYmxlIHN1YndheSBsaW5lcyBmb3IgdGhlIHJvdXRlXG4gICAgY29uc3QgZnJvbVN1YndheUxpbmVzID0gc3Vid2F5TGluZXNCeUxvY2F0aW9uW2Zyb21BcmVhXSB8fCBbXTtcbiAgICBjb25zdCB0b1N1YndheUxpbmVzID0gc3Vid2F5TGluZXNCeUxvY2F0aW9uW3RvQXJlYV0gfHwgW107XG4gICAgXG4gICAgLy8gRmluZCBjb21tb24gc3Vid2F5IGxpbmVzIG9yIGxpbmVzIHRoYXQgY2FuIGdldCB5b3UgdGhlcmUgd2l0aCBhIHRyYW5zZmVyXG4gICAgbGV0IGF2YWlsYWJsZVN1YndheUxpbmVzID0gZnJvbVN1YndheUxpbmVzLmZpbHRlcihsaW5lID0+IHRvU3Vid2F5TGluZXMuaW5jbHVkZXMobGluZSkpO1xuICAgIFxuICAgIC8vIElmIG5vIGRpcmVjdCBsaW5lcywgY29uc2lkZXIgb3B0aW9ucyB3aXRoIHRyYW5zZmVyc1xuICAgIGNvbnN0IGhhc1RyYW5zZmVyT3B0aW9ucyA9IGZyb21TdWJ3YXlMaW5lcy5sZW5ndGggPiAwICYmIHRvU3Vid2F5TGluZXMubGVuZ3RoID4gMDtcbiAgICBcbiAgICAvLyBDaGVjayBzdWJ3YXkgc3RhdHVzIHRvIHNlZSBpZiB0aGUgbGluZXMgYXJlIG9wZXJhdGluZyBub3JtYWxseVxuICAgIGNvbnN0IG9wZXJhdGluZ1N1YndheUxpbmVzID0gYXZhaWxhYmxlU3Vid2F5TGluZXMuZmlsdGVyKGxpbmUgPT4ge1xuICAgICAgY29uc3QgbGluZVN0YXR1cyA9IHN1YndheVN0YXR1cy5maW5kKHMgPT4gcy5saW5lID09PSBsaW5lKTtcbiAgICAgIHJldHVybiBsaW5lU3RhdHVzICYmIGxpbmVTdGF0dXMuc3RhdHVzID09PSAnbm9ybWFsJztcbiAgICB9KTtcbiAgICBcbiAgICAvLyBGaWx0ZXIgdG8ganVzdCBnZXQgb25lIG9wZXJhdGluZyBsaW5lIGlmIGF2YWlsYWJsZVxuICAgIGNvbnN0IGJlc3RTdWJ3YXlMaW5lID0gb3BlcmF0aW5nU3Vid2F5TGluZXMubGVuZ3RoID4gMCA/IG9wZXJhdGluZ1N1YndheUxpbmVzWzBdIDogbnVsbDtcbiAgICBcbiAgICAvLyBHZXQgYWxsIHRoZSBidXMgcm91dGVzIGZvciBib3RoIGFyZWFzXG4gICAgY29uc3QgZnJvbUJvcm91Z2hQcmVmaXggPSBmcm9tQXJlYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCB0b0Jvcm91Z2hQcmVmaXggPSB0b0FyZWEuY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgYnVzUm91dGVzRnJvbSA9IGF3YWl0IHRyYW5zaXRBUEkuZ2V0QnVzUm91dGVzKGZyb21BcmVhKTtcbiAgICBcbiAgICAvLyBNYXAgc3BlY2lmaWMgbmVpZ2hib3Job29kcyB0byBhcHByb3ByaWF0ZSBidXMgcm91dGVzXG4gICAgY29uc3QgYnVzUm91dGVzQnlBcmVhOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7XG4gICAgICAnTWFuaGF0dGFuJzogWydNMScsICdNMicsICdNMycsICdNNCcsICdNNScsICdNMTUnLCAnTTMxJywgJ000MicsICdNNjAnXSxcbiAgICAgICdCcm9va2x5bic6IFsnQjQxJywgJ0I0MicsICdCNDQnLCAnQjQ2JywgJ0I2NycsICdCNjgnLCAnQjY5J10sXG4gICAgICAnUXVlZW5zJzogWydRNTgnLCAnUTU5JywgJ1E2MCcsICdRNjUnLCAnUTY2JywgJ1E0NCcsICdRNDYnXSxcbiAgICAgICdCcm9ueCc6IFsnQlgxJywgJ0JYMicsICdCWDknLCAnQlgxMCcsICdCWDEyJywgJ0JYMjInXSxcbiAgICAgICdTdGF0ZW4gSXNsYW5kJzogWydTNDAnLCAnUzQ0JywgJ1M0NicsICdTNDgnLCAnUzUxJywgJ1M1MyddLFxuICAgICAgJ0ZsdXNoaW5nJzogWydRNjUnLCAnUTY2JywgJ1ExNycsICdRMjcnLCAnUTQ0J10sXG4gICAgICAnQmF5c2lkZSc6IFsnUTI3JywgJ1EzMScsICdRNzYnLCAnUTEzJ10sXG4gICAgICAnVGltZXMgU3F1YXJlJzogWydNNDInLCAnTTEwNCcsICdRMTA0J10sXG4gICAgICAnSkZLIEFpcnBvcnQnOiBbJ1EzJywgJ1ExMCcsICdCMTUnXSxcbiAgICAgICdMYUd1YXJkaWEgQWlycG9ydCc6IFsnUTcwJywgJ002MCddLFxuICAgIH07XG4gICAgXG4gICAgLy8gR2V0IHNwZWNpZmljIGJ1cyByb3V0ZXMgZm9yIG9yaWdpbiBhbmQgZGVzdGluYXRpb25cbiAgICBjb25zdCBzcGVjaWZpY0Zyb21CdXNlcyA9IGJ1c1JvdXRlc0J5QXJlYVtmcm9tQXJlYV0gfHwgW107XG4gICAgY29uc3Qgc3BlY2lmaWNUb0J1c2VzID0gYnVzUm91dGVzQnlBcmVhW3RvQXJlYV0gfHwgW107XG4gICAgXG4gICAgLy8gRmluZCBidXMgcm91dGVzIHRoYXQgbWlnaHQgY29ubmVjdCB0aGUgdHdvIGFyZWFzXG4gICAgbGV0IGNvbm5lY3RpbmdCdXNlcyA9IHNwZWNpZmljRnJvbUJ1c2VzLmZpbHRlcihidXMgPT4gc3BlY2lmaWNUb0J1c2VzLmluY2x1ZGVzKGJ1cykpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gYXJlIGluIGRpZmZlcmVudCBib3JvdWdoc1xuICAgIGNvbnN0IG9yaWdpbkJvcm91Z2ggPSBcbiAgICAgIGZyb21BcmVhID09PSAnTWFuaGF0dGFuJyB8fCBmcm9tQXJlYSA9PT0gJ1RpbWVzIFNxdWFyZScgfHwgZnJvbUFyZWEgPT09ICdDZW50cmFsIFBhcmsnID8gJ01hbmhhdHRhbicgOlxuICAgICAgZnJvbUFyZWEgPT09ICdCcm9va2x5bicgfHwgZnJvbUFyZWEgPT09ICdQcm9zcGVjdCBQYXJrJyA/ICdCcm9va2x5bicgOlxuICAgICAgZnJvbUFyZWEgPT09ICdRdWVlbnMnIHx8IGZyb21BcmVhID09PSAnRmx1c2hpbmcnIHx8IGZyb21BcmVhID09PSAnQmF5c2lkZScgfHwgZnJvbUFyZWEgPT09ICdKRksgQWlycG9ydCcgPyAnUXVlZW5zJyA6XG4gICAgICBmcm9tQXJlYSA9PT0gJ0Jyb254JyB8fCBmcm9tQXJlYSA9PT0gJ1lhbmtlZSBTdGFkaXVtJyA/ICdCcm9ueCcgOlxuICAgICAgZnJvbUFyZWEgPT09ICdTdGF0ZW4gSXNsYW5kJyA/ICdTdGF0ZW4gSXNsYW5kJyA6ICdNYW5oYXR0YW4nO1xuICAgIFxuICAgIGNvbnN0IGRlc3RpbmF0aW9uQm9yb3VnaCA9IFxuICAgICAgdG9BcmVhID09PSAnTWFuaGF0dGFuJyB8fCB0b0FyZWEgPT09ICdUaW1lcyBTcXVhcmUnIHx8IHRvQXJlYSA9PT0gJ0NlbnRyYWwgUGFyaycgPyAnTWFuaGF0dGFuJyA6XG4gICAgICB0b0FyZWEgPT09ICdCcm9va2x5bicgfHwgdG9BcmVhID09PSAnUHJvc3BlY3QgUGFyaycgPyAnQnJvb2tseW4nIDpcbiAgICAgIHRvQXJlYSA9PT0gJ1F1ZWVucycgfHwgdG9BcmVhID09PSAnRmx1c2hpbmcnIHx8IHRvQXJlYSA9PT0gJ0JheXNpZGUnIHx8IHRvQXJlYSA9PT0gJ0pGSyBBaXJwb3J0JyA/ICdRdWVlbnMnIDpcbiAgICAgIHRvQXJlYSA9PT0gJ0Jyb254JyB8fCB0b0FyZWEgPT09ICdZYW5rZWUgU3RhZGl1bScgPyAnQnJvbngnIDpcbiAgICAgIHRvQXJlYSA9PT0gJ1N0YXRlbiBJc2xhbmQnID8gJ1N0YXRlbiBJc2xhbmQnIDogJ01hbmhhdHRhbic7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGNyb3NzLWJvcm91Z2ggdHJpcCByZXF1aXJpbmcgdHJhbnNmZXJzXG4gICAgY29uc3QgaXNDcm9zc0Jvcm91Z2hUcmlwID0gb3JpZ2luQm9yb3VnaCAhPT0gZGVzdGluYXRpb25Cb3JvdWdoO1xuICAgIFxuICAgIC8vIEV4cHJlc3MgQnVzIHJvdXRlcyBmb3IgY3Jvc3MtYm9yb3VnaCB0cmF2ZWxcbiAgICBjb25zdCBleHByZXNzQnVzUm91dGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSB7XG4gICAgICAnUXVlZW5zLU1hbmhhdHRhbic6IFsnUU0xJywgJ1FNNScsICdRTTcnLCAnUU04J10sXG4gICAgICAnQnJvb2tseW4tTWFuaGF0dGFuJzogWydCTTEnLCAnQk0yJywgJ0JNMycsICdCTTQnXSxcbiAgICAgICdCcm9ueC1NYW5oYXR0YW4nOiBbJ0J4TTEnLCAnQnhNMicsICdCeE0zJywgJ0J4TTQnXSxcbiAgICAgICdTdGF0ZW4gSXNsYW5kLU1hbmhhdHRhbic6IFsnU0lNMScsICdTSU0zJywgJ1NJTTQnLCAnU0lNNSddLFxuICAgIH07XG4gICAgXG4gICAgLy8gR2V0IGFwcHJvcHJpYXRlIGV4cHJlc3MgYnVzIGlmIHRoaXMgaXMgY3Jvc3MtYm9yb3VnaFxuICAgIGxldCBleHByZXNzQnVzUm91dGUgPSAnJztcbiAgICBpZiAoaXNDcm9zc0Jvcm91Z2hUcmlwKSB7XG4gICAgICBjb25zdCByb3V0ZUtleSA9IGAke29yaWdpbkJvcm91Z2h9LSR7ZGVzdGluYXRpb25Cb3JvdWdofWA7XG4gICAgICBjb25zdCByZXZlcnNlUm91dGVLZXkgPSBgJHtkZXN0aW5hdGlvbkJvcm91Z2h9LSR7b3JpZ2luQm9yb3VnaH1gO1xuICAgICAgXG4gICAgICBpZiAoZXhwcmVzc0J1c1JvdXRlc1tyb3V0ZUtleV0pIHtcbiAgICAgICAgZXhwcmVzc0J1c1JvdXRlID0gZXhwcmVzc0J1c1JvdXRlc1tyb3V0ZUtleV1bMF07XG4gICAgICB9IGVsc2UgaWYgKGV4cHJlc3NCdXNSb3V0ZXNbcmV2ZXJzZVJvdXRlS2V5XSkge1xuICAgICAgICBleHByZXNzQnVzUm91dGUgPSBleHByZXNzQnVzUm91dGVzW3JldmVyc2VSb3V0ZUtleV1bMF07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIElmIG5vIGRpcmVjdCBjb25uZWN0aW9uLCBwaWNrIGEgYnVzIGZyb20gb3JpZ2luIGZvciBsb2NhbCB0cmlwcyBvbmx5XG4gICAgLy8gRm9yIGNyb3NzLWJvcm91Z2ggdHJpcHMgd2l0aG91dCBleHByZXNzIGJ1c2VzLCB3ZSdsbCByZWx5IG9uIHN1YndheSBpbnN0ZWFkXG4gICAgaWYgKGNvbm5lY3RpbmdCdXNlcy5sZW5ndGggPT09IDAgJiYgc3BlY2lmaWNGcm9tQnVzZXMubGVuZ3RoID4gMCAmJiAhaXNDcm9zc0Jvcm91Z2hUcmlwKSB7XG4gICAgICBjb25uZWN0aW5nQnVzZXMgPSBbc3BlY2lmaWNGcm9tQnVzZXNbMF1dO1xuICAgIH1cbiAgICBcbiAgICAvLyBEZWZhdWx0IHRvIGEgYm9yb3VnaC1zcGVjaWZpYyBidXMgaWYgbm90aGluZyBlbHNlIGlzIGF2YWlsYWJsZVxuICAgIGNvbnN0IGJ1c1JvdXRlID0gY29ubmVjdGluZ0J1c2VzLmxlbmd0aCA+IDAgXG4gICAgICA/IGNvbm5lY3RpbmdCdXNlc1swXSBcbiAgICAgIDogKGV4cHJlc3NCdXNSb3V0ZSB8fCBgJHtmcm9tQm9yb3VnaFByZWZpeH0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwKSArIDF9YCk7XG4gICAgXG4gICAgLy8gR2V0IHRyYWZmaWMgY29uZGl0aW9ucyBmb3Igb3JpZ2luIGFuZCBkZXN0aW5hdGlvbiBhcmVhc1xuICAgIGNvbnN0IG9yaWdpblRyYWZmaWMgPSB0cmFmZmljQ29uZGl0aW9uc1tvcmlnaW5Cb3JvdWdoXSB8fCB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjI1IH07XG4gICAgY29uc3QgZGVzdGluYXRpb25UcmFmZmljID0gdHJhZmZpY0NvbmRpdGlvbnNbZGVzdGluYXRpb25Cb3JvdWdoXSB8fCB7IGxldmVsOiAnbWVkaXVtJywgZmFjdG9yOiAxLjI1IH07XG4gICAgXG4gICAgLy8gR2V0IHRvcG9sb2d5IGRpZmZpY3VsdHkgZm9yIGVhY2ggYXJlYVxuICAgIGNvbnN0IG9yaWdpblRvcG9sb2d5ID0gdG9wb2xvZ3lEaWZmaWN1bHR5W29yaWdpbkJvcm91Z2hdIHx8IDAuMjtcbiAgICBjb25zdCBkZXN0aW5hdGlvblRvcG9sb2d5ID0gdG9wb2xvZ3lEaWZmaWN1bHR5W2Rlc3RpbmF0aW9uQm9yb3VnaF0gfHwgMC4yO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIHRyYWZmaWMgYW5kIHRvcG9sb2d5IGRpZmZpY3VsdHlcbiAgICBjb25zdCBhdmdUcmFmZmljRmFjdG9yID0gKG9yaWdpblRyYWZmaWMuZmFjdG9yICsgZGVzdGluYXRpb25UcmFmZmljLmZhY3RvcikgLyAyO1xuICAgIGNvbnN0IGF2Z1RvcG9sb2d5RGlmZmljdWx0eSA9IChvcmlnaW5Ub3BvbG9neSArIGRlc3RpbmF0aW9uVG9wb2xvZ3kpIC8gMjtcbiAgICBcbiAgICBjb25zdCBnZW5lcmF0ZVJvdXRlcyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJvdXRlczogUm91dGVJdGVtW10gPSBbXTtcbiAgICAgIFxuICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBiYWxhbmNlZCBzY29yZVxuICAgICAgY29uc3QgY2FsY3VsYXRlQmFsYW5jZWRTY29yZSA9IChcbiAgICAgICAgZHVyYXRpb246IG51bWJlciwgXG4gICAgICAgIGNvc3Q6IG51bWJlciwgXG4gICAgICAgIGNvbWZvcnQ6IHN0cmluZywgXG4gICAgICAgIG51bVRyYW5zZmVyczogbnVtYmVyXG4gICAgICApID0+IHtcbiAgICAgICAgLy8gU2ltcGxlIHNjb3Jpbmcgc3lzdGVtXG4gICAgICAgIGNvbnN0IHRpbWVTY29yZSA9IE1hdGgubWF4KDAsIDEgLSAoZHVyYXRpb24gLyAxMjApKTsgLy8gTm9ybWFsaXplIHRvIDAtMSAoMiBob3VycyBtYXgpXG4gICAgICAgIGNvbnN0IGNvc3RTY29yZSA9IE1hdGgubWF4KDAsIDEgLSAoY29zdCAvIDMwKSk7ICAgICAgLy8gTm9ybWFsaXplIHRvIDAtMSAoJDMwIG1heClcbiAgICAgICAgY29uc3QgY29tZm9ydFNjb3JlID0gY29tZm9ydCA9PT0gJ2hpZ2gnID8gMSA6IGNvbWZvcnQgPT09ICdtZWRpdW0nID8gMC42IDogMC4zO1xuICAgICAgICBjb25zdCB0cmFuc2ZlclNjb3JlID0gTWF0aC5tYXgoMCwgMSAtIChudW1UcmFuc2ZlcnMgKiAwLjIpKTtcblxuICAgICAgICAvLyBXZWlnaHRlZCBhdmVyYWdlXG4gICAgICAgIGNvbnN0IHNjb3JlID0gKFxuICAgICAgICAgIHRpbWVTY29yZSAqIDAuNCArXG4gICAgICAgICAgY29zdFNjb3JlICogMC4zICtcbiAgICAgICAgICBjb21mb3J0U2NvcmUgKiAwLjIgK1xuICAgICAgICAgIHRyYW5zZmVyU2NvcmUgKiAwLjFcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhdzogc2NvcmUsXG4gICAgICAgICAgc2NvcmU6IE1hdGgucm91bmQoc2NvcmUgKiAxMCksXG4gICAgICAgICAgdGltZVNjb3JlOiBNYXRoLnJvdW5kKHRpbWVTY29yZSAqIDEwKSxcbiAgICAgICAgICBjb3N0U2NvcmU6IE1hdGgucm91bmQoY29zdFNjb3JlICogMTApLFxuICAgICAgICAgIGNvbWZvcnRTY29yZTogTWF0aC5yb3VuZChjb21mb3J0U2NvcmUgKiAxMCksXG4gICAgICAgICAgdHJhbnNmZXJTY29yZTogTWF0aC5yb3VuZCh0cmFuc2ZlclNjb3JlICogMTApXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICAvLyBBbHdheXMgYWRkIGEgd2Fsa2luZyByb3V0ZSBhcyBhIGJhc2VsaW5lIG9wdGlvblxuICAgICAgY29uc3Qgd2Fsa2luZ1JvdXRlOiBSb3V0ZUl0ZW0gPSB7XG4gICAgICAgIGlkOiAnMCcsXG4gICAgICAgIG5hbWU6ICdXYWxraW5nIFJvdXRlJyxcbiAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAyMCksXG4gICAgICAgIGNvc3Q6IDAsXG4gICAgICAgIGNvbWZvcnQ6ICdtZWRpdW0nLFxuICAgICAgICB2ZWN0b3JTY29yZTogMC41LFxuICAgICAgICBzZWdtZW50czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxuICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMjApLFxuICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBkZXN0aW5hdGlvbicsXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgfTtcbiAgICAgIHdhbGtpbmdSb3V0ZS5iYWxhbmNlZFNjb3JlID0gY2FsY3VsYXRlQmFsYW5jZWRTY29yZSh3YWxraW5nUm91dGUuZHVyYXRpb24sIHdhbGtpbmdSb3V0ZS5jb3N0LCB3YWxraW5nUm91dGUuY29tZm9ydCwgMCk7XG4gICAgICAvLyBDYWxjdWxhdGUgQ08yIGZvciB3YWxraW5nICgwIGVtaXNzaW9ucylcbiAgICAgIHdhbGtpbmdSb3V0ZS5jbzIgPSBjYWxjdWxhdGVDTzJFbWlzc2lvbnMoJ3dhbGsnLCBkaXN0YW5jZSAqIDEuNjA5MzQpOyAvLyBDb252ZXJ0IG1pbGVzIHRvIGttXG4gICAgICByb3V0ZXMucHVzaCh3YWxraW5nUm91dGUpO1xuXG4gICAgICAvLyBBZGQgYSBiaWtlIHJvdXRlIGlmIGRpc3RhbmNlIGlzIHJlYXNvbmFibGUgKGxlc3MgdGhhbiAxMCBtaWxlcylcbiAgICAgIGlmIChkaXN0YW5jZSA8IDEwKSB7XG4gICAgICAgIGNvbnN0IGJpa2VSb3V0ZTogUm91dGVJdGVtID0ge1xuICAgICAgICAgIGlkOiAnMScsXG4gICAgICAgICAgbmFtZTogJ0Jpa2UgUm91dGUnLFxuICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTIpLCAvLyB+NW1waCBhdmVyYWdlIHNwZWVkXG4gICAgICAgICAgY29zdDogMy41MCwgLy8gQ2l0aSBCaWtlIHNpbmdsZSByaWRlXG4gICAgICAgICAgY29tZm9ydDogJ21lZGl1bScsXG4gICAgICAgICAgdmVjdG9yU2NvcmU6IDAuNjUsXG4gICAgICAgICAgc2VnbWVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbW9kZTogJ2Jpa2UnLFxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcbiAgICAgICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxMiksXG4gICAgICAgICAgICAgIGNvc3Q6IDMuNTAsXG4gICAgICAgICAgICAgIGxpbmVJbmZvOiAnQ2l0aSBCaWtlJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgICBiaWtlUm91dGUuYmFsYW5jZWRTY29yZSA9IGNhbGN1bGF0ZUJhbGFuY2VkU2NvcmUoYmlrZVJvdXRlLmR1cmF0aW9uLCBiaWtlUm91dGUuY29zdCwgYmlrZVJvdXRlLmNvbWZvcnQsIDApO1xuICAgICAgICAvLyBDYWxjdWxhdGUgQ08yIGZvciBiaWtpbmcgKDAgZW1pc3Npb25zKVxuICAgICAgICBiaWtlUm91dGUuY28yID0gY2FsY3VsYXRlQ08yRW1pc3Npb25zKCdiaWtlJywgZGlzdGFuY2UgKiAxLjYwOTM0KTtcbiAgICAgICAgcm91dGVzLnB1c2goYmlrZVJvdXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHN1YndheSByb3V0ZXMgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAoYmVzdFN1YndheUxpbmUgfHwgaGFzVHJhbnNmZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN1YndheVJvdXRlOiBSb3V0ZUl0ZW0gPSB7XG4gICAgICAgICAgaWQ6ICcyJyxcbiAgICAgICAgICBuYW1lOiAnU3Vid2F5IFJvdXRlJyxcbiAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDgpICsgMTAsIC8vIFRyYW5zaXQgdGltZSArIHdhbGtpbmdcbiAgICAgICAgICBjb3N0OiAyLjkwLFxuICAgICAgICAgIGNvbWZvcnQ6ICdoaWdoJyxcbiAgICAgICAgICB2ZWN0b3JTY29yZTogMC44LFxuICAgICAgICAgIHNlZ21lbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogZnJvbSBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiAnU3Vid2F5IFN0YXRpb24nLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcbiAgICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIHN0YXRpb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbW9kZTogJ3N1YndheScsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246ICdTdWJ3YXkgU3RhdGlvbicsXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiAnU3Vid2F5IFN0YXRpb24nLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDgpLFxuICAgICAgICAgICAgICBjb3N0OiAyLjkwLFxuICAgICAgICAgICAgICBsaW5lSW5mbzogYmVzdFN1YndheUxpbmUgPyBgJHtiZXN0U3Vid2F5TGluZX0gVHJhaW5gIDogJ1N1YndheScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtb2RlOiAnd2FsaycsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246ICdTdWJ3YXkgU3RhdGlvbicsXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiA1LFxuICAgICAgICAgICAgICBjb3N0OiAwLFxuICAgICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gZGVzdGluYXRpb24nLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICAgIHN1YndheVJvdXRlLmJhbGFuY2VkU2NvcmUgPSBjYWxjdWxhdGVCYWxhbmNlZFNjb3JlKHN1YndheVJvdXRlLmR1cmF0aW9uLCBzdWJ3YXlSb3V0ZS5jb3N0LCBzdWJ3YXlSb3V0ZS5jb21mb3J0LCAwKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIENPMiBmb3Igc3Vid2F5IHJvdXRlICh3YWxraW5nICsgc3Vid2F5IHNlZ21lbnRzKVxuICAgICAgICBzdWJ3YXlSb3V0ZS5jbzIgPSBcbiAgICAgICAgICBjYWxjdWxhdGVDTzJFbWlzc2lvbnMoJ3dhbGsnLCAwLjQpICsgLy8gQXNzdW1pbmcgMC40IGttIHdhbGtpbmcgdG90YWxcbiAgICAgICAgICBjYWxjdWxhdGVDTzJFbWlzc2lvbnMoJ3N1YndheScsIGRpc3RhbmNlICogMS42MDkzNCk7IC8vIE1haW4gc3Vid2F5IGpvdXJuZXlcbiAgICAgICAgcm91dGVzLnB1c2goc3Vid2F5Um91dGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYnVzIHJvdXRlXG4gICAgICBjb25zdCBidXNSb3V0ZTogUm91dGVJdGVtID0ge1xuICAgICAgICBpZDogJzMnLFxuICAgICAgICBuYW1lOiAnQnVzIFJvdXRlJyxcbiAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxNSkgKyAxMCwgLy8gQnVzIHRpbWUgKyB3YWxraW5nXG4gICAgICAgIGNvc3Q6IDIuOTAsXG4gICAgICAgIGNvbWZvcnQ6ICdtZWRpdW0nLFxuICAgICAgICB2ZWN0b3JTY29yZTogMC42LFxuICAgICAgICBzZWdtZW50czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxuICAgICAgICAgICAgZW5kTG9jYXRpb246ICdCdXMgU3RvcCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogNSxcbiAgICAgICAgICAgIGNvc3Q6IDAsXG4gICAgICAgICAgICBsaW5lSW5mbzogJ1dhbGsgdG8gYnVzIHN0b3AnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbW9kZTogJ2J1cycsXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiAnQnVzIFN0b3AnLFxuICAgICAgICAgICAgZW5kTG9jYXRpb246ICdCdXMgU3RvcCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDE1KSxcbiAgICAgICAgICAgIGNvc3Q6IDIuOTAsXG4gICAgICAgICAgICBsaW5lSW5mbzogYExvY2FsIEJ1c2AsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb2RlOiAnd2FsaycsXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiAnQnVzIFN0b3AnLFxuICAgICAgICAgICAgZW5kTG9jYXRpb246IHRvIGFzIHN0cmluZyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1LFxuICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgIGxpbmVJbmZvOiAnV2FsayB0byBkZXN0aW5hdGlvbicsXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgfTtcbiAgICAgIGJ1c1JvdXRlLmJhbGFuY2VkU2NvcmUgPSBjYWxjdWxhdGVCYWxhbmNlZFNjb3JlKGJ1c1JvdXRlLmR1cmF0aW9uLCBidXNSb3V0ZS5jb3N0LCBidXNSb3V0ZS5jb21mb3J0LCAwKTtcbiAgICAgIC8vIENhbGN1bGF0ZSBDTzIgZm9yIGJ1cyByb3V0ZSAod2Fsa2luZyArIGJ1cyBzZWdtZW50cylcbiAgICAgIGJ1c1JvdXRlLmNvMiA9IFxuICAgICAgICBjYWxjdWxhdGVDTzJFbWlzc2lvbnMoJ3dhbGsnLCAwLjQpICsgLy8gQXNzdW1pbmcgMC40IGttIHdhbGtpbmcgdG90YWxcbiAgICAgICAgY2FsY3VsYXRlQ08yRW1pc3Npb25zKCdidXMnLCBkaXN0YW5jZSAqIDEuNjA5MzQpOyAvLyBNYWluIGJ1cyBqb3VybmV5XG4gICAgICByb3V0ZXMucHVzaChidXNSb3V0ZSk7XG5cbiAgICAgIC8vIEFkZCBleHByZXNzIGJ1cyBmb3IgbG9uZ2VyIGRpc3RhbmNlc1xuICAgICAgaWYgKGRpc3RhbmNlID4gNSkge1xuICAgICAgICBjb25zdCBleHByZXNzQnVzUm91dGU6IFJvdXRlSXRlbSA9IHtcbiAgICAgICAgICBpZDogJzQnLFxuICAgICAgICAgIG5hbWU6ICdFeHByZXNzIEJ1cyBSb3V0ZScsXG4gICAgICAgICAgZHVyYXRpb246IE1hdGgucm91bmQoZGlzdGFuY2UgKiAxMCkgKyAxMCwgLy8gRXhwcmVzcyBidXMgdGltZSArIHdhbGtpbmdcbiAgICAgICAgICBjb3N0OiA3LjAwLFxuICAgICAgICAgIGNvbWZvcnQ6ICdoaWdoJyxcbiAgICAgICAgICB2ZWN0b3JTY29yZTogMC43NSxcbiAgICAgICAgICBzZWdtZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtb2RlOiAnd2FsaycsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IGZyb20gYXMgc3RyaW5nLFxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogJ0V4cHJlc3MgQnVzIFN0b3AnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcbiAgICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGJ1cyBzdG9wJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1vZGU6ICdidXMnLFxuICAgICAgICAgICAgICBzdGFydExvY2F0aW9uOiAnRXhwcmVzcyBCdXMgU3RvcCcsXG4gICAgICAgICAgICAgIGVuZExvY2F0aW9uOiAnRXhwcmVzcyBCdXMgU3RvcCcsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMTApLFxuICAgICAgICAgICAgICBjb3N0OiA3LjAwLFxuICAgICAgICAgICAgICBsaW5lSW5mbzogJ0V4cHJlc3MgQnVzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1vZGU6ICd3YWxrJyxcbiAgICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogJ0V4cHJlc3MgQnVzIFN0b3AnLFxuICAgICAgICAgICAgICBlbmRMb2NhdGlvbjogdG8gYXMgc3RyaW5nLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogNSxcbiAgICAgICAgICAgICAgY29zdDogMCxcbiAgICAgICAgICAgICAgbGluZUluZm86ICdXYWxrIHRvIGRlc3RpbmF0aW9uJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgICBleHByZXNzQnVzUm91dGUuYmFsYW5jZWRTY29yZSA9IGNhbGN1bGF0ZUJhbGFuY2VkU2NvcmUoZXhwcmVzc0J1c1JvdXRlLmR1cmF0aW9uLCBleHByZXNzQnVzUm91dGUuY29zdCwgZXhwcmVzc0J1c1JvdXRlLmNvbWZvcnQsIDApO1xuICAgICAgICAvLyBDYWxjdWxhdGUgQ08yIGZvciBleHByZXNzIGJ1cyByb3V0ZSAod2Fsa2luZyArIGJ1cyBzZWdtZW50cylcbiAgICAgICAgZXhwcmVzc0J1c1JvdXRlLmNvMiA9IFxuICAgICAgICAgIGNhbGN1bGF0ZUNPMkVtaXNzaW9ucygnd2FsaycsIDAuNCkgKyAvLyBBc3N1bWluZyAwLjQga20gd2Fsa2luZyB0b3RhbFxuICAgICAgICAgIGNhbGN1bGF0ZUNPMkVtaXNzaW9ucygnYnVzJywgZGlzdGFuY2UgKiAxLjYwOTM0KTsgLy8gTWFpbiBidXMgam91cm5leVxuICAgICAgICByb3V0ZXMucHVzaChleHByZXNzQnVzUm91dGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYSByaWRlLXNoYXJpbmcgcm91dGUgYXMgYW5vdGhlciBvcHRpb25cbiAgICAgIGNvbnN0IHViZXJSb3V0ZTogUm91dGVJdGVtID0ge1xuICAgICAgICBpZDogJzUnLFxuICAgICAgICBuYW1lOiAnUmlkZS1TaGFyZSBSb3V0ZScsXG4gICAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKGRpc3RhbmNlICogMyksXG4gICAgICAgIGNvc3Q6IHBhcnNlRmxvYXQoKGRpc3RhbmNlICogMi41KS50b0ZpeGVkKDIpKSxcbiAgICAgICAgY29tZm9ydDogJ2hpZ2gnLFxuICAgICAgICB2ZWN0b3JTY29yZTogMC43OCxcbiAgICAgICAgc2VnbWVudHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb2RlOiAndWJlcicsXG4gICAgICAgICAgICBzdGFydExvY2F0aW9uOiBmcm9tIGFzIHN0cmluZyxcbiAgICAgICAgICAgIGVuZExvY2F0aW9uOiB0byBhcyBzdHJpbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yb3VuZChkaXN0YW5jZSAqIDMpLFxuICAgICAgICAgICAgY29zdDogcGFyc2VGbG9hdCgoZGlzdGFuY2UgKiAyLjUpLnRvRml4ZWQoMikpLFxuICAgICAgICAgICAgbGluZUluZm86ICdVYmVyWCcsXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgfTtcbiAgICAgIHViZXJSb3V0ZS5iYWxhbmNlZFNjb3JlID0gY2FsY3VsYXRlQmFsYW5jZWRTY29yZSh1YmVyUm91dGUuZHVyYXRpb24sIHViZXJSb3V0ZS5jb3N0LCB1YmVyUm91dGUuY29tZm9ydCwgMCk7XG4gICAgICAvLyBDYWxjdWxhdGUgQ08yIGZvciByaWRlLXNoYXJlIHJvdXRlXG4gICAgICB1YmVyUm91dGUuY28yID0gY2FsY3VsYXRlQ08yRW1pc3Npb25zKCd1YmVyJywgZGlzdGFuY2UgKiAxLjYwOTM0KTtcbiAgICAgIHJvdXRlcy5wdXNoKHViZXJSb3V0ZSk7XG5cbiAgICAgIC8vIFNvcnQgcm91dGVzIGJ5IGJhbGFuY2VkIHNjb3JlIChoaWdoZXN0IGZpcnN0KVxuICAgICAgcm91dGVzLnNvcnQoKGEsIGIpID0+IChiLmJhbGFuY2VkU2NvcmU/LnNjb3JlIHx8IDApIC0gKGEuYmFsYW5jZWRTY29yZT8uc2NvcmUgfHwgMCkpO1xuXG4gICAgICByZXR1cm4gcm91dGVzO1xuICAgIH07XG4gICAgXG4gICAgY29uc3Qgcm91dGVzID0gZ2VuZXJhdGVSb3V0ZXMoKTtcblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBmaW5hbGl6ZSByb3V0ZSBkZXRhaWxzXG4gICAgY29uc3QgZmluYWxpemVSb3V0ZSA9IChyb3V0ZTogUm91dGVJdGVtKTogUm91dGVJdGVtID0+IHtcbiAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgdHJhbnNmZXJzXG4gICAgICBjb25zdCBudW1UcmFuc2ZlcnMgPSByb3V0ZS5zZWdtZW50cy5sZW5ndGggPiAwID8gcm91dGUuc2VnbWVudHMubGVuZ3RoIC0gMSA6IDA7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHJvdXRlIGhhcyB3YWxraW5nL2Jpa2luZyBjb21wb25lbnRzXG4gICAgICBjb25zdCBoYXNUb3BvbG9neUltcGFjdCA9IHJvdXRlLnNlZ21lbnRzLnNvbWUoc2VnbWVudCA9PiBcbiAgICAgICAgc2VnbWVudC5tb2RlID09PSAnd2FsaycgfHwgc2VnbWVudC5tb2RlID09PSAnZWJpa2UnXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgdHJhZmZpYyBpbXBhY3QgZm9yIHJvYWQtYmFzZWQgc2VnbWVudHNcbiAgICAgIGNvbnN0IHJvYWRCYXNlZFNlZ21lbnRzID0gcm91dGUuc2VnbWVudHMuZmlsdGVyKHNlZ21lbnQgPT4gXG4gICAgICAgIHNlZ21lbnQubW9kZSA9PT0gJ2J1cycgfHwgc2VnbWVudC5tb2RlID09PSAndWJlcicgfHwgc2VnbWVudC5tb2RlID09PSAndGF4aSdcbiAgICAgICk7XG4gICAgICBjb25zdCB0cmFmZmljSW1wYWN0ID0gcm9hZEJhc2VkU2VnbWVudHMubGVuZ3RoID4gMCA/IGF2Z1RyYWZmaWNGYWN0b3IgOiAxLjA7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBFVEFcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBldGEgPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpICsgcm91dGUuZHVyYXRpb24gKiA2MDAwMCk7XG4gICAgICBcbiAgICAgIC8vIEFkZCByb3V0ZSBjb2xvciBiYXNlZCBvbiBtb2RlXG4gICAgICBjb25zdCByb3V0ZUNvbG9yID0gZ2V0Um91dGVDb2xvcihyb3V0ZS5zZWdtZW50c1swXT8ubW9kZSB8fCAnd2FsaycpO1xuICAgICAgXG4gICAgICAvLyBSZXR1cm4gZW5oYW5jZWQgcm91dGVcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJvdXRlLFxuICAgICAgICBudW1UcmFuc2ZlcnMsXG4gICAgICAgIGhhc1RvcG9sb2d5SW1wYWN0LFxuICAgICAgICB0cmFmZmljOiB7IFxuICAgICAgICAgIGxldmVsOiB0cmFmZmljSW1wYWN0ID4gMS4zID8gJ2hpZ2gnIDogdHJhZmZpY0ltcGFjdCA+IDEuMSA/ICdtZWRpdW0nIDogJ2xvdycsXG4gICAgICAgICAgaW1wYWN0OiB0cmFmZmljSW1wYWN0XG4gICAgICAgIH0sXG4gICAgICAgIGV0YTogZXRhLnRvTG9jYWxlVGltZVN0cmluZyhbXSwgeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pLFxuICAgICAgICByb3V0ZUNvbG9yLFxuICAgICAgICBpc1doZWVsY2hhaXJBY2Nlc3NpYmxlOiB0cnVlLCAvLyBTaW1wbGlmaWVkIC0gaW4gcmVhbCBhcHAgd291bGQgY2hlY2sgYWN0dWFsIGFjY2Vzc2liaWxpdHlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IG1vY2tSb3V0ZXMgPSByb3V0ZXMubWFwKGZpbmFsaXplUm91dGUpO1xuXG4gICAgLy8gT25seSBzb3J0IGlmIHdlIGhhdmUgcm91dGVzXG4gICAgaWYgKG1vY2tSb3V0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gU29ydCByb3V0ZXMgYnkgdGhlaXIgYmFsYW5jZWQgc2NvcmUgKGhpZ2hlc3QgdG8gbG93ZXN0KVxuICAgICAgbW9ja1JvdXRlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIHZhbGlkIHNjb3Jlc1xuICAgICAgICBjb25zdCBzY29yZUEgPSBhLnNjb3Jlcz8ub3ZlcmFsbCB8fCBhLmJhbGFuY2VkU2NvcmU/LnNjb3JlIHx8IDA7XG4gICAgICAgIGNvbnN0IHNjb3JlQiA9IGIuc2NvcmVzPy5vdmVyYWxsIHx8IGIuYmFsYW5jZWRTY29yZT8uc2NvcmUgfHwgMDtcbiAgICAgICAgXG4gICAgICAgIC8vIFNvcnQgaW4gZGVzY2VuZGluZyBvcmRlciAoaGlnaGVzdCBzY29yZSBmaXJzdClcbiAgICAgICAgaWYgKHNjb3JlQSAhPT0gc2NvcmVCKSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3JlQiAtIHNjb3JlQTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgc2NvcmVzIGFyZSBlcXVhbCwgcHJlZmVyIGZhc3RlciByb3V0ZXMgZmlyc3RcbiAgICAgICAgcmV0dXJuIChhLmR1cmF0aW9uIHx8IDApIC0gKGIuZHVyYXRpb24gfHwgMCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIFwiYmVzdFwiIGluZGljYXRvciB0byB0aGUgZmlyc3Qgcm91dGUgKG5vdyB0aGUgYmVzdCBvbmUpXG4gICAgICBtb2NrUm91dGVzWzBdLm5hbWUgPSBgJHttb2NrUm91dGVzWzBdLm5hbWV9IChCZXN0IFJvdXRlKWA7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGVycm9yIGlmIG5vIHJvdXRlcyBmb3VuZFxuICAgIGlmIChtb2NrUm91dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5qc29uKHsgXG4gICAgICAgIGVycm9yOiBcIk5vIHJvdXRlcyBmb3VuZFwiLFxuICAgICAgICBtZXNzYWdlOiBcIldlIGNvdWxkbid0IGZpbmQgYW55IHJvdXRlcyBiZXR3ZWVuIHRoZXNlIGxvY2F0aW9ucy4gUGxlYXNlIHRyeSBkaWZmZXJlbnQgbG9jYXRpb25zIG9yIGFkanVzdCB5b3VyIHByZWZlcmVuY2VzLlwiXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhlIHNvcnRlZCByb3V0ZXNcbiAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oeyBcbiAgICAgIHJvdXRlczogbW9ja1JvdXRlcy5zbGljZSgwLCA2KSwgLy8gUmV0dXJuIGZpcnN0IDYgcm91dGVzLCBub3cgc29ydGVkIGZyb20gd29yc3QgdG8gYmVzdFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBmcm9tQ29vcmRzLFxuICAgICAgdG9Db29yZHMsXG4gICAgICBzdWJ3YXlBdmFpbGFibGU6IGJlc3RTdWJ3YXlMaW5lICE9PSBudWxsIHx8IGhhc1RyYW5zZmVyT3B0aW9ucyxcbiAgICAgIHRyYW5zZmVyUmVxdWlyZWQ6ICFiZXN0U3Vid2F5TGluZSAmJiBoYXNUcmFuc2Zlck9wdGlvbnMsXG4gICAgICB0cmFmZmljOiB7XG4gICAgICAgIG9yaWdpbjogb3JpZ2luVHJhZmZpYyxcbiAgICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uVHJhZmZpYyxcbiAgICAgICAgYXZlcmFnZTogYXZnVHJhZmZpY0ZhY3RvclxuICAgICAgfSxcbiAgICAgIHRvcG9sb2d5OiB7XG4gICAgICAgIG9yaWdpbjogb3JpZ2luVG9wb2xvZ3ksXG4gICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvblRvcG9sb2d5LFxuICAgICAgICBhdmVyYWdlOiBhdmdUb3BvbG9neURpZmZpY3VsdHlcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYWxjdWxhdGluZyByb3V0ZXM6JywgZXJyb3IpO1xuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IG1lc3NhZ2U6ICdFcnJvciBjYWxjdWxhdGluZyByb3V0ZXMnIH0pO1xuICB9XG59ICJdLCJuYW1lcyI6WyJ0cmFuc2l0QVBJIiwibG9jYXRpb25Db29yZGluYXRlcyIsInRyYWZmaWNDb25kaXRpb25zIiwibGV2ZWwiLCJmYWN0b3IiLCJ0b3BvbG9neURpZmZpY3VsdHkiLCJnZXRDb29yZGluYXRlcyIsImxvY2F0aW9uIiwibm9ybWFsaXplZExvY2F0aW9uIiwidG9Mb3dlckNhc2UiLCJuYW1lIiwiY29vcmRzIiwiT2JqZWN0IiwiZW50cmllcyIsImluY2x1ZGVzIiwiY2FsY3VsYXRlRGlzdGFuY2UiLCJsYXQxIiwibG5nMSIsImxhdDIiLCJsbmcyIiwiUiIsImRMYXQiLCJNYXRoIiwiUEkiLCJkTG5nIiwiYSIsInNpbiIsImNvcyIsImMiLCJhdGFuMiIsInNxcnQiLCJkaXN0YW5jZSIsImdldFJvdXRlQ29sb3IiLCJtb2RlIiwiY2FsY3VsYXRlQ08yRW1pc3Npb25zIiwiZGlzdGFuY2VLbSIsImVtaXNzaW9uc0ZhY3RvcnMiLCJlbWlzc2lvbkZhY3RvciIsImRlZmF1bHQiLCJyb3VuZCIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwibWVzc2FnZSIsImZyb20iLCJ0byIsInByaW9yaXR5Iiwibm9pc2UiLCJzYWZldHkiLCJiYWdzIiwid2hlZWxjaGFpciIsInF1ZXJ5IiwiZnJvbUNvb3JkcyIsInRvQ29vcmRzIiwiY29uc29sZSIsImxvZyIsInVzZXJQcmlvcml0eSIsInVzZXJOb2lzZSIsInVzZXJTYWZldHkiLCJ1c2VyQmFncyIsInBhcnNlSW50IiwicmVxdWlyZVdoZWVsY2hhaXIiLCJzdWJ3YXlTdGF0dXMiLCJnZXRTdWJ3YXlTdGF0dXMiLCJzdWJ3YXlMaW5lc0J5TG9jYXRpb24iLCJmcm9tQXJlYSIsImtleXMiLCJmaW5kIiwiYXJlYSIsInRvQXJlYSIsImZyb21TdWJ3YXlMaW5lcyIsInRvU3Vid2F5TGluZXMiLCJhdmFpbGFibGVTdWJ3YXlMaW5lcyIsImZpbHRlciIsImxpbmUiLCJoYXNUcmFuc2Zlck9wdGlvbnMiLCJsZW5ndGgiLCJvcGVyYXRpbmdTdWJ3YXlMaW5lcyIsImxpbmVTdGF0dXMiLCJzIiwiYmVzdFN1YndheUxpbmUiLCJmcm9tQm9yb3VnaFByZWZpeCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwidG9Cb3JvdWdoUHJlZml4IiwiYnVzUm91dGVzRnJvbSIsImdldEJ1c1JvdXRlcyIsImJ1c1JvdXRlc0J5QXJlYSIsInNwZWNpZmljRnJvbUJ1c2VzIiwic3BlY2lmaWNUb0J1c2VzIiwiY29ubmVjdGluZ0J1c2VzIiwiYnVzIiwib3JpZ2luQm9yb3VnaCIsImRlc3RpbmF0aW9uQm9yb3VnaCIsImlzQ3Jvc3NCb3JvdWdoVHJpcCIsImV4cHJlc3NCdXNSb3V0ZXMiLCJleHByZXNzQnVzUm91dGUiLCJyb3V0ZUtleSIsInJldmVyc2VSb3V0ZUtleSIsImJ1c1JvdXRlIiwiZmxvb3IiLCJyYW5kb20iLCJvcmlnaW5UcmFmZmljIiwiZGVzdGluYXRpb25UcmFmZmljIiwib3JpZ2luVG9wb2xvZ3kiLCJkZXN0aW5hdGlvblRvcG9sb2d5IiwiYXZnVHJhZmZpY0ZhY3RvciIsImF2Z1RvcG9sb2d5RGlmZmljdWx0eSIsImdlbmVyYXRlUm91dGVzIiwicm91dGVzIiwiY2FsY3VsYXRlQmFsYW5jZWRTY29yZSIsImR1cmF0aW9uIiwiY29zdCIsImNvbWZvcnQiLCJudW1UcmFuc2ZlcnMiLCJ0aW1lU2NvcmUiLCJtYXgiLCJjb3N0U2NvcmUiLCJjb21mb3J0U2NvcmUiLCJ0cmFuc2ZlclNjb3JlIiwic2NvcmUiLCJyYXciLCJ3YWxraW5nUm91dGUiLCJpZCIsInZlY3RvclNjb3JlIiwic2VnbWVudHMiLCJzdGFydExvY2F0aW9uIiwiZW5kTG9jYXRpb24iLCJsaW5lSW5mbyIsImJhbGFuY2VkU2NvcmUiLCJjbzIiLCJwdXNoIiwiYmlrZVJvdXRlIiwic3Vid2F5Um91dGUiLCJ1YmVyUm91dGUiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsInNvcnQiLCJiIiwiZmluYWxpemVSb3V0ZSIsInJvdXRlIiwiaGFzVG9wb2xvZ3lJbXBhY3QiLCJzb21lIiwic2VnbWVudCIsInJvYWRCYXNlZFNlZ21lbnRzIiwidHJhZmZpY0ltcGFjdCIsIm5vdyIsIkRhdGUiLCJldGEiLCJnZXRUaW1lIiwicm91dGVDb2xvciIsInRyYWZmaWMiLCJpbXBhY3QiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJob3VyIiwibWludXRlIiwiaXNXaGVlbGNoYWlyQWNjZXNzaWJsZSIsIm1vY2tSb3V0ZXMiLCJtYXAiLCJzY29yZUEiLCJzY29yZXMiLCJvdmVyYWxsIiwic2NvcmVCIiwiZXJyb3IiLCJzbGljZSIsInN1YndheUF2YWlsYWJsZSIsInRyYW5zZmVyUmVxdWlyZWQiLCJvcmlnaW4iLCJkZXN0aW5hdGlvbiIsImF2ZXJhZ2UiLCJ0b3BvbG9neSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/routes.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Froutes&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Froutes.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();