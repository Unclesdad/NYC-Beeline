"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/routes",{

/***/ "./src/components/AnimatedBackground.tsx":
/*!***********************************************!*\
  !*** ./src/components/AnimatedBackground.tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nconst AnimatedBackground = (param)=>{\n    let { children, theme = \"honey\", intensity = \"medium\", pattern = \"hexagon\" } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Define theme colors with enhanced gradients\n    const themeColors = {\n        honey: {\n            primary: \"#f59e0b\",\n            secondary: \"#fbbf24\",\n            tertiary: \"#fcd34d\",\n            accent: \"#d97706\",\n            background: \"linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%)\"\n        },\n        blue: {\n            primary: \"#3b82f6\",\n            secondary: \"#60a5fa\",\n            tertiary: \"#93c5fd\",\n            accent: \"#2563eb\",\n            background: \"linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)\"\n        },\n        green: {\n            primary: \"#10b981\",\n            secondary: \"#34d399\",\n            tertiary: \"#6ee7b7\",\n            accent: \"#059669\",\n            background: \"linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%)\"\n        }\n    };\n    // Set particle count based on intensity\n    const getParticleCount = ()=>{\n        switch(intensity){\n            case \"low\":\n                return 30;\n            case \"high\":\n                return 100;\n            default:\n                return 60; // medium\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Set canvas dimensions to match window\n        const setCanvasDimensions = ()=>{\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        };\n        setCanvasDimensions();\n        window.addEventListener(\"resize\", setCanvasDimensions);\n        // Create particles\n        const colors = themeColors[theme];\n        const particleColors = [\n            colors.primary,\n            colors.secondary,\n            colors.tertiary,\n            colors.accent\n        ];\n        const particles = [];\n        // Enhanced Particle class with improved animation\n        class Particle {\n            update() {\n                this.x += this.speedX;\n                this.y += this.speedY;\n                // Smooth pulsing effect\n                this.pulseFactor += this.pulseSpeed;\n                this.size = this.baseSize + Math.sin(this.pulseFactor) * 0.8;\n                // Bounce off edges with slight randomization\n                if (this.x + this.size > canvas.width || this.x - this.size < 0) {\n                    this.speedX = -this.speedX * (0.9 + Math.random() * 0.2);\n                    this.speedY += (Math.random() - 0.5) * 0.1; // Add slight randomness\n                }\n                if (this.y + this.size > canvas.height || this.y - this.size < 0) {\n                    this.speedY = -this.speedY * (0.9 + Math.random() * 0.2);\n                    this.speedX += (Math.random() - 0.5) * 0.1; // Add slight randomness\n                }\n                // Ensure particles don't slow down too much\n                const speed = Math.sqrt(this.speedX * this.speedX + this.speedY * this.speedY);\n                if (speed < 0.1) {\n                    const boost = 0.2 + Math.random() * 0.3;\n                    this.speedX = this.speedX / speed * boost;\n                    this.speedY = this.speedY / speed * boost;\n                }\n            }\n            draw() {\n                if (!ctx) return;\n                ctx.beginPath();\n                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n                ctx.fillStyle = this.color;\n                ctx.globalAlpha = this.opacity;\n                ctx.fill();\n            }\n            constructor(){\n                this.x = Math.random() * canvas.width;\n                this.y = Math.random() * canvas.height;\n                this.baseSize = Math.random() * 5 + 2;\n                this.size = this.baseSize;\n                this.speedX = Math.random() * 1 - 0.5;\n                this.speedY = Math.random() * 1 - 0.5;\n                this.color = particleColors[Math.floor(Math.random() * particleColors.length)];\n                this.pulseFactor = 0;\n                this.pulseSpeed = Math.random() * 0.05 + 0.01;\n                this.opacity = Math.random() * 0.5 + 0.3;\n            }\n        }\n        // Initialize particles\n        const init = ()=>{\n            const particleCount = getParticleCount();\n            for(let i = 0; i < particleCount; i++){\n                particles.push(new Particle());\n            }\n        };\n        // Animate\n        const animate = ()=>{\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Draw background patterns based on selected pattern\n            if (pattern === \"hexagon\" && theme === \"honey\") {\n                drawHexagonPattern(ctx, canvas.width, canvas.height);\n            } else if (pattern === \"circles\") {\n                drawCirclePattern(ctx, canvas.width, canvas.height);\n            } else if (pattern === \"dots\") {\n                drawDotPattern(ctx, canvas.width, canvas.height);\n            }\n            // Update and draw particles\n            for(let i = 0; i < particles.length; i++){\n                particles[i].update();\n                particles[i].draw();\n                // Connect particles with lines if they're close\n                connectParticles(particles[i], particles);\n            }\n            requestAnimationFrame(animate);\n        };\n        // Connect particles with lines - enhanced version\n        const connectParticles = (particle, particles)=>{\n            const maxDistance = intensity === \"high\" ? 150 : intensity === \"medium\" ? 120 : 80;\n            for(let i = 0; i < particles.length; i++){\n                const dx = particle.x - particles[i].x;\n                const dy = particle.y - particles[i].y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance < maxDistance) {\n                    // Create gradient lines for better visual effect\n                    const gradient = ctx.createLinearGradient(particle.x, particle.y, particles[i].x, particles[i].y);\n                    gradient.addColorStop(0, particle.color);\n                    gradient.addColorStop(1, particles[i].color);\n                    ctx.beginPath();\n                    ctx.strokeStyle = gradient;\n                    ctx.globalAlpha = 0.3 * (1 - distance / maxDistance);\n                    ctx.lineWidth = 0.8;\n                    ctx.moveTo(particle.x, particle.y);\n                    ctx.lineTo(particles[i].x, particles[i].y);\n                    ctx.stroke();\n                }\n            }\n        };\n        // Draw hexagon pattern for honey theme\n        const drawHexagonPattern = (ctx, width, height)=>{\n            const hexSize = 40;\n            const hexWidth = hexSize * 2;\n            const hexHeight = Math.sqrt(3) * hexSize;\n            ctx.strokeStyle = themeColors.honey.tertiary;\n            ctx.lineWidth = 0.5;\n            ctx.globalAlpha = 0.15;\n            for(let y = -hexHeight; y < height + hexHeight; y += hexHeight){\n                for(let x = -hexWidth; x < width + hexWidth; x += hexWidth * 1.5){\n                    // Draw hexagons in a staggered pattern\n                    const offsetY = Math.floor(x / (hexWidth * 1.5)) % 2 === 0 ? 0 : hexHeight / 2;\n                    drawHexagon(ctx, x, y + offsetY, hexSize);\n                }\n            }\n        };\n        // Draw circle pattern\n        const drawCirclePattern = (ctx, width, height)=>{\n            const circleRadius = 50;\n            const circleSpacing = 120;\n            ctx.strokeStyle = themeColors[theme].tertiary;\n            ctx.lineWidth = 0.5;\n            ctx.globalAlpha = 0.1;\n            for(let y = -circleRadius; y < height + circleRadius; y += circleSpacing){\n                for(let x = -circleRadius; x < width + circleRadius; x += circleSpacing){\n                    // Add some variance to circle positions\n                    const offsetX = Math.sin(y * 0.1) * 20;\n                    const offsetY = Math.cos(x * 0.1) * 20;\n                    ctx.beginPath();\n                    ctx.arc(x + offsetX, y + offsetY, circleRadius, 0, Math.PI * 2);\n                    ctx.stroke();\n                    // Add smaller inner circle\n                    ctx.beginPath();\n                    ctx.arc(x + offsetX, y + offsetY, circleRadius * 0.6, 0, Math.PI * 2);\n                    ctx.stroke();\n                }\n            }\n        };\n        // Draw dot pattern\n        const drawDotPattern = (ctx, width, height)=>{\n            const dotSpacing = 40;\n            const dotRadius = 1;\n            ctx.fillStyle = themeColors[theme].tertiary;\n            ctx.globalAlpha = 0.2;\n            for(let y = 0; y < height; y += dotSpacing){\n                for(let x = 0; x < width; x += dotSpacing){\n                    ctx.beginPath();\n                    ctx.arc(x, y, dotRadius, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n            }\n        };\n        // Draw a single hexagon\n        const drawHexagon = (ctx, x, y, size)=>{\n            ctx.beginPath();\n            for(let i = 0; i < 6; i++){\n                const angle = 2 * Math.PI / 6 * i;\n                const xPos = x + size * Math.cos(angle);\n                const yPos = y + size * Math.sin(angle);\n                if (i === 0) {\n                    ctx.moveTo(xPos, yPos);\n                } else {\n                    ctx.lineTo(xPos, yPos);\n                }\n            }\n            ctx.closePath();\n            ctx.stroke();\n        };\n        init();\n        animate();\n        // Cleanup\n        return ()=>{\n            window.removeEventListener(\"resize\", setCanvasDimensions);\n        };\n    }, [\n        theme,\n        intensity,\n        pattern\n    ]);\n    // Get the background color based on theme\n    const getBackgroundStyle = ()=>{\n        const bgColor = theme === \"honey\" ? \"#fffbeb\" : theme === \"blue\" ? \"#eff6ff\" : \"#ecfdf5\";\n        // Use gradient for enhanced look\n        const gradient = themeColors[theme].background;\n        return {\n            background: gradient\n        };\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative min-h-screen overflow-hidden\",\n        style: getBackgroundStyle(),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                className: \"absolute top-0 left-0 w-full h-full\",\n                style: {\n                    pointerEvents: \"none\"\n                }\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Aaron\\\\Documents\\\\NYC-Beeline\\\\src\\\\components\\\\AnimatedBackground.tsx\",\n                lineNumber: 306,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative z-10\",\n                children: children\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Aaron\\\\Documents\\\\NYC-Beeline\\\\src\\\\components\\\\AnimatedBackground.tsx\",\n                lineNumber: 311,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Aaron\\\\Documents\\\\NYC-Beeline\\\\src\\\\components\\\\AnimatedBackground.tsx\",\n        lineNumber: 305,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AnimatedBackground, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = AnimatedBackground;\n/* harmony default export */ __webpack_exports__[\"default\"] = (AnimatedBackground);\nvar _c;\n$RefreshReg$(_c, \"AnimatedBackground\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9BbmltYXRlZEJhY2tncm91bmQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUQ7QUFTakQsTUFBTUcscUJBQXdEO1FBQUMsRUFDN0RDLFFBQVEsRUFDUkMsUUFBUSxPQUFPLEVBQ2ZDLFlBQVksUUFBUSxFQUNwQkMsVUFBVSxTQUFTLEVBQ3BCOztJQUNDLE1BQU1DLFlBQVlOLDZDQUFNQSxDQUFvQjtJQUU1Qyw4Q0FBOEM7SUFDOUMsTUFBTU8sY0FBYztRQUNsQkMsT0FBTztZQUNMQyxTQUFTO1lBQ1RDLFdBQVc7WUFDWEMsVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLFlBQVk7UUFDZDtRQUNBQyxNQUFNO1lBQ0pMLFNBQVM7WUFDVEMsV0FBVztZQUNYQyxVQUFVO1lBQ1ZDLFFBQVE7WUFDUkMsWUFBWTtRQUNkO1FBQ0FFLE9BQU87WUFDTE4sU0FBUztZQUNUQyxXQUFXO1lBQ1hDLFVBQVU7WUFDVkMsUUFBUTtZQUNSQyxZQUFZO1FBQ2Q7SUFDRjtJQUVBLHdDQUF3QztJQUN4QyxNQUFNRyxtQkFBbUI7UUFDdkIsT0FBUVo7WUFDTixLQUFLO2dCQUFPLE9BQU87WUFDbkIsS0FBSztnQkFBUSxPQUFPO1lBQ3BCO2dCQUFTLE9BQU8sSUFBSSxTQUFTO1FBQy9CO0lBQ0Y7SUFFQUwsZ0RBQVNBLENBQUM7UUFDUixNQUFNa0IsU0FBU1gsVUFBVVksT0FBTztRQUNoQyxJQUFJLENBQUNELFFBQVE7UUFFYixNQUFNRSxNQUFNRixPQUFPRyxVQUFVLENBQUM7UUFDOUIsSUFBSSxDQUFDRCxLQUFLO1FBRVYsd0NBQXdDO1FBQ3hDLE1BQU1FLHNCQUFzQjtZQUMxQkosT0FBT0ssS0FBSyxHQUFHQyxPQUFPQyxVQUFVO1lBQ2hDUCxPQUFPUSxNQUFNLEdBQUdGLE9BQU9HLFdBQVc7UUFDcEM7UUFFQUw7UUFDQUUsT0FBT0ksZ0JBQWdCLENBQUMsVUFBVU47UUFFbEMsbUJBQW1CO1FBQ25CLE1BQU1PLFNBQVNyQixXQUFXLENBQUNKLE1BQU07UUFD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QUd0QztHQWhUTUQ7S0FBQUE7QUFrVE4sK0RBQWVBLGtCQUFrQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9BbmltYXRlZEJhY2tncm91bmQudHN4PzMwMzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW50ZXJmYWNlIEFuaW1hdGVkQmFja2dyb3VuZFByb3BzIHtcclxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xyXG4gIHRoZW1lOiAnaG9uZXknIHwgJ2JsdWUnIHwgJ2dyZWVuJztcclxuICBpbnRlbnNpdHk/OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnO1xyXG4gIHBhdHRlcm4/OiAnaGV4YWdvbicgfCAnY2lyY2xlcycgfCAnZG90cycgfCAnbm9uZSc7XHJcbn1cclxuXHJcbmNvbnN0IEFuaW1hdGVkQmFja2dyb3VuZDogUmVhY3QuRkM8QW5pbWF0ZWRCYWNrZ3JvdW5kUHJvcHM+ID0gKHsgXHJcbiAgY2hpbGRyZW4sIFxyXG4gIHRoZW1lID0gJ2hvbmV5JyxcclxuICBpbnRlbnNpdHkgPSAnbWVkaXVtJyxcclxuICBwYXR0ZXJuID0gJ2hleGFnb24nXHJcbn0pID0+IHtcclxuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xyXG4gIFxyXG4gIC8vIERlZmluZSB0aGVtZSBjb2xvcnMgd2l0aCBlbmhhbmNlZCBncmFkaWVudHNcclxuICBjb25zdCB0aGVtZUNvbG9ycyA9IHtcclxuICAgIGhvbmV5OiB7XHJcbiAgICAgIHByaW1hcnk6ICcjZjU5ZTBiJywgLy8gYW1iZXItNTAwXHJcbiAgICAgIHNlY29uZGFyeTogJyNmYmJmMjQnLCAvLyBhbWJlci00MDBcclxuICAgICAgdGVydGlhcnk6ICcjZmNkMzRkJywgLy8gYW1iZXItMzAwXHJcbiAgICAgIGFjY2VudDogJyNkOTc3MDYnLCAvLyBhbWJlci02MDBcclxuICAgICAgYmFja2dyb3VuZDogJ2xpbmVhci1ncmFkaWVudCgxMzVkZWcsICNmZmZiZWIgMCUsICNmZWYzYzcgMTAwJSknLCAvLyBhbWJlci01MCB0byBhbWJlci0xMDBcclxuICAgIH0sXHJcbiAgICBibHVlOiB7XHJcbiAgICAgIHByaW1hcnk6ICcjM2I4MmY2JywgLy8gYmx1ZS01MDBcclxuICAgICAgc2Vjb25kYXJ5OiAnIzYwYTVmYScsIC8vIGJsdWUtNDAwXHJcbiAgICAgIHRlcnRpYXJ5OiAnIzkzYzVmZCcsIC8vIGJsdWUtMzAwXHJcbiAgICAgIGFjY2VudDogJyMyNTYzZWInLCAvLyBibHVlLTYwMFxyXG4gICAgICBiYWNrZ3JvdW5kOiAnbGluZWFyLWdyYWRpZW50KDEzNWRlZywgI2VmZjZmZiAwJSwgI2RiZWFmZSAxMDAlKScsIC8vIGJsdWUtNTAgdG8gYmx1ZS0xMDBcclxuICAgIH0sXHJcbiAgICBncmVlbjoge1xyXG4gICAgICBwcmltYXJ5OiAnIzEwYjk4MScsIC8vIGVtZXJhbGQtNTAwXHJcbiAgICAgIHNlY29uZGFyeTogJyMzNGQzOTknLCAvLyBlbWVyYWxkLTQwMFxyXG4gICAgICB0ZXJ0aWFyeTogJyM2ZWU3YjcnLCAvLyBlbWVyYWxkLTMwMFxyXG4gICAgICBhY2NlbnQ6ICcjMDU5NjY5JywgLy8gZW1lcmFsZC02MDBcclxuICAgICAgYmFja2dyb3VuZDogJ2xpbmVhci1ncmFkaWVudCgxMzVkZWcsICNlY2ZkZjUgMCUsICNkMWZhZTUgMTAwJSknLCAvLyBlbWVyYWxkLTUwIHRvIGVtZXJhbGQtMTAwXHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gU2V0IHBhcnRpY2xlIGNvdW50IGJhc2VkIG9uIGludGVuc2l0eVxyXG4gIGNvbnN0IGdldFBhcnRpY2xlQ291bnQgPSAoKSA9PiB7XHJcbiAgICBzd2l0Y2ggKGludGVuc2l0eSkge1xyXG4gICAgICBjYXNlICdsb3cnOiByZXR1cm4gMzA7XHJcbiAgICAgIGNhc2UgJ2hpZ2gnOiByZXR1cm4gMTAwO1xyXG4gICAgICBkZWZhdWx0OiByZXR1cm4gNjA7IC8vIG1lZGl1bVxyXG4gICAgfVxyXG4gIH07XHJcbiAgXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuICAgIFxyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCB3aW5kb3dcclxuICAgIGNvbnN0IHNldENhbnZhc0RpbWVuc2lvbnMgPSAoKSA9PiB7XHJcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgfTtcclxuXHJcbiAgICBzZXRDYW52YXNEaW1lbnNpb25zKCk7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc2V0Q2FudmFzRGltZW5zaW9ucyk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHBhcnRpY2xlc1xyXG4gICAgY29uc3QgY29sb3JzID0gdGhlbWVDb2xvcnNbdGhlbWVdO1xyXG4gICAgY29uc3QgcGFydGljbGVDb2xvcnMgPSBbY29sb3JzLnByaW1hcnksIGNvbG9ycy5zZWNvbmRhcnksIGNvbG9ycy50ZXJ0aWFyeSwgY29sb3JzLmFjY2VudF07XHJcbiAgICBjb25zdCBwYXJ0aWNsZXM6IFBhcnRpY2xlW10gPSBbXTtcclxuICAgIFxyXG4gICAgLy8gRW5oYW5jZWQgUGFydGljbGUgY2xhc3Mgd2l0aCBpbXByb3ZlZCBhbmltYXRpb25cclxuICAgIGNsYXNzIFBhcnRpY2xlIHtcclxuICAgICAgeDogbnVtYmVyO1xyXG4gICAgICB5OiBudW1iZXI7XHJcbiAgICAgIHNpemU6IG51bWJlcjtcclxuICAgICAgYmFzZVNpemU6IG51bWJlcjtcclxuICAgICAgc3BlZWRYOiBudW1iZXI7XHJcbiAgICAgIHNwZWVkWTogbnVtYmVyO1xyXG4gICAgICBjb2xvcjogc3RyaW5nO1xyXG4gICAgICBwdWxzZUZhY3RvcjogbnVtYmVyO1xyXG4gICAgICBwdWxzZVNwZWVkOiBudW1iZXI7XHJcbiAgICAgIG9wYWNpdHk6IG51bWJlcjtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMueCA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5yYW5kb20oKSAqIGNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5iYXNlU2l6ZSA9IE1hdGgucmFuZG9tKCkgKiA1ICsgMjtcclxuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLmJhc2VTaXplO1xyXG4gICAgICAgIHRoaXMuc3BlZWRYID0gTWF0aC5yYW5kb20oKSAqIDEgLSAwLjU7XHJcbiAgICAgICAgdGhpcy5zcGVlZFkgPSBNYXRoLnJhbmRvbSgpICogMSAtIDAuNTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gcGFydGljbGVDb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGFydGljbGVDb2xvcnMubGVuZ3RoKV07XHJcbiAgICAgICAgdGhpcy5wdWxzZUZhY3RvciA9IDA7XHJcbiAgICAgICAgdGhpcy5wdWxzZVNwZWVkID0gTWF0aC5yYW5kb20oKSAqIDAuMDUgKyAwLjAxO1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IE1hdGgucmFuZG9tKCkgKiAwLjUgKyAwLjM7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLnggKz0gdGhpcy5zcGVlZFg7XHJcbiAgICAgICAgdGhpcy55ICs9IHRoaXMuc3BlZWRZO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNtb290aCBwdWxzaW5nIGVmZmVjdFxyXG4gICAgICAgIHRoaXMucHVsc2VGYWN0b3IgKz0gdGhpcy5wdWxzZVNwZWVkO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuYmFzZVNpemUgKyBNYXRoLnNpbih0aGlzLnB1bHNlRmFjdG9yKSAqIDAuODtcclxuICAgICAgICBcclxuICAgICAgICAvLyBCb3VuY2Ugb2ZmIGVkZ2VzIHdpdGggc2xpZ2h0IHJhbmRvbWl6YXRpb25cclxuICAgICAgICBpZiAodGhpcy54ICsgdGhpcy5zaXplID4gY2FudmFzLndpZHRoIHx8IHRoaXMueCAtIHRoaXMuc2l6ZSA8IDApIHtcclxuICAgICAgICAgIHRoaXMuc3BlZWRYID0gLXRoaXMuc3BlZWRYICogKDAuOSArIE1hdGgucmFuZG9tKCkgKiAwLjIpO1xyXG4gICAgICAgICAgdGhpcy5zcGVlZFkgKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4xOyAvLyBBZGQgc2xpZ2h0IHJhbmRvbW5lc3NcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMueSArIHRoaXMuc2l6ZSA+IGNhbnZhcy5oZWlnaHQgfHwgdGhpcy55IC0gdGhpcy5zaXplIDwgMCkge1xyXG4gICAgICAgICAgdGhpcy5zcGVlZFkgPSAtdGhpcy5zcGVlZFkgKiAoMC45ICsgTWF0aC5yYW5kb20oKSAqIDAuMik7XHJcbiAgICAgICAgICB0aGlzLnNwZWVkWCArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjE7IC8vIEFkZCBzbGlnaHQgcmFuZG9tbmVzc1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBFbnN1cmUgcGFydGljbGVzIGRvbid0IHNsb3cgZG93biB0b28gbXVjaFxyXG4gICAgICAgIGNvbnN0IHNwZWVkID0gTWF0aC5zcXJ0KHRoaXMuc3BlZWRYICogdGhpcy5zcGVlZFggKyB0aGlzLnNwZWVkWSAqIHRoaXMuc3BlZWRZKTtcclxuICAgICAgICBpZiAoc3BlZWQgPCAwLjEpIHtcclxuICAgICAgICAgIGNvbnN0IGJvb3N0ID0gMC4yICsgTWF0aC5yYW5kb20oKSAqIDAuMztcclxuICAgICAgICAgIHRoaXMuc3BlZWRYID0gdGhpcy5zcGVlZFggLyBzcGVlZCAqIGJvb3N0O1xyXG4gICAgICAgICAgdGhpcy5zcGVlZFkgPSB0aGlzLnNwZWVkWSAvIHNwZWVkICogYm9vc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBkcmF3KCkge1xyXG4gICAgICAgIGlmICghY3R4KSByZXR1cm47XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5hcmModGhpcy54LCB0aGlzLnksIHRoaXMuc2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEluaXRpYWxpemUgcGFydGljbGVzXHJcbiAgICBjb25zdCBpbml0ID0gKCkgPT4ge1xyXG4gICAgICBjb25zdCBwYXJ0aWNsZUNvdW50ID0gZ2V0UGFydGljbGVDb3VudCgpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2xlQ291bnQ7IGkrKykge1xyXG4gICAgICAgIHBhcnRpY2xlcy5wdXNoKG5ldyBQYXJ0aWNsZSgpKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gQW5pbWF0ZVxyXG4gICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcclxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICBcclxuICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kIHBhdHRlcm5zIGJhc2VkIG9uIHNlbGVjdGVkIHBhdHRlcm5cclxuICAgICAgaWYgKHBhdHRlcm4gPT09ICdoZXhhZ29uJyAmJiB0aGVtZSA9PT0gJ2hvbmV5Jykge1xyXG4gICAgICAgIGRyYXdIZXhhZ29uUGF0dGVybihjdHgsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgIH0gZWxzZSBpZiAocGF0dGVybiA9PT0gJ2NpcmNsZXMnKSB7XHJcbiAgICAgICAgZHJhd0NpcmNsZVBhdHRlcm4oY3R4LCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHBhdHRlcm4gPT09ICdkb3RzJykge1xyXG4gICAgICAgIGRyYXdEb3RQYXR0ZXJuKGN0eCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGFuZCBkcmF3IHBhcnRpY2xlc1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2xlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBhcnRpY2xlc1tpXS51cGRhdGUoKTtcclxuICAgICAgICBwYXJ0aWNsZXNbaV0uZHJhdygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENvbm5lY3QgcGFydGljbGVzIHdpdGggbGluZXMgaWYgdGhleSdyZSBjbG9zZVxyXG4gICAgICAgIGNvbm5lY3RQYXJ0aWNsZXMocGFydGljbGVzW2ldLCBwYXJ0aWNsZXMpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBDb25uZWN0IHBhcnRpY2xlcyB3aXRoIGxpbmVzIC0gZW5oYW5jZWQgdmVyc2lvblxyXG4gICAgY29uc3QgY29ubmVjdFBhcnRpY2xlcyA9IChwYXJ0aWNsZTogUGFydGljbGUsIHBhcnRpY2xlczogUGFydGljbGVbXSkgPT4ge1xyXG4gICAgICBjb25zdCBtYXhEaXN0YW5jZSA9IGludGVuc2l0eSA9PT0gJ2hpZ2gnID8gMTUwIDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZW5zaXR5ID09PSAnbWVkaXVtJyA/IDEyMCA6IDgwO1xyXG4gICAgICBcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBkeCA9IHBhcnRpY2xlLnggLSBwYXJ0aWNsZXNbaV0ueDtcclxuICAgICAgICBjb25zdCBkeSA9IHBhcnRpY2xlLnkgLSBwYXJ0aWNsZXNbaV0ueTtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWF4RGlzdGFuY2UpIHtcclxuICAgICAgICAgIC8vIENyZWF0ZSBncmFkaWVudCBsaW5lcyBmb3IgYmV0dGVyIHZpc3VhbCBlZmZlY3RcclxuICAgICAgICAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxyXG4gICAgICAgICAgICBwYXJ0aWNsZS54LCBwYXJ0aWNsZS55LCBcclxuICAgICAgICAgICAgcGFydGljbGVzW2ldLngsIHBhcnRpY2xlc1tpXS55XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgcGFydGljbGUuY29sb3IpO1xyXG4gICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIHBhcnRpY2xlc1tpXS5jb2xvcik7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGdyYWRpZW50O1xyXG4gICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4zICogKDEgLSBkaXN0YW5jZSAvIG1heERpc3RhbmNlKTtcclxuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAwLjg7XHJcbiAgICAgICAgICBjdHgubW92ZVRvKHBhcnRpY2xlLngsIHBhcnRpY2xlLnkpO1xyXG4gICAgICAgICAgY3R4LmxpbmVUbyhwYXJ0aWNsZXNbaV0ueCwgcGFydGljbGVzW2ldLnkpO1xyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gRHJhdyBoZXhhZ29uIHBhdHRlcm4gZm9yIGhvbmV5IHRoZW1lXHJcbiAgICBjb25zdCBkcmF3SGV4YWdvblBhdHRlcm4gPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGNvbnN0IGhleFNpemUgPSA0MDtcclxuICAgICAgY29uc3QgaGV4V2lkdGggPSBoZXhTaXplICogMjtcclxuICAgICAgY29uc3QgaGV4SGVpZ2h0ID0gTWF0aC5zcXJ0KDMpICogaGV4U2l6ZTtcclxuICAgICAgXHJcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lQ29sb3JzLmhvbmV5LnRlcnRpYXJ5O1xyXG4gICAgICBjdHgubGluZVdpZHRoID0gMC41O1xyXG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjE1O1xyXG4gICAgICBcclxuICAgICAgZm9yIChsZXQgeSA9IC1oZXhIZWlnaHQ7IHkgPCBoZWlnaHQgKyBoZXhIZWlnaHQ7IHkgKz0gaGV4SGVpZ2h0KSB7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IC1oZXhXaWR0aDsgeCA8IHdpZHRoICsgaGV4V2lkdGg7IHggKz0gaGV4V2lkdGggKiAxLjUpIHtcclxuICAgICAgICAgIC8vIERyYXcgaGV4YWdvbnMgaW4gYSBzdGFnZ2VyZWQgcGF0dGVyblxyXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IoeCAvIChoZXhXaWR0aCAqIDEuNSkpICUgMiA9PT0gMCA/IDAgOiBoZXhIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBkcmF3SGV4YWdvbihjdHgsIHgsIHkgKyBvZmZzZXRZLCBoZXhTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIERyYXcgY2lyY2xlIHBhdHRlcm5cclxuICAgIGNvbnN0IGRyYXdDaXJjbGVQYXR0ZXJuID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4ge1xyXG4gICAgICBjb25zdCBjaXJjbGVSYWRpdXMgPSA1MDtcclxuICAgICAgY29uc3QgY2lyY2xlU3BhY2luZyA9IDEyMDtcclxuICAgICAgXHJcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoZW1lQ29sb3JzW3RoZW1lXS50ZXJ0aWFyeTtcclxuICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcclxuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4xO1xyXG4gICAgICBcclxuICAgICAgZm9yIChsZXQgeSA9IC1jaXJjbGVSYWRpdXM7IHkgPCBoZWlnaHQgKyBjaXJjbGVSYWRpdXM7IHkgKz0gY2lyY2xlU3BhY2luZykge1xyXG4gICAgICAgIGZvciAobGV0IHggPSAtY2lyY2xlUmFkaXVzOyB4IDwgd2lkdGggKyBjaXJjbGVSYWRpdXM7IHggKz0gY2lyY2xlU3BhY2luZykge1xyXG4gICAgICAgICAgLy8gQWRkIHNvbWUgdmFyaWFuY2UgdG8gY2lyY2xlIHBvc2l0aW9uc1xyXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguc2luKHkgKiAwLjEpICogMjA7XHJcbiAgICAgICAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5jb3MoeCAqIDAuMSkgKiAyMDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgY3R4LmFyYyh4ICsgb2Zmc2V0WCwgeSArIG9mZnNldFksIGNpcmNsZVJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBBZGQgc21hbGxlciBpbm5lciBjaXJjbGVcclxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgIGN0eC5hcmMoeCArIG9mZnNldFgsIHkgKyBvZmZzZXRZLCBjaXJjbGVSYWRpdXMgKiAwLjYsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIERyYXcgZG90IHBhdHRlcm5cclxuICAgIGNvbnN0IGRyYXdEb3RQYXR0ZXJuID0gKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4ge1xyXG4gICAgICBjb25zdCBkb3RTcGFjaW5nID0gNDA7XHJcbiAgICAgIGNvbnN0IGRvdFJhZGl1cyA9IDE7XHJcbiAgICAgIFxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhlbWVDb2xvcnNbdGhlbWVdLnRlcnRpYXJ5O1xyXG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjI7XHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSArPSBkb3RTcGFjaW5nKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCArPSBkb3RTcGFjaW5nKSB7XHJcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICBjdHguYXJjKHgsIHksIGRvdFJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIERyYXcgYSBzaW5nbGUgaGV4YWdvblxyXG4gICAgY29uc3QgZHJhd0hleGFnb24gPSAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBzaXplOiBudW1iZXIpID0+IHtcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gMiAqIE1hdGguUEkgLyA2ICogaTtcclxuICAgICAgICBjb25zdCB4UG9zID0geCArIHNpemUgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgY29uc3QgeVBvcyA9IHkgKyBzaXplICogTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICBjdHgubW92ZVRvKHhQb3MsIHlQb3MpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjdHgubGluZVRvKHhQb3MsIHlQb3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGluaXQoKTtcclxuICAgIGFuaW1hdGUoKTtcclxuICAgIFxyXG4gICAgLy8gQ2xlYW51cFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHNldENhbnZhc0RpbWVuc2lvbnMpO1xyXG4gICAgfTtcclxuICB9LCBbdGhlbWUsIGludGVuc2l0eSwgcGF0dGVybl0pO1xyXG4gIFxyXG4gIC8vIEdldCB0aGUgYmFja2dyb3VuZCBjb2xvciBiYXNlZCBvbiB0aGVtZVxyXG4gIGNvbnN0IGdldEJhY2tncm91bmRTdHlsZSA9ICgpID0+IHtcclxuICAgIGNvbnN0IGJnQ29sb3IgPSB0aGVtZSA9PT0gJ2hvbmV5JyA/ICcjZmZmYmViJyA6IFxyXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lID09PSAnYmx1ZScgPyAnI2VmZjZmZicgOiBcclxuICAgICAgICAgICAgICAgICAgICAnI2VjZmRmNSc7XHJcbiAgICBcclxuICAgIC8vIFVzZSBncmFkaWVudCBmb3IgZW5oYW5jZWQgbG9va1xyXG4gICAgY29uc3QgZ3JhZGllbnQgPSB0aGVtZUNvbG9yc1t0aGVtZV0uYmFja2dyb3VuZDtcclxuICAgIFxyXG4gICAgcmV0dXJuIHsgYmFja2dyb3VuZDogZ3JhZGllbnQgfTtcclxuICB9O1xyXG4gIFxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlIG1pbi1oLXNjcmVlbiBvdmVyZmxvdy1oaWRkZW5cIiBzdHlsZT17Z2V0QmFja2dyb3VuZFN0eWxlKCl9PlxyXG4gICAgICA8Y2FudmFzIFxyXG4gICAgICAgIHJlZj17Y2FudmFzUmVmfSBcclxuICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgdy1mdWxsIGgtZnVsbFwiIFxyXG4gICAgICAgIHN0eWxlPXt7IHBvaW50ZXJFdmVudHM6ICdub25lJyB9fVxyXG4gICAgICAvPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlIHotMTBcIj57Y2hpbGRyZW59PC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0ZWRCYWNrZ3JvdW5kOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJBbmltYXRlZEJhY2tncm91bmQiLCJjaGlsZHJlbiIsInRoZW1lIiwiaW50ZW5zaXR5IiwicGF0dGVybiIsImNhbnZhc1JlZiIsInRoZW1lQ29sb3JzIiwiaG9uZXkiLCJwcmltYXJ5Iiwic2Vjb25kYXJ5IiwidGVydGlhcnkiLCJhY2NlbnQiLCJiYWNrZ3JvdW5kIiwiYmx1ZSIsImdyZWVuIiwiZ2V0UGFydGljbGVDb3VudCIsImNhbnZhcyIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0Iiwic2V0Q2FudmFzRGltZW5zaW9ucyIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNvbG9ycyIsInBhcnRpY2xlQ29sb3JzIiwicGFydGljbGVzIiwiUGFydGljbGUiLCJ1cGRhdGUiLCJ4Iiwic3BlZWRYIiwieSIsInNwZWVkWSIsInB1bHNlRmFjdG9yIiwicHVsc2VTcGVlZCIsInNpemUiLCJiYXNlU2l6ZSIsIk1hdGgiLCJzaW4iLCJyYW5kb20iLCJzcGVlZCIsInNxcnQiLCJib29zdCIsImRyYXciLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGxTdHlsZSIsImNvbG9yIiwiZ2xvYmFsQWxwaGEiLCJvcGFjaXR5IiwiZmlsbCIsImNvbnN0cnVjdG9yIiwiZmxvb3IiLCJsZW5ndGgiLCJpbml0IiwicGFydGljbGVDb3VudCIsImkiLCJwdXNoIiwiYW5pbWF0ZSIsImNsZWFyUmVjdCIsImRyYXdIZXhhZ29uUGF0dGVybiIsImRyYXdDaXJjbGVQYXR0ZXJuIiwiZHJhd0RvdFBhdHRlcm4iLCJjb25uZWN0UGFydGljbGVzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicGFydGljbGUiLCJtYXhEaXN0YW5jZSIsImR4IiwiZHkiLCJkaXN0YW5jZSIsImdyYWRpZW50IiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJhZGRDb2xvclN0b3AiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImhleFNpemUiLCJoZXhXaWR0aCIsImhleEhlaWdodCIsIm9mZnNldFkiLCJkcmF3SGV4YWdvbiIsImNpcmNsZVJhZGl1cyIsImNpcmNsZVNwYWNpbmciLCJvZmZzZXRYIiwiY29zIiwiZG90U3BhY2luZyIsImRvdFJhZGl1cyIsImFuZ2xlIiwieFBvcyIsInlQb3MiLCJjbG9zZVBhdGgiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZ2V0QmFja2dyb3VuZFN0eWxlIiwiYmdDb2xvciIsImRpdiIsImNsYXNzTmFtZSIsInN0eWxlIiwicmVmIiwicG9pbnRlckV2ZW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/AnimatedBackground.tsx\n"));

/***/ })

});